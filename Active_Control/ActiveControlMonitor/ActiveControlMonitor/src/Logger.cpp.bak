#include "Logger.hpp"

void Logger::Logger::start()
{
    error = LoggerError::None;
#if LOG_TO_SERIAL
    Serial.begin(0);
#endif
    if (!sd.begin(SD_CS_PIN, SPI_SPEED))
    {
        error = LoggerError::SDStartError;
#if LOG_TO_SERIAL
        sd.initErrorPrint(&Serial);
#endif // LOG_TO_SERIAL
       // #if LOG_TO_BT
       //         if (BTInterface.isConnected())
       //         {
       //             sd.initErrorPrint(&BT_SERIAL);
       //         }
       // #endif
        return;
    }
    bool foundFileName = false;
    for (int i = 0; i < MAX_FILENAME_TRIES; i++)
    {
        filename[FILENAME_UNITS_POSITION] = i % 10 + 48;

        filename[FILENAME_TENS_POSITION] = i / 10 + 48;
        if (sd.exists(filename))
        {
            logMessage("Filename " + String(filename) + " exists, trying next.", LogLevel::Info);
            continue;
        }
        else
        {
            foundFileName = true;
            break;
        }
    }
    if (!foundFileName)
    {
        error = LoggerError::TooManyFilesError;
        return;
    }
    if (!file.open(filename, O_RDWR | O_CREAT | O_TRUNC | O_BINARY))
    {
        Serial.println("open failed\n");
        return;
    }

    if (!file.preAllocate(LOG_FILE_SIZE))
    {
        file.close();
        error = LoggerError::PreAllocateError;
        return;
    }

    rb.begin(&file);
}

void Logger::Logger::logData(DataPacket &data)
{
    error = LoggerError::None;
    bytesUsed = rb.bytesUsed();
    if ((bytesUsed + file.curPosition()) > (LOG_FILE_SIZE - packetSize * 2))
    {
        error = LoggerError::FileFullError;
        return;
    }
    rb.write((const uint8_t *)&data, packetSize);
    if (rb.getWriteError())
    {
        error = LoggerError::SDBufferError;
        return;
    }

#if LOG_PACKETS_TO_SERIAL
    Serial.println(data.toString());
#endif
}

void Logger::Logger::logInfo(String msg)
{
    logMessage(msg, LogLevel::Info);
}

void Logger::Logger::logError(String msg)
{
    logMessage(msg, LogLevel::Error);
}

void Logger::Logger::logDebug(String msg)
{
    logMessage(msg, LogLevel::Debug);
}

void Logger::Logger::logWarning(String msg)
{
    logMessage(msg, LogLevel::Warning);
}

void Logger::Logger::flush()
{
    if (rb.bytesUsed() > 0)
    {
        rb.sync();
    }
}

void Logger::Logger::logMessage(String msg, LogLevel level)
{
#if LOG_TO_SERIAL | LOG_TO_BT
    if (level >= LOG_LEVEL)
    {
        switch (level)
        {
        case LogLevel::Debug:
            msg = "DEBUG : " + msg;
            break;
        case LogLevel::Info:
            msg = "INFO : " + msg;
            break;
        case LogLevel::Warning:
            msg = "WARNING : " + msg;
            break;
        case LogLevel::Error:
            msg = "ERROR : " + msg;
            break;
        }
#if LOG_TO_SERIAL
        Serial.println(msg);
#endif
#if LOG_TO_BT
        BTInterface.sendBluetoothMessage(msg);
#endif
#endif // LOG_TO_SERIAL | LOG_TO_BT
    }
}

void Logger::Logger::endLog()
{
    rb.sync();
    file.truncate();
    file.rewind();
    file.close();
}

void Logger::Logger::logMessageCode(unsigned long time, OutputMessageCode errorCode)
{
    errorPacket.elapsedTime = time;
    errorPacket.message = errorCode;
    logData(errorPacket);
#if LOG_TO_SERIAL | LOG_TO_BT
    logMessage("Error code " + errorCode, LogLevel::Error);
    logMessage("Error at " + time, LogLevel::Error);
#endif
}

bool Logger::Logger::tryWrite()
{
    error = LoggerError::None;
    if (rb.bytesUsed() >= 512 && !file.isBusy())
    {
        // Not busy only allows one sector before possible busy wait.
        // Write one sector from RingBuf to file.
        if (512 != rb.writeOut(512))
        {
            error = LoggerError::SDWriteError;
            return false;
        }
    }
    return true;
}
