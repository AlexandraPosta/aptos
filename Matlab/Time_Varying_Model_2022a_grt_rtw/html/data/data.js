var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"Time_Varying_Model_2022a","ref":false,"files":[{"name":"Time_Varying_Model_2022a.c","type":"source","group":"model","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Time_Varying_Model_2022a.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"Time_Varying_Model_2022a.h\"\r\n#include \"rtwtypes.h\"\r\n#include <math.h>\r\n#include \"rt_nonfinite.h\"\r\n#include \"Time_Varying_Model_2022a_private.h\"\r\n#include <string.h>\r\n#include <emmintrin.h>\r\n#include \"rt_defines.h\"\r\n\r\n/* Block signals (default storage) */\r\nB_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_B;\r\n\r\n/* Continuous states */\r\nX_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_X;\r\n\r\n/* Disabled State Vector */\r\nXDis_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_XDis;\r\n\r\n/* Block states (default storage) */\r\nDW_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_DW;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_Time_Varying_Model_2_T Time_Varying_Model_2022a_M_;\r\nRT_MODEL_Time_Varying_Model_2_T *const Time_Varying_Model_2022a_M =\r\n  &Time_Varying_Model_2022a_M_;\r\n\r\n/* Forward declaration for local functions */\r\nstatic real_T Time_Varying_Model_2022a_norm(const real_T x[3]);\r\nstatic void rate_scheduler(void);\r\nreal_T look1_binlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n                     uint32_T maxIndex)\r\n{\r\n  real_T frac;\r\n  real_T yL_0d0;\r\n  uint32_T iLeft;\r\n\r\n  /* Column-major Lookup 1-D\r\n     Search method: 'binary'\r\n     Use previous index: 'off'\r\n     Interpolation method: 'Linear point-slope'\r\n     Extrapolation method: 'Linear'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  /* Prelookup - Index and Fraction\r\n     Index Search method: 'binary'\r\n     Extrapolation method: 'Linear'\r\n     Use previous index: 'off'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  if (u0 <= bp0[0U]) {\r\n    iLeft = 0U;\r\n    frac = (u0 - bp0[0U]) / (bp0[1U] - bp0[0U]);\r\n  } else if (u0 < bp0[maxIndex]) {\r\n    uint32_T bpIdx;\r\n    uint32_T iRght;\r\n\r\n    /* Binary Search */\r\n    bpIdx = maxIndex >> 1U;\r\n    iLeft = 0U;\r\n    iRght = maxIndex;\r\n    while (iRght - iLeft > 1U) {\r\n      if (u0 < bp0[bpIdx]) {\r\n        iRght = bpIdx;\r\n      } else {\r\n        iLeft = bpIdx;\r\n      }\r\n\r\n      bpIdx = (iRght + iLeft) >> 1U;\r\n    }\r\n\r\n    frac = (u0 - bp0[iLeft]) / (bp0[iLeft + 1U] - bp0[iLeft]);\r\n  } else {\r\n    iLeft = maxIndex - 1U;\r\n    frac = (u0 - bp0[maxIndex - 1U]) / (bp0[maxIndex] - bp0[maxIndex - 1U]);\r\n  }\r\n\r\n  /* Column-major Interpolation 1-D\r\n     Interpolation method: 'Linear point-slope'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Overflow mode: 'portable wrapping'\r\n   */\r\n  yL_0d0 = table[iLeft];\r\n  return (table[iLeft + 1U] - yL_0d0) * frac + yL_0d0;\r\n}\r\n\r\nuint32_T plook_bincpa(real_T u, const real_T bp[], uint32_T maxIndex, real_T\r\n                      *fraction, uint32_T *prevIndex)\r\n{\r\n  uint32_T bpIndex;\r\n\r\n  /* Prelookup - Index and Fraction\r\n     Index Search method: 'binary'\r\n     Extrapolation method: 'Clip'\r\n     Use previous index: 'on'\r\n     Use last breakpoint for index at or above upper limit: 'on'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  if (u <= bp[0U]) {\r\n    bpIndex = 0U;\r\n    *fraction = 0.0;\r\n  } else if (u < bp[maxIndex]) {\r\n    bpIndex = binsearch_u32d_prevIdx(u, bp, *prevIndex, maxIndex);\r\n    *fraction = (u - bp[bpIndex]) / (bp[bpIndex + 1U] - bp[bpIndex]);\r\n  } else {\r\n    bpIndex = maxIndex;\r\n    *fraction = 0.0;\r\n  }\r\n\r\n  *prevIndex = bpIndex;\r\n  return bpIndex;\r\n}\r\n\r\nreal_T intrp2d_la_pw(const uint32_T bpIndex[], const real_T frac[], const real_T\r\n                     table[], const uint32_T stride, const uint32_T maxIndex[])\r\n{\r\n  real_T y;\r\n  real_T yL_0d0;\r\n  uint32_T offset_1d;\r\n\r\n  /* Column-major Interpolation 2-D\r\n     Interpolation method: 'Linear point-slope'\r\n     Use last breakpoint for index at or above upper limit: 'on'\r\n     Overflow mode: 'portable wrapping'\r\n   */\r\n  offset_1d = bpIndex[1U] * stride + bpIndex[0U];\r\n  if (bpIndex[0U] == maxIndex[0U]) {\r\n    y = table[offset_1d];\r\n  } else {\r\n    yL_0d0 = table[offset_1d];\r\n    y = (table[offset_1d + 1U] - yL_0d0) * frac[0U] + yL_0d0;\r\n  }\r\n\r\n  if (bpIndex[1U] == maxIndex[1U]) {\r\n  } else {\r\n    offset_1d += stride;\r\n    if (bpIndex[0U] == maxIndex[0U]) {\r\n      yL_0d0 = table[offset_1d];\r\n    } else {\r\n      yL_0d0 = table[offset_1d];\r\n      yL_0d0 += (table[offset_1d + 1U] - yL_0d0) * frac[0U];\r\n    }\r\n\r\n    y += (yL_0d0 - y) * frac[1U];\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nuint32_T plook_u32d_binckan(real_T u, const real_T bp[], uint32_T maxIndex)\r\n{\r\n  uint32_T bpIndex;\r\n\r\n  /* Prelookup - Index only\r\n     Index Search method: 'binary'\r\n     Interpolation method: 'Use nearest'\r\n     Extrapolation method: 'Clip'\r\n     Use previous index: 'off'\r\n     Use last breakpoint for index at or above upper limit: 'on'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  if (u <= bp[0U]) {\r\n    bpIndex = 0U;\r\n  } else if (u < bp[maxIndex]) {\r\n    bpIndex = binsearch_u32d(u, bp, maxIndex >> 1U, maxIndex);\r\n    if ((bpIndex < maxIndex) && (bp[bpIndex + 1U] - u <= u - bp[bpIndex])) {\r\n      bpIndex++;\r\n    }\r\n  } else {\r\n    bpIndex = maxIndex;\r\n  }\r\n\r\n  return bpIndex;\r\n}\r\n\r\nuint32_T binsearch_u32d_prevIdx(real_T u, const real_T bp[], uint32_T startIndex,\r\n  uint32_T maxIndex)\r\n{\r\n  uint32_T bpIndex;\r\n  uint32_T found;\r\n  uint32_T iLeft;\r\n  uint32_T iRght;\r\n\r\n  /* Binary Search using Previous Index */\r\n  bpIndex = startIndex;\r\n  iLeft = 0U;\r\n  iRght = maxIndex;\r\n  found = 0U;\r\n  while (found == 0U) {\r\n    if (u < bp[bpIndex]) {\r\n      iRght = bpIndex - 1U;\r\n      bpIndex = ((bpIndex + iLeft) - 1U) >> 1U;\r\n    } else if (u < bp[bpIndex + 1U]) {\r\n      found = 1U;\r\n    } else {\r\n      iLeft = bpIndex + 1U;\r\n      bpIndex = ((bpIndex + iRght) + 1U) >> 1U;\r\n    }\r\n  }\r\n\r\n  return bpIndex;\r\n}\r\n\r\nuint32_T binsearch_u32d(real_T u, const real_T bp[], uint32_T startIndex,\r\n  uint32_T maxIndex)\r\n{\r\n  uint32_T bpIdx;\r\n  uint32_T bpIndex;\r\n  uint32_T iRght;\r\n\r\n  /* Binary Search */\r\n  bpIdx = startIndex;\r\n  bpIndex = 0U;\r\n  iRght = maxIndex;\r\n  while (iRght - bpIndex > 1U) {\r\n    if (u < bp[bpIdx]) {\r\n      iRght = bpIdx;\r\n    } else {\r\n      bpIndex = bpIdx;\r\n    }\r\n\r\n    bpIdx = (iRght + bpIndex) >> 1U;\r\n  }\r\n\r\n  return bpIndex;\r\n}\r\n\r\n/*\r\n *         This function updates active task flag for each subrate.\r\n *         The function is called at model base rate, hence the\r\n *         generated code self-manages all its subrates.\r\n */\r\nstatic void rate_scheduler(void)\r\n{\r\n  /* Compute which subrates run during the next base time step.  Subrates\r\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\r\n   * counter is reset when it reaches its limit (zero means run).\r\n   */\r\n  (Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[2])++;\r\n  if ((Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[2]) > 49) {/* Sample time: [0.5s, 0.0s] */\r\n    Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[2] = 0;\r\n  }\r\n\r\n  (Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[3])++;\r\n  if ((Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[3]) > 599) {/* Sample time: [6.0s, 0.0s] */\r\n    Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[3] = 0;\r\n  }\r\n}\r\n\r\n/*\r\n * This function updates continuous states using the ODE3 fixed-step\r\n * solver algorithm\r\n */\r\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\r\n{\r\n  /* Solver Matrices */\r\n  static const real_T rt_ODE3_A[3] = {\r\n    1.0/2.0, 3.0/4.0, 1.0\r\n  };\r\n\r\n  static const real_T rt_ODE3_B[3][3] = {\r\n    { 1.0/2.0, 0.0, 0.0 },\r\n\r\n    { 0.0, 3.0/4.0, 0.0 },\r\n\r\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\r\n  };\r\n\r\n  time_T t = rtsiGetT(si);\r\n  time_T tnew = rtsiGetSolverStopTime(si);\r\n  time_T h = rtsiGetStepSize(si);\r\n  real_T *x = rtsiGetContStates(si);\r\n  ODE3_IntgData *id = (ODE3_IntgData *)rtsiGetSolverData(si);\r\n  real_T *y = id->y;\r\n  real_T *f0 = id->f[0];\r\n  real_T *f1 = id->f[1];\r\n  real_T *f2 = id->f[2];\r\n  real_T hB[3];\r\n  int_T i;\r\n  int_T nXc = 25;\r\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\r\n\r\n  /* Save the state values at time t in y, we'll use x as ynew. */\r\n  (void) memcpy(y, x,\r\n                (uint_T)nXc*sizeof(real_T));\r\n\r\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\r\n  /* f0 = f(t,y) */\r\n  rtsiSetdX(si, f0);\r\n  Time_Varying_Model_2022a_derivatives();\r\n\r\n  /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\r\n  hB[0] = h * rt_ODE3_B[0][0];\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\r\n  rtsiSetdX(si, f1);\r\n  Time_Varying_Model_2022a_step();\r\n  Time_Varying_Model_2022a_derivatives();\r\n\r\n  /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\r\n  for (i = 0; i <= 1; i++) {\r\n    hB[i] = h * rt_ODE3_B[1][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\r\n  }\r\n\r\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\r\n  rtsiSetdX(si, f2);\r\n  Time_Varying_Model_2022a_step();\r\n  Time_Varying_Model_2022a_derivatives();\r\n\r\n  /* tnew = t + hA(3);\r\n     ynew = y + f*hB(:,3); */\r\n  for (i = 0; i <= 2; i++) {\r\n    hB[i] = h * rt_ODE3_B[2][i];\r\n  }\r\n\r\n  for (i = 0; i < nXc; i++) {\r\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\r\n  }\r\n\r\n  rtsiSetT(si, tnew);\r\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\r\n}\r\n\r\nreal_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u)\r\n{\r\n  uint32_T hi;\r\n  uint32_T lo;\r\n\r\n  /* Uniform random number generator (random number between 0 and 1)\r\n\r\n     #define IA      16807                      magic multiplier = 7^5\r\n     #define IM      2147483647                 modulus = 2^31-1\r\n     #define IQ      127773                     IM div IA\r\n     #define IR      2836                       IM modulo IA\r\n     #define S       4.656612875245797e-10      reciprocal of 2^31-1\r\n     test = IA * (seed % IQ) - IR * (seed/IQ)\r\n     seed = test < 0 ? (test + IM) : test\r\n     return (seed*S)\r\n   */\r\n  lo = *u % 127773U * 16807U;\r\n  hi = *u / 127773U * 2836U;\r\n  if (lo < hi) {\r\n    *u = 2147483647U - (hi - lo);\r\n  } else {\r\n    *u = lo - hi;\r\n  }\r\n\r\n  return (real_T)*u * 4.6566128752457969E-10;\r\n}\r\n\r\nreal_T rt_nrand_Upu32_Yd_f_pw_snf(uint32_T *u)\r\n{\r\n  real_T si;\r\n  real_T sr;\r\n  real_T y;\r\n\r\n  /* Normal (Gaussian) random number generator */\r\n  do {\r\n    sr = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;\r\n    si = 2.0 * rt_urand_Upu32_Yd_f_pw_snf(u) - 1.0;\r\n    si = sr * sr + si * si;\r\n  } while (si > 1.0);\r\n\r\n  y = sqrt(-2.0 * log(si) / si) * sr;\r\n  return y;\r\n}\r\n\r\nreal_T rt_powd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else {\r\n    real_T tmp;\r\n    real_T tmp_0;\r\n    tmp = fabs(u0);\r\n    tmp_0 = fabs(u1);\r\n    if (rtIsInf(u1)) {\r\n      if (tmp == 1.0) {\r\n        y = 1.0;\r\n      } else if (tmp > 1.0) {\r\n        if (u1 > 0.0) {\r\n          y = (rtInf);\r\n        } else {\r\n          y = 0.0;\r\n        }\r\n      } else if (u1 > 0.0) {\r\n        y = 0.0;\r\n      } else {\r\n        y = (rtInf);\r\n      }\r\n    } else if (tmp_0 == 0.0) {\r\n      y = 1.0;\r\n    } else if (tmp_0 == 1.0) {\r\n      if (u1 > 0.0) {\r\n        y = u0;\r\n      } else {\r\n        y = 1.0 / u0;\r\n      }\r\n    } else if (u1 == 2.0) {\r\n      y = u0 * u0;\r\n    } else if ((u1 == 0.5) && (u0 >= 0.0)) {\r\n      y = sqrt(u0);\r\n    } else if ((u0 < 0.0) && (u1 > floor(u1))) {\r\n      y = (rtNaN);\r\n    } else {\r\n      y = pow(u0, u1);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\r\n    int32_T tmp;\r\n    int32_T tmp_0;\r\n    if (u1 > 0.0) {\r\n      tmp = 1;\r\n    } else {\r\n      tmp = -1;\r\n    }\r\n\r\n    if (u0 > 0.0) {\r\n      tmp_0 = 1;\r\n    } else {\r\n      tmp_0 = -1;\r\n    }\r\n\r\n    y = atan2(tmp_0, tmp);\r\n  } else if (u1 == 0.0) {\r\n    if (u0 > 0.0) {\r\n      y = RT_PI / 2.0;\r\n    } else if (u0 < 0.0) {\r\n      y = -(RT_PI / 2.0);\r\n    } else {\r\n      y = 0.0;\r\n    }\r\n  } else {\r\n    y = atan2(u0, u1);\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Function for MATLAB Function: '<S1>/MATLAB Function5' */\r\nstatic real_T Time_Varying_Model_2022a_norm(const real_T x[3])\r\n{\r\n  real_T absxk;\r\n  real_T scale;\r\n  real_T t;\r\n  real_T y;\r\n  scale = 3.3121686421112381E-170;\r\n  absxk = fabs(x[0]);\r\n  if (absxk > 3.3121686421112381E-170) {\r\n    y = 1.0;\r\n    scale = absxk;\r\n  } else {\r\n    t = absxk / 3.3121686421112381E-170;\r\n    y = t * t;\r\n  }\r\n\r\n  absxk = fabs(x[1]);\r\n  if (absxk > scale) {\r\n    t = scale / absxk;\r\n    y = y * t * t + 1.0;\r\n    scale = absxk;\r\n  } else {\r\n    t = absxk / scale;\r\n    y += t * t;\r\n  }\r\n\r\n  absxk = fabs(x[2]);\r\n  if (absxk > scale) {\r\n    t = scale / absxk;\r\n    y = y * t * t + 1.0;\r\n    scale = absxk;\r\n  } else {\r\n    t = absxk / scale;\r\n    y += t * t;\r\n  }\r\n\r\n  return scale * sqrt(y);\r\n}\r\n\r\n/* Model step function */\r\nvoid Time_Varying_Model_2022a_step(void)\r\n{\r\n  __m128d tmp_0;\r\n  __m128d tmp_1;\r\n  real_T rotmZYX[9];\r\n  real_T tmp[6];\r\n  real_T frac[2];\r\n  real_T ang_cos;\r\n  real_T ang_sin;\r\n  real_T ct_idx_0;\r\n  real_T ct_idx_1;\r\n  real_T ct_idx_2;\r\n  real_T rotmZYX_tmp;\r\n  real_T st;\r\n  real_T st_idx_1;\r\n  real_T *tmp_2;\r\n  int32_T K_tmp;\r\n  int32_T K_tmp_0;\r\n  int32_T i;\r\n  int32_T i_0;\r\n  uint32_T bpIndex[2];\r\n  uint32_T bpIdx;\r\n  int8_T rtAction;\r\n  boolean_T limitedCache_idx_0;\r\n  boolean_T limitedCache_idx_1;\r\n  boolean_T limitedCache_idx_2;\r\n  boolean_T limitedCache_idx_3;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M)) {\r\n    /* set solver stop time */\r\n    if (!(Time_Varying_Model_2022a_M->Timing.clockTick0+1)) {\r\n      rtsiSetSolverStopTime(&Time_Varying_Model_2022a_M->solverInfo,\r\n                            ((Time_Varying_Model_2022a_M->Timing.clockTickH0 + 1)\r\n        * Time_Varying_Model_2022a_M->Timing.stepSize0 * 4294967296.0));\r\n    } else {\r\n      rtsiSetSolverStopTime(&Time_Varying_Model_2022a_M->solverInfo,\r\n                            ((Time_Varying_Model_2022a_M->Timing.clockTick0 + 1)\r\n        * Time_Varying_Model_2022a_M->Timing.stepSize0 +\r\n        Time_Varying_Model_2022a_M->Timing.clockTickH0 *\r\n        Time_Varying_Model_2022a_M->Timing.stepSize0 * 4294967296.0));\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  /* Update absolute time of base rate at minor time step */\r\n  if (rtmIsMinorTimeStep(Time_Varying_Model_2022a_M)) {\r\n    Time_Varying_Model_2022a_M->Timing.t[0] = rtsiGetT\r\n      (&Time_Varying_Model_2022a_M->solverInfo);\r\n  }\r\n\r\n  /* Integrator: '<S16>/Integrator4' */\r\n  Time_Varying_Model_2022a_B.Integrator4 =\r\n    Time_Varying_Model_2022a_X.Integrator4_CSTATE;\r\n\r\n  /* Gain: '<S21>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain = Time_Varying_Model_2022a_P.Gain_Gain_h *\r\n    Time_Varying_Model_2022a_B.Integrator4;\r\n\r\n  /* Outport: '<Root>/thetaOut' */\r\n  Time_Varying_Model_2022a_Y.pitchAngle = Time_Varying_Model_2022a_B.Gain;\r\n\r\n  /* Clock: '<Root>/Clock' */\r\n  Time_Varying_Model_2022a_B.Clock = Time_Varying_Model_2022a_M->Timing.t[0];\r\n\r\n  /* Lookup_n-D: '<Root>/OpenRocket Velocity' incorporates:\r\n   *  Clock: '<Root>/Clock'\r\n   */\r\n  Time_Varying_Model_2022a_B.OpenRocketVelocity = look1_binlxpw\r\n    (Time_Varying_Model_2022a_B.Clock,\r\n     Time_Varying_Model_2022a_P.OpenRocketVelocity_bp01Data,\r\n     Time_Varying_Model_2022a_P.OpenRocketVelocity_tableData, 222U);\r\n\r\n  /* Switch: '<S15>/Switch' */\r\n  if (Time_Varying_Model_2022a_B.OpenRocketVelocity >=\r\n      Time_Varying_Model_2022a_P.Switch_Threshold) {\r\n    /* Switch: '<S15>/Switch' incorporates:\r\n     *  Constant: '<S15>/Constant'\r\n     */\r\n    Time_Varying_Model_2022a_B.Switch =\r\n      Time_Varying_Model_2022a_P.Constant_Value_j;\r\n  } else {\r\n    /* Switch: '<S15>/Switch' incorporates:\r\n     *  Constant: '<S15>/Constant1'\r\n     */\r\n    Time_Varying_Model_2022a_B.Switch =\r\n      Time_Varying_Model_2022a_P.Constant1_Value_p;\r\n  }\r\n\r\n  /* End of Switch: '<S15>/Switch' */\r\n\r\n  /* Lookup_n-D: '<S9>/1-D Lookup Table' incorporates:\r\n   *  Lookup_n-D: '<Root>/OpenRocket Velocity'\r\n   */\r\n  bpIdx = plook_u32d_binckan(Time_Varying_Model_2022a_B.OpenRocketVelocity,\r\n    Time_Varying_Model_2022a_P.uDLookupTable_bp01Data, 49U);\r\n\r\n  /* Lookup_n-D: '<S9>/1-D Lookup Table' */\r\n  Time_Varying_Model_2022a_B.uDLookupTable =\r\n    Time_Varying_Model_2022a_P.uDLookupTable_tableData[bpIdx];\r\n\r\n  /* Selector: '<S9>/Selector' */\r\n  i_0 = Time_Varying_Model_2022a_B.uDLookupTable;\r\n  for (i = 0; i < 6; i++) {\r\n    /* Selector: '<S9>/Selector' incorporates:\r\n     *  Constant: '<S9>/Constant'\r\n     */\r\n    K_tmp = i << 2;\r\n    K_tmp_0 = (i_0 - 1) * 24 + K_tmp;\r\n\r\n    /* Selector: '<S9>/Selector' incorporates:\r\n     *  Constant: '<S9>/Constant'\r\n     */\r\n    Time_Varying_Model_2022a_B.K[K_tmp] =\r\n      Time_Varying_Model_2022a_P.Constant_Value_l[K_tmp_0];\r\n    Time_Varying_Model_2022a_B.K[K_tmp + 1] =\r\n      Time_Varying_Model_2022a_P.Constant_Value_l[K_tmp_0 + 1];\r\n    Time_Varying_Model_2022a_B.K[K_tmp + 2] =\r\n      Time_Varying_Model_2022a_P.Constant_Value_l[K_tmp_0 + 2];\r\n    Time_Varying_Model_2022a_B.K[K_tmp + 3] =\r\n      Time_Varying_Model_2022a_P.Constant_Value_l[K_tmp_0 + 3];\r\n  }\r\n\r\n  /* Integrator: '<S16>/Integrator5' */\r\n  Time_Varying_Model_2022a_B.Integrator5 =\r\n    Time_Varying_Model_2022a_X.Integrator5_CSTATE;\r\n\r\n  /* Integrator: '<S16>/Integrator3' */\r\n  Time_Varying_Model_2022a_B.Integrator3 =\r\n    Time_Varying_Model_2022a_X.Integrator3_CSTATE;\r\n\r\n  /* Integrator: '<S16>/Integrator2' */\r\n  Time_Varying_Model_2022a_B.Integrator2 =\r\n    Time_Varying_Model_2022a_X.Integrator2_CSTATE;\r\n\r\n  /* Integrator: '<S16>/Integrator' */\r\n  Time_Varying_Model_2022a_B.Integrator =\r\n    Time_Varying_Model_2022a_X.Integrator_CSTATE;\r\n\r\n  /* Integrator: '<S16>/Integrator1' */\r\n  Time_Varying_Model_2022a_B.Integrator1 =\r\n    Time_Varying_Model_2022a_X.Integrator1_CSTATE;\r\n\r\n  /* Sum: '<Root>/Sum1' incorporates:\r\n   *  Constant: '<Root>/p'\r\n   *  Constant: '<Root>/phi'\r\n   *  Constant: '<Root>/psi'\r\n   *  Constant: '<Root>/q'\r\n   *  Constant: '<Root>/r'\r\n   *  Constant: '<Root>/theta'\r\n   */\r\n  Time_Varying_Model_2022a_B.Sum1[0] = Time_Varying_Model_2022a_P.phi_Value -\r\n    Time_Varying_Model_2022a_B.Integrator5;\r\n  Time_Varying_Model_2022a_B.Sum1[1] = Time_Varying_Model_2022a_P.theta_Value -\r\n    Time_Varying_Model_2022a_B.Integrator4;\r\n  Time_Varying_Model_2022a_B.Sum1[2] = Time_Varying_Model_2022a_P.psi_Value -\r\n    Time_Varying_Model_2022a_B.Integrator3;\r\n  Time_Varying_Model_2022a_B.Sum1[3] = Time_Varying_Model_2022a_P.p_Value -\r\n    Time_Varying_Model_2022a_B.Integrator2;\r\n  Time_Varying_Model_2022a_B.Sum1[4] = Time_Varying_Model_2022a_P.q_Value -\r\n    Time_Varying_Model_2022a_B.Integrator;\r\n  Time_Varying_Model_2022a_B.Sum1[5] = Time_Varying_Model_2022a_P.r_Value -\r\n    Time_Varying_Model_2022a_B.Integrator1;\r\n\r\n  /* Product: '<Root>/Matrix Multiply' incorporates:\r\n   *  Selector: '<S9>/Selector'\r\n   */\r\n  tmp_2 = &Time_Varying_Model_2022a_B.K[0];\r\n  for (i = 0; i < 6; i++) {\r\n    tmp[i] = Time_Varying_Model_2022a_B.Sum1[i];\r\n  }\r\n\r\n  for (i = 0; i < 4; i++) {\r\n    ct_idx_2 = 0.0;\r\n    for (i_0 = 0; i_0 < 6; i_0++) {\r\n      ct_idx_2 += tmp_2[(i_0 << 2) + i] * tmp[i_0];\r\n    }\r\n\r\n    /* Product: '<Root>/Matrix Multiply' */\r\n    Time_Varying_Model_2022a_B.MatrixMultiply[i] = ct_idx_2;\r\n\r\n    /* Product: '<Root>/Product' */\r\n    Time_Varying_Model_2022a_B.Product[i] = Time_Varying_Model_2022a_B.Switch *\r\n      ct_idx_2;\r\n  }\r\n\r\n  /* End of Product: '<Root>/Matrix Multiply' */\r\n\r\n  /* RateLimiter: '<Root>/Motor Speed' */\r\n  if (Time_Varying_Model_2022a_DW.LastMajorTime == (rtInf)) {\r\n    /* RateLimiter: '<Root>/Motor Speed' */\r\n    Time_Varying_Model_2022a_B.MotorSpeed[0] =\r\n      Time_Varying_Model_2022a_B.Product[0];\r\n    Time_Varying_Model_2022a_B.MotorSpeed[1] =\r\n      Time_Varying_Model_2022a_B.Product[1];\r\n    Time_Varying_Model_2022a_B.MotorSpeed[2] =\r\n      Time_Varying_Model_2022a_B.Product[2];\r\n    Time_Varying_Model_2022a_B.MotorSpeed[3] =\r\n      Time_Varying_Model_2022a_B.Product[3];\r\n  } else {\r\n    ang_cos = Time_Varying_Model_2022a_M->Timing.t[0] -\r\n      Time_Varying_Model_2022a_DW.LastMajorTime;\r\n    if (Time_Varying_Model_2022a_DW.LastMajorTime ==\r\n        Time_Varying_Model_2022a_M->Timing.t[0]) {\r\n      if (Time_Varying_Model_2022a_DW.PrevLimited[0]) {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[0] =\r\n          Time_Varying_Model_2022a_DW.PrevY[0];\r\n      } else {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[0] =\r\n          Time_Varying_Model_2022a_B.Product[0];\r\n      }\r\n\r\n      if (Time_Varying_Model_2022a_DW.PrevLimited[1]) {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[1] =\r\n          Time_Varying_Model_2022a_DW.PrevY[1];\r\n      } else {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[1] =\r\n          Time_Varying_Model_2022a_B.Product[1];\r\n      }\r\n\r\n      if (Time_Varying_Model_2022a_DW.PrevLimited[2]) {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[2] =\r\n          Time_Varying_Model_2022a_DW.PrevY[2];\r\n      } else {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[2] =\r\n          Time_Varying_Model_2022a_B.Product[2];\r\n      }\r\n\r\n      if (Time_Varying_Model_2022a_DW.PrevLimited[3]) {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[3] =\r\n          Time_Varying_Model_2022a_DW.PrevY[3];\r\n      } else {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[3] =\r\n          Time_Varying_Model_2022a_B.Product[3];\r\n      }\r\n    } else {\r\n      ct_idx_2 = ang_cos * Time_Varying_Model_2022a_P.MotorSpeed_RisingLim;\r\n      ang_sin = Time_Varying_Model_2022a_B.Product[0];\r\n      st_idx_1 = Time_Varying_Model_2022a_DW.PrevY[0];\r\n      ct_idx_0 = ang_sin - st_idx_1;\r\n      if (ct_idx_0 > ct_idx_2) {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[0] = st_idx_1 + ct_idx_2;\r\n        limitedCache_idx_0 = true;\r\n      } else {\r\n        ct_idx_2 = ang_cos * Time_Varying_Model_2022a_P.MotorSpeed_FallingLim;\r\n        if (ct_idx_0 < ct_idx_2) {\r\n          Time_Varying_Model_2022a_B.MotorSpeed[0] = st_idx_1 + ct_idx_2;\r\n          limitedCache_idx_0 = true;\r\n        } else {\r\n          Time_Varying_Model_2022a_B.MotorSpeed[0] = ang_sin;\r\n          limitedCache_idx_0 = false;\r\n        }\r\n      }\r\n\r\n      ct_idx_2 = ang_cos * Time_Varying_Model_2022a_P.MotorSpeed_RisingLim;\r\n      ang_sin = Time_Varying_Model_2022a_B.Product[1];\r\n      st_idx_1 = Time_Varying_Model_2022a_DW.PrevY[1];\r\n      ct_idx_0 = ang_sin - st_idx_1;\r\n      if (ct_idx_0 > ct_idx_2) {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[1] = st_idx_1 + ct_idx_2;\r\n        limitedCache_idx_1 = true;\r\n      } else {\r\n        ct_idx_2 = ang_cos * Time_Varying_Model_2022a_P.MotorSpeed_FallingLim;\r\n        if (ct_idx_0 < ct_idx_2) {\r\n          Time_Varying_Model_2022a_B.MotorSpeed[1] = st_idx_1 + ct_idx_2;\r\n          limitedCache_idx_1 = true;\r\n        } else {\r\n          Time_Varying_Model_2022a_B.MotorSpeed[1] = ang_sin;\r\n          limitedCache_idx_1 = false;\r\n        }\r\n      }\r\n\r\n      ct_idx_2 = ang_cos * Time_Varying_Model_2022a_P.MotorSpeed_RisingLim;\r\n      ang_sin = Time_Varying_Model_2022a_B.Product[2];\r\n      st_idx_1 = Time_Varying_Model_2022a_DW.PrevY[2];\r\n      ct_idx_0 = ang_sin - st_idx_1;\r\n      if (ct_idx_0 > ct_idx_2) {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[2] = st_idx_1 + ct_idx_2;\r\n        limitedCache_idx_2 = true;\r\n      } else {\r\n        ct_idx_2 = ang_cos * Time_Varying_Model_2022a_P.MotorSpeed_FallingLim;\r\n        if (ct_idx_0 < ct_idx_2) {\r\n          Time_Varying_Model_2022a_B.MotorSpeed[2] = st_idx_1 + ct_idx_2;\r\n          limitedCache_idx_2 = true;\r\n        } else {\r\n          Time_Varying_Model_2022a_B.MotorSpeed[2] = ang_sin;\r\n          limitedCache_idx_2 = false;\r\n        }\r\n      }\r\n\r\n      ct_idx_2 = ang_cos * Time_Varying_Model_2022a_P.MotorSpeed_RisingLim;\r\n      ang_sin = Time_Varying_Model_2022a_B.Product[3];\r\n      st_idx_1 = Time_Varying_Model_2022a_DW.PrevY[3];\r\n      ct_idx_0 = ang_sin - st_idx_1;\r\n      if (ct_idx_0 > ct_idx_2) {\r\n        Time_Varying_Model_2022a_B.MotorSpeed[3] = st_idx_1 + ct_idx_2;\r\n        limitedCache_idx_3 = true;\r\n      } else {\r\n        ct_idx_2 = ang_cos * Time_Varying_Model_2022a_P.MotorSpeed_FallingLim;\r\n        if (ct_idx_0 < ct_idx_2) {\r\n          Time_Varying_Model_2022a_B.MotorSpeed[3] = st_idx_1 + ct_idx_2;\r\n          limitedCache_idx_3 = true;\r\n        } else {\r\n          Time_Varying_Model_2022a_B.MotorSpeed[3] = ang_sin;\r\n          limitedCache_idx_3 = false;\r\n        }\r\n      }\r\n\r\n      if (rtsiIsModeUpdateTimeStep(&Time_Varying_Model_2022a_M->solverInfo)) {\r\n        Time_Varying_Model_2022a_DW.PrevLimited[0] = limitedCache_idx_0;\r\n        Time_Varying_Model_2022a_DW.PrevLimited[1] = limitedCache_idx_1;\r\n        Time_Varying_Model_2022a_DW.PrevLimited[2] = limitedCache_idx_2;\r\n        Time_Varying_Model_2022a_DW.PrevLimited[3] = limitedCache_idx_3;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* End of RateLimiter: '<Root>/Motor Speed' */\r\n\r\n  /* Saturate: '<Root>/Max Deflection' */\r\n  ang_cos = Time_Varying_Model_2022a_B.MotorSpeed[0];\r\n  if (ang_cos > Time_Varying_Model_2022a_P.MaxDeflection_UpperSat) {\r\n    ang_cos = Time_Varying_Model_2022a_P.MaxDeflection_UpperSat;\r\n  } else if (ang_cos < Time_Varying_Model_2022a_P.MaxDeflection_LowerSat) {\r\n    ang_cos = Time_Varying_Model_2022a_P.MaxDeflection_LowerSat;\r\n  }\r\n\r\n  /* Saturate: '<Root>/Max Deflection' */\r\n  Time_Varying_Model_2022a_B.MaxDeflection[0] = ang_cos;\r\n\r\n  /* Saturate: '<Root>/Max Deflection' */\r\n  ang_cos = Time_Varying_Model_2022a_B.MotorSpeed[1];\r\n  if (ang_cos > Time_Varying_Model_2022a_P.MaxDeflection_UpperSat) {\r\n    ang_cos = Time_Varying_Model_2022a_P.MaxDeflection_UpperSat;\r\n  } else if (ang_cos < Time_Varying_Model_2022a_P.MaxDeflection_LowerSat) {\r\n    ang_cos = Time_Varying_Model_2022a_P.MaxDeflection_LowerSat;\r\n  }\r\n\r\n  /* Saturate: '<Root>/Max Deflection' */\r\n  Time_Varying_Model_2022a_B.MaxDeflection[1] = ang_cos;\r\n\r\n  /* Saturate: '<Root>/Max Deflection' */\r\n  ang_cos = Time_Varying_Model_2022a_B.MotorSpeed[2];\r\n  if (ang_cos > Time_Varying_Model_2022a_P.MaxDeflection_UpperSat) {\r\n    ang_cos = Time_Varying_Model_2022a_P.MaxDeflection_UpperSat;\r\n  } else if (ang_cos < Time_Varying_Model_2022a_P.MaxDeflection_LowerSat) {\r\n    ang_cos = Time_Varying_Model_2022a_P.MaxDeflection_LowerSat;\r\n  }\r\n\r\n  /* Saturate: '<Root>/Max Deflection' */\r\n  Time_Varying_Model_2022a_B.MaxDeflection[2] = ang_cos;\r\n\r\n  /* Saturate: '<Root>/Max Deflection' */\r\n  ang_cos = Time_Varying_Model_2022a_B.MotorSpeed[3];\r\n  if (ang_cos > Time_Varying_Model_2022a_P.MaxDeflection_UpperSat) {\r\n    ang_cos = Time_Varying_Model_2022a_P.MaxDeflection_UpperSat;\r\n  } else if (ang_cos < Time_Varying_Model_2022a_P.MaxDeflection_LowerSat) {\r\n    ang_cos = Time_Varying_Model_2022a_P.MaxDeflection_LowerSat;\r\n  }\r\n\r\n  /* Saturate: '<Root>/Max Deflection' */\r\n  Time_Varying_Model_2022a_B.MaxDeflection[3] = ang_cos;\r\n\r\n  /* Gain: '<S22>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_j = Time_Varying_Model_2022a_P.Gain_Gain_i *\r\n    Time_Varying_Model_2022a_B.MaxDeflection[0];\r\n\r\n  /* Outport: '<Root>/x1Out' */\r\n  Time_Varying_Model_2022a_Y.x1 = Time_Varying_Model_2022a_B.Gain_j;\r\n\r\n  /* Gain: '<S23>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_l = Time_Varying_Model_2022a_P.Gain_Gain_oo *\r\n    Time_Varying_Model_2022a_B.MaxDeflection[1];\r\n\r\n  /* Outport: '<Root>/x2Out' */\r\n  Time_Varying_Model_2022a_Y.x2 = Time_Varying_Model_2022a_B.Gain_l;\r\n\r\n  /* Gain: '<S24>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_g = Time_Varying_Model_2022a_P.Gain_Gain_p *\r\n    Time_Varying_Model_2022a_B.MaxDeflection[2];\r\n\r\n  /* Outport: '<Root>/y1Out' */\r\n  Time_Varying_Model_2022a_Y.y1 = Time_Varying_Model_2022a_B.Gain_g;\r\n\r\n  /* Gain: '<S25>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_f = Time_Varying_Model_2022a_P.Gain_Gain_f *\r\n    Time_Varying_Model_2022a_B.MaxDeflection[3];\r\n\r\n  /* Outport: '<Root>/y2Out' */\r\n  Time_Varying_Model_2022a_Y.y2 = Time_Varying_Model_2022a_B.Gain_f;\r\n\r\n  /* Outport: '<Root>/vOut' */\r\n  Time_Varying_Model_2022a_Y.v = Time_Varying_Model_2022a_B.OpenRocketVelocity;\r\n\r\n  /* Lookup_n-D: '<Root>/OpenRocket alt' incorporates:\r\n   *  Clock: '<Root>/Clock'\r\n   */\r\n  Time_Varying_Model_2022a_B.OpenRocketalt = look1_binlxpw\r\n    (Time_Varying_Model_2022a_B.Clock,\r\n     Time_Varying_Model_2022a_P.OpenRocketalt_bp01Data,\r\n     Time_Varying_Model_2022a_P.OpenRocketalt_tableData, 222U);\r\n\r\n  /* UnitConversion: '<S115>/Unit Conversion' */\r\n  /* Unit Conversion - from: m to: ft\r\n     Expression: output = (3.28084*input) + (0) */\r\n  Time_Varying_Model_2022a_B.UnitConversion = 3.280839895013123 *\r\n    Time_Varying_Model_2022a_B.OpenRocketalt;\r\n\r\n  /* UnitConversion: '<S121>/Unit Conversion' */\r\n  /* Unit Conversion - from: m/s to: ft/s\r\n     Expression: output = (3.28084*input) + (0) */\r\n  Time_Varying_Model_2022a_B.UnitConversion_e = 3.280839895013123 *\r\n    Time_Varying_Model_2022a_B.OpenRocketVelocity;\r\n\r\n  /* Saturate: '<S148>/Limit Function 10ft to 1000ft' */\r\n  if (Time_Varying_Model_2022a_B.UnitConversion >\r\n      Time_Varying_Model_2022a_P.LimitFunction10ftto1000ft_Upper) {\r\n    /* Saturate: '<S148>/Limit Function 10ft to 1000ft' */\r\n    Time_Varying_Model_2022a_B.LimitFunction10ftto1000ft =\r\n      Time_Varying_Model_2022a_P.LimitFunction10ftto1000ft_Upper;\r\n  } else if (Time_Varying_Model_2022a_B.UnitConversion <\r\n             Time_Varying_Model_2022a_P.LimitFunction10ftto1000ft_Lower) {\r\n    /* Saturate: '<S148>/Limit Function 10ft to 1000ft' */\r\n    Time_Varying_Model_2022a_B.LimitFunction10ftto1000ft =\r\n      Time_Varying_Model_2022a_P.LimitFunction10ftto1000ft_Lower;\r\n  } else {\r\n    /* Saturate: '<S148>/Limit Function 10ft to 1000ft' */\r\n    Time_Varying_Model_2022a_B.LimitFunction10ftto1000ft =\r\n      Time_Varying_Model_2022a_B.UnitConversion;\r\n  }\r\n\r\n  /* End of Saturate: '<S148>/Limit Function 10ft to 1000ft' */\r\n\r\n  /* Fcn: '<S148>/Low Altitude Scale Length' */\r\n  ang_cos = 0.000823 * Time_Varying_Model_2022a_B.LimitFunction10ftto1000ft +\r\n    0.177;\r\n  if (ang_cos < 0.0) {\r\n    ang_sin = -rt_powd_snf(-ang_cos, 1.2);\r\n  } else {\r\n    ang_sin = rt_powd_snf(ang_cos, 1.2);\r\n  }\r\n\r\n  /* Fcn: '<S148>/Low Altitude Scale Length' */\r\n  Time_Varying_Model_2022a_B.LowAltitudeScaleLength =\r\n    Time_Varying_Model_2022a_B.LimitFunction10ftto1000ft / ang_sin;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n    /* UnitConversion: '<S150>/Unit Conversion' incorporates:\r\n     *  Constant: '<S149>/Medium//High Altitude'\r\n     */\r\n    /* Unit Conversion - from: m to: ft\r\n       Expression: output = (3.28084*input) + (0) */\r\n    Time_Varying_Model_2022a_B.UnitConversion_f = 3.280839895013123 *\r\n      Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelContin;\r\n  }\r\n\r\n  /* Saturate: '<S131>/Limit Height h<1000ft' */\r\n  if (Time_Varying_Model_2022a_B.UnitConversion >\r\n      Time_Varying_Model_2022a_P.LimitHeighth1000ft_UpperSat) {\r\n    /* Saturate: '<S131>/Limit Height h<1000ft' */\r\n    Time_Varying_Model_2022a_B.LimitHeighth1000ft =\r\n      Time_Varying_Model_2022a_P.LimitHeighth1000ft_UpperSat;\r\n  } else if (Time_Varying_Model_2022a_B.UnitConversion <\r\n             Time_Varying_Model_2022a_P.LimitHeighth1000ft_LowerSat) {\r\n    /* Saturate: '<S131>/Limit Height h<1000ft' */\r\n    Time_Varying_Model_2022a_B.LimitHeighth1000ft =\r\n      Time_Varying_Model_2022a_P.LimitHeighth1000ft_LowerSat;\r\n  } else {\r\n    /* Saturate: '<S131>/Limit Height h<1000ft' */\r\n    Time_Varying_Model_2022a_B.LimitHeighth1000ft =\r\n      Time_Varying_Model_2022a_B.UnitConversion;\r\n  }\r\n\r\n  /* End of Saturate: '<S131>/Limit Height h<1000ft' */\r\n\r\n  /* Fcn: '<S131>/Low Altitude Intensity' */\r\n  ang_cos = 0.000823 * Time_Varying_Model_2022a_B.LimitHeighth1000ft + 0.177;\r\n  if (ang_cos < 0.0) {\r\n    ang_sin = -rt_powd_snf(-ang_cos, 0.4);\r\n  } else {\r\n    ang_sin = rt_powd_snf(ang_cos, 0.4);\r\n  }\r\n\r\n  /* Fcn: '<S131>/Low Altitude Intensity' */\r\n  Time_Varying_Model_2022a_B.LowAltitudeIntensity = 1.0 / ang_sin;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n    /* UnitConversion: '<S122>/Unit Conversion' incorporates:\r\n     *  Constant: '<S110>/Windspeed at 20ft (6m)'\r\n     */\r\n    /* Unit Conversion - from: m/s to: ft/s\r\n       Expression: output = (3.28084*input) + (0) */\r\n    Time_Varying_Model_2022a_B.UnitConversion_g = 3.280839895013123 *\r\n      Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_i;\r\n\r\n    /* Gain: '<S131>/sigma_wg ' */\r\n    Time_Varying_Model_2022a_B.sigma_wg =\r\n      Time_Varying_Model_2022a_P.sigma_wg_Gain *\r\n      Time_Varying_Model_2022a_B.UnitConversion_g;\r\n  }\r\n\r\n  /* Product: '<S131>/sigma_ug, sigma_vg' */\r\n  Time_Varying_Model_2022a_B.sigma_ugsigma_vg =\r\n    Time_Varying_Model_2022a_B.LowAltitudeIntensity *\r\n    Time_Varying_Model_2022a_B.sigma_wg;\r\n\r\n  /* PreLookup: '<S130>/PreLook-Up Index Search  (altitude)' */\r\n  Time_Varying_Model_2022a_B.PreLookUpIndexSearchaltitude_o1 = plook_bincpa\r\n    (Time_Varying_Model_2022a_B.UnitConversion,\r\n     Time_Varying_Model_2022a_P.PreLookUpIndexSearchaltitude_Br, 11U,\r\n     &Time_Varying_Model_2022a_B.PreLookUpIndexSearchaltitude_o2,\r\n     &Time_Varying_Model_2022a_DW.PreLookUpIndexSearchaltitude_DW);\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n    /* PreLookup: '<S130>/PreLook-Up Index Search  (prob of exceed)' incorporates:\r\n     *  Constant: '<S130>/Probability of  Exceedance'\r\n     */\r\n    Time_Varying_Model_2022a_B.PreLookUpIndexSearchprobofexc_m = plook_bincpa\r\n      (Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCon_au,\r\n       Time_Varying_Model_2022a_P.PreLookUpIndexSearchprobofexcee, 6U,\r\n       &Time_Varying_Model_2022a_B.PreLookUpIndexSearchprobofexcee,\r\n       &Time_Varying_Model_2022a_DW.PreLookUpIndexSearchprobofexcee);\r\n  }\r\n\r\n  /* Interpolation_n-D: '<S130>/Medium//High Altitude Intensity' */\r\n  ang_cos = Time_Varying_Model_2022a_B.PreLookUpIndexSearchaltitude_o2;\r\n  frac[0] = ang_cos;\r\n  ang_cos = Time_Varying_Model_2022a_B.PreLookUpIndexSearchprobofexcee;\r\n  frac[1] = ang_cos;\r\n  bpIdx = Time_Varying_Model_2022a_B.PreLookUpIndexSearchaltitude_o1;\r\n  bpIndex[0] = bpIdx;\r\n  bpIdx = Time_Varying_Model_2022a_B.PreLookUpIndexSearchprobofexc_m;\r\n  bpIndex[1] = bpIdx;\r\n\r\n  /* Interpolation_n-D: '<S130>/Medium//High Altitude Intensity' */\r\n  Time_Varying_Model_2022a_B.MediumHighAltitudeIntensity = intrp2d_la_pw(bpIndex,\r\n    frac, Time_Varying_Model_2022a_P.MediumHighAltitudeIntensity_Tab, 12U,\r\n    Time_Varying_Model_2022a_P.MediumHighAltitudeIntensity_max);\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[2] == 0) {\r\n    /* Sqrt: '<S123>/Sqrt1' incorporates:\r\n     *  Constant: '<S123>/Constant1'\r\n     */\r\n    Time_Varying_Model_2022a_B.Sqrt1 = sqrt\r\n      (Time_Varying_Model_2022a_P.WhiteNoise_Ts);\r\n\r\n    /* Sqrt: '<S123>/Sqrt' incorporates:\r\n     *  Constant: '<S123>/Constant'\r\n     */\r\n    ang_cos = sqrt(Time_Varying_Model_2022a_P.WhiteNoise_pwr[0]);\r\n    Time_Varying_Model_2022a_B.Sqrt[0] = ang_cos;\r\n\r\n    /* Product: '<S123>/Divide' */\r\n    ang_cos /= Time_Varying_Model_2022a_B.Sqrt1;\r\n    Time_Varying_Model_2022a_B.Divide[0] = ang_cos;\r\n\r\n    /* RandomNumber: '<S123>/White Noise' */\r\n    ct_idx_2 = Time_Varying_Model_2022a_DW.NextOutput[0];\r\n\r\n    /* RandomNumber: '<S123>/White Noise' */\r\n    Time_Varying_Model_2022a_B.WhiteNoise[0] = ct_idx_2;\r\n\r\n    /* Product: '<S123>/Product' */\r\n    Time_Varying_Model_2022a_B.Product_p[0] = ang_cos * ct_idx_2;\r\n\r\n    /* Sqrt: '<S123>/Sqrt' incorporates:\r\n     *  Constant: '<S123>/Constant'\r\n     */\r\n    ang_cos = sqrt(Time_Varying_Model_2022a_P.WhiteNoise_pwr[1]);\r\n    Time_Varying_Model_2022a_B.Sqrt[1] = ang_cos;\r\n\r\n    /* Product: '<S123>/Divide' */\r\n    ang_cos /= Time_Varying_Model_2022a_B.Sqrt1;\r\n    Time_Varying_Model_2022a_B.Divide[1] = ang_cos;\r\n\r\n    /* RandomNumber: '<S123>/White Noise' */\r\n    ct_idx_2 = Time_Varying_Model_2022a_DW.NextOutput[1];\r\n\r\n    /* RandomNumber: '<S123>/White Noise' */\r\n    Time_Varying_Model_2022a_B.WhiteNoise[1] = ct_idx_2;\r\n\r\n    /* Product: '<S123>/Product' */\r\n    Time_Varying_Model_2022a_B.Product_p[1] = ang_cos * ct_idx_2;\r\n\r\n    /* Sqrt: '<S123>/Sqrt' incorporates:\r\n     *  Constant: '<S123>/Constant'\r\n     */\r\n    ang_cos = sqrt(Time_Varying_Model_2022a_P.WhiteNoise_pwr[2]);\r\n    Time_Varying_Model_2022a_B.Sqrt[2] = ang_cos;\r\n\r\n    /* Product: '<S123>/Divide' */\r\n    ang_cos /= Time_Varying_Model_2022a_B.Sqrt1;\r\n    Time_Varying_Model_2022a_B.Divide[2] = ang_cos;\r\n\r\n    /* RandomNumber: '<S123>/White Noise' */\r\n    ct_idx_2 = Time_Varying_Model_2022a_DW.NextOutput[2];\r\n\r\n    /* RandomNumber: '<S123>/White Noise' */\r\n    Time_Varying_Model_2022a_B.WhiteNoise[2] = ct_idx_2;\r\n\r\n    /* Product: '<S123>/Product' */\r\n    Time_Varying_Model_2022a_B.Product_p[2] = ang_cos * ct_idx_2;\r\n\r\n    /* Sqrt: '<S123>/Sqrt' incorporates:\r\n     *  Constant: '<S123>/Constant'\r\n     */\r\n    ang_cos = sqrt(Time_Varying_Model_2022a_P.WhiteNoise_pwr[3]);\r\n    Time_Varying_Model_2022a_B.Sqrt[3] = ang_cos;\r\n\r\n    /* Product: '<S123>/Divide' */\r\n    ang_cos /= Time_Varying_Model_2022a_B.Sqrt1;\r\n    Time_Varying_Model_2022a_B.Divide[3] = ang_cos;\r\n\r\n    /* RandomNumber: '<S123>/White Noise' */\r\n    ct_idx_2 = Time_Varying_Model_2022a_DW.NextOutput[3];\r\n\r\n    /* RandomNumber: '<S123>/White Noise' */\r\n    Time_Varying_Model_2022a_B.WhiteNoise[3] = ct_idx_2;\r\n\r\n    /* Product: '<S123>/Product' */\r\n    Time_Varying_Model_2022a_B.Product_p[3] = ang_cos * ct_idx_2;\r\n  }\r\n\r\n  /* Outputs for Enabled SubSystem: '<S114>/Hugw(s)' incorporates:\r\n   *  EnablePort: '<S127>/Enable'\r\n   */\r\n  if ((rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n       Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) &&\r\n      rtsiIsModeUpdateTimeStep(&Time_Varying_Model_2022a_M->solverInfo)) {\r\n    /* Constant: '<S114>/Constant' */\r\n    if (Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_c > 0.0) {\r\n      if (!Time_Varying_Model_2022a_DW.Hugws_MODE) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.ug_p_CSTATE), 0,\r\n                      2*sizeof(boolean_T));\r\n\r\n        /* InitializeConditions for Integrator: '<S127>/ug_p' */\r\n        Time_Varying_Model_2022a_X.ug_p_CSTATE[0] =\r\n          Time_Varying_Model_2022a_P.ug_p_IC;\r\n        Time_Varying_Model_2022a_X.ug_p_CSTATE[1] =\r\n          Time_Varying_Model_2022a_P.ug_p_IC;\r\n        Time_Varying_Model_2022a_DW.Hugws_MODE = true;\r\n      }\r\n    } else {\r\n      ang_cos = rtmGetTStart(Time_Varying_Model_2022a_M);\r\n      if ((((Time_Varying_Model_2022a_M->Timing.clockTick1+\r\n             Time_Varying_Model_2022a_M->Timing.clockTickH1* 4294967296.0)) *\r\n           0.01) == ang_cos) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.ug_p_CSTATE), 1,\r\n                      2*sizeof(boolean_T));\r\n      }\r\n\r\n      if (Time_Varying_Model_2022a_DW.Hugws_MODE) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.ug_p_CSTATE), 1,\r\n                      2*sizeof(boolean_T));\r\n\r\n        /* Disable for Product: '<S127>/w1' incorporates:\r\n         *  Outport: '<S127>/ugw'\r\n         */\r\n        Time_Varying_Model_2022a_B.w1_a[0] = Time_Varying_Model_2022a_P.ugw_Y0;\r\n        Time_Varying_Model_2022a_B.w1_a[1] = Time_Varying_Model_2022a_P.ugw_Y0;\r\n        Time_Varying_Model_2022a_DW.Hugws_MODE = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (Time_Varying_Model_2022a_DW.Hugws_MODE) {\r\n    /* Product: '<S127>/Lug//V' */\r\n    Time_Varying_Model_2022a_B.LugV[0] =\r\n      Time_Varying_Model_2022a_B.LowAltitudeScaleLength /\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n    Time_Varying_Model_2022a_B.LugV[1] =\r\n      Time_Varying_Model_2022a_B.UnitConversion_f /\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n\r\n    /* Gain: '<S127>/(2//pi)' */\r\n    ang_cos = Time_Varying_Model_2022a_B.LugV[0];\r\n\r\n    /* Gain: '<S127>/(2//pi)' */\r\n    Time_Varying_Model_2022a_B.upi_l[0] = Time_Varying_Model_2022a_P.upi_Gain *\r\n      ang_cos;\r\n\r\n    /* Sqrt: '<S127>/sqrt' */\r\n    ang_sin = sqrt(Time_Varying_Model_2022a_B.upi_l[0]);\r\n    Time_Varying_Model_2022a_B.sqrt_a[0] = ang_sin;\r\n\r\n    /* Product: '<S127>/Lug//V1' */\r\n    ang_sin *= Time_Varying_Model_2022a_B.Product_p[0];\r\n    Time_Varying_Model_2022a_B.LugV1_m[0] = ang_sin;\r\n\r\n    /* Integrator: '<S127>/ug_p' */\r\n    st_idx_1 = Time_Varying_Model_2022a_X.ug_p_CSTATE[0];\r\n    Time_Varying_Model_2022a_B.ug_p[0] = st_idx_1;\r\n\r\n    /* Sum: '<S127>/Sum' */\r\n    ang_sin -= st_idx_1;\r\n    Time_Varying_Model_2022a_B.Sum_i[0] = ang_sin;\r\n\r\n    /* Product: '<S127>/w' */\r\n    Time_Varying_Model_2022a_B.w_b[0] = ang_sin / ang_cos;\r\n\r\n    /* Gain: '<S127>/(2//pi)' */\r\n    ang_cos = Time_Varying_Model_2022a_B.LugV[1];\r\n\r\n    /* Gain: '<S127>/(2//pi)' */\r\n    Time_Varying_Model_2022a_B.upi_l[1] = Time_Varying_Model_2022a_P.upi_Gain *\r\n      ang_cos;\r\n\r\n    /* Sqrt: '<S127>/sqrt' */\r\n    ang_sin = sqrt(Time_Varying_Model_2022a_B.upi_l[1]);\r\n    Time_Varying_Model_2022a_B.sqrt_a[1] = ang_sin;\r\n\r\n    /* Product: '<S127>/Lug//V1' */\r\n    ang_sin *= Time_Varying_Model_2022a_B.Product_p[0];\r\n    Time_Varying_Model_2022a_B.LugV1_m[1] = ang_sin;\r\n\r\n    /* Integrator: '<S127>/ug_p' */\r\n    st_idx_1 = Time_Varying_Model_2022a_X.ug_p_CSTATE[1];\r\n    Time_Varying_Model_2022a_B.ug_p[1] = st_idx_1;\r\n\r\n    /* Sum: '<S127>/Sum' */\r\n    ang_sin -= st_idx_1;\r\n    Time_Varying_Model_2022a_B.Sum_i[1] = ang_sin;\r\n\r\n    /* Product: '<S127>/w' */\r\n    Time_Varying_Model_2022a_B.w_b[1] = ang_sin / ang_cos;\r\n\r\n    /* Product: '<S127>/w1' */\r\n    Time_Varying_Model_2022a_B.w1_a[0] = Time_Varying_Model_2022a_B.ug_p[0] *\r\n      Time_Varying_Model_2022a_B.sigma_ugsigma_vg;\r\n    Time_Varying_Model_2022a_B.w1_a[1] = Time_Varying_Model_2022a_B.ug_p[1] *\r\n      Time_Varying_Model_2022a_B.MediumHighAltitudeIntensity;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S114>/Hugw(s)' */\r\n\r\n  /* Gain: '<S120>/Lv' */\r\n  Time_Varying_Model_2022a_B.Lv[0] = Time_Varying_Model_2022a_P.Lv_Gain *\r\n    Time_Varying_Model_2022a_B.LowAltitudeScaleLength;\r\n  Time_Varying_Model_2022a_B.Lv[1] = Time_Varying_Model_2022a_P.Lv_Gain *\r\n    Time_Varying_Model_2022a_B.UnitConversion_f;\r\n\r\n  /* Outputs for Enabled SubSystem: '<S114>/Hvgw(s)' incorporates:\r\n   *  EnablePort: '<S128>/Enable'\r\n   */\r\n  if ((rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n       Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) &&\r\n      rtsiIsModeUpdateTimeStep(&Time_Varying_Model_2022a_M->solverInfo)) {\r\n    /* Constant: '<S114>/Constant' */\r\n    if (Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_c > 0.0) {\r\n      if (!Time_Varying_Model_2022a_DW.Hvgws_MODE) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.vg_p1_CSTATE), 0,\r\n                      4*sizeof(boolean_T));\r\n\r\n        /* InitializeConditions for Integrator: '<S128>/vg_p1' */\r\n        Time_Varying_Model_2022a_X.vg_p1_CSTATE[0] =\r\n          Time_Varying_Model_2022a_P.vg_p1_IC;\r\n\r\n        /* InitializeConditions for Integrator: '<S128>/vgw_p2' */\r\n        Time_Varying_Model_2022a_X.vgw_p2_CSTATE[0] =\r\n          Time_Varying_Model_2022a_P.vgw_p2_IC;\r\n\r\n        /* InitializeConditions for Integrator: '<S128>/vg_p1' */\r\n        Time_Varying_Model_2022a_X.vg_p1_CSTATE[1] =\r\n          Time_Varying_Model_2022a_P.vg_p1_IC;\r\n\r\n        /* InitializeConditions for Integrator: '<S128>/vgw_p2' */\r\n        Time_Varying_Model_2022a_X.vgw_p2_CSTATE[1] =\r\n          Time_Varying_Model_2022a_P.vgw_p2_IC;\r\n        Time_Varying_Model_2022a_DW.Hvgws_MODE = true;\r\n      }\r\n    } else {\r\n      /* Outputs for Enabled SubSystem: '<S114>/Hugw(s)' incorporates:\r\n       *  EnablePort: '<S127>/Enable'\r\n       */\r\n      ang_cos = rtmGetTStart(Time_Varying_Model_2022a_M);\r\n\r\n      /* End of Outputs for SubSystem: '<S114>/Hugw(s)' */\r\n      if ((((Time_Varying_Model_2022a_M->Timing.clockTick1+\r\n             Time_Varying_Model_2022a_M->Timing.clockTickH1* 4294967296.0)) *\r\n           0.01) == ang_cos) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.vg_p1_CSTATE), 1,\r\n                      4*sizeof(boolean_T));\r\n      }\r\n\r\n      if (Time_Varying_Model_2022a_DW.Hvgws_MODE) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.vg_p1_CSTATE), 1,\r\n                      4*sizeof(boolean_T));\r\n\r\n        /* Disable for Product: '<S128>/w 1' incorporates:\r\n         *  Outport: '<S128>/vgw'\r\n         */\r\n        Time_Varying_Model_2022a_B.w1[0] = Time_Varying_Model_2022a_P.vgw_Y0;\r\n        Time_Varying_Model_2022a_B.w1[1] = Time_Varying_Model_2022a_P.vgw_Y0;\r\n        Time_Varying_Model_2022a_DW.Hvgws_MODE = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (Time_Varying_Model_2022a_DW.Hvgws_MODE) {\r\n    /* Product: '<S128>/Lvg//V' */\r\n    ang_cos = Time_Varying_Model_2022a_B.Lv[0] /\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n    Time_Varying_Model_2022a_B.LvgV[0] = ang_cos;\r\n\r\n    /* Gain: '<S128>/(1//pi)' */\r\n    Time_Varying_Model_2022a_B.upi_h[0] = Time_Varying_Model_2022a_P.upi_Gain_m *\r\n      ang_cos;\r\n\r\n    /* Sqrt: '<S128>/sqrt' */\r\n    ang_sin = sqrt(Time_Varying_Model_2022a_B.upi_h[0]);\r\n    Time_Varying_Model_2022a_B.sqrt_ew[0] = ang_sin;\r\n\r\n    /* Product: '<S128>/Lug//V1' */\r\n    st_idx_1 = ang_sin * Time_Varying_Model_2022a_B.Product_p[1];\r\n    Time_Varying_Model_2022a_B.LugV1_c[0] = st_idx_1;\r\n\r\n    /* Integrator: '<S128>/vg_p1' */\r\n    ang_sin = Time_Varying_Model_2022a_X.vg_p1_CSTATE[0];\r\n    Time_Varying_Model_2022a_B.vg_p1[0] = ang_sin;\r\n\r\n    /* Sum: '<S128>/Sum' */\r\n    st_idx_1 -= ang_sin;\r\n    Time_Varying_Model_2022a_B.Sum_c[0] = st_idx_1;\r\n\r\n    /* Product: '<S128>/w' */\r\n    st_idx_1 /= ang_cos;\r\n    Time_Varying_Model_2022a_B.w_l[0] = st_idx_1;\r\n\r\n    /* Product: '<S128>/Lvg//V ' */\r\n    ct_idx_0 = st_idx_1 * ang_cos;\r\n    Time_Varying_Model_2022a_B.LvgV_n[0] = ct_idx_0;\r\n\r\n    /* Integrator: '<S128>/vgw_p2' */\r\n    st_idx_1 = Time_Varying_Model_2022a_X.vgw_p2_CSTATE[0];\r\n    Time_Varying_Model_2022a_B.vgw_p2[0] = st_idx_1;\r\n\r\n    /* Gain: '<S128>/sqrt(3)' */\r\n    ct_idx_0 *= Time_Varying_Model_2022a_P.sqrt3_Gain;\r\n    Time_Varying_Model_2022a_B.sqrt3[0] = ct_idx_0;\r\n\r\n    /* Sum: '<S128>/Sum1' */\r\n    ang_sin = (ang_sin - st_idx_1) + ct_idx_0;\r\n    Time_Varying_Model_2022a_B.Sum1_l[0] = ang_sin;\r\n\r\n    /* Product: '<S128>/w ' */\r\n    Time_Varying_Model_2022a_B.w_i[0] = ang_sin / ang_cos;\r\n\r\n    /* Product: '<S128>/Lvg//V' */\r\n    ang_cos = Time_Varying_Model_2022a_B.Lv[1] /\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n    Time_Varying_Model_2022a_B.LvgV[1] = ang_cos;\r\n\r\n    /* Gain: '<S128>/(1//pi)' */\r\n    Time_Varying_Model_2022a_B.upi_h[1] = Time_Varying_Model_2022a_P.upi_Gain_m *\r\n      ang_cos;\r\n\r\n    /* Sqrt: '<S128>/sqrt' */\r\n    ang_sin = sqrt(Time_Varying_Model_2022a_B.upi_h[1]);\r\n    Time_Varying_Model_2022a_B.sqrt_ew[1] = ang_sin;\r\n\r\n    /* Product: '<S128>/Lug//V1' */\r\n    st_idx_1 = ang_sin * Time_Varying_Model_2022a_B.Product_p[1];\r\n    Time_Varying_Model_2022a_B.LugV1_c[1] = st_idx_1;\r\n\r\n    /* Integrator: '<S128>/vg_p1' */\r\n    ang_sin = Time_Varying_Model_2022a_X.vg_p1_CSTATE[1];\r\n    Time_Varying_Model_2022a_B.vg_p1[1] = ang_sin;\r\n\r\n    /* Sum: '<S128>/Sum' */\r\n    st_idx_1 -= ang_sin;\r\n    Time_Varying_Model_2022a_B.Sum_c[1] = st_idx_1;\r\n\r\n    /* Product: '<S128>/w' */\r\n    st_idx_1 /= ang_cos;\r\n    Time_Varying_Model_2022a_B.w_l[1] = st_idx_1;\r\n\r\n    /* Product: '<S128>/Lvg//V ' */\r\n    ct_idx_0 = st_idx_1 * ang_cos;\r\n    Time_Varying_Model_2022a_B.LvgV_n[1] = ct_idx_0;\r\n\r\n    /* Integrator: '<S128>/vgw_p2' */\r\n    st_idx_1 = Time_Varying_Model_2022a_X.vgw_p2_CSTATE[1];\r\n    Time_Varying_Model_2022a_B.vgw_p2[1] = st_idx_1;\r\n\r\n    /* Gain: '<S128>/sqrt(3)' */\r\n    ct_idx_0 *= Time_Varying_Model_2022a_P.sqrt3_Gain;\r\n    Time_Varying_Model_2022a_B.sqrt3[1] = ct_idx_0;\r\n\r\n    /* Sum: '<S128>/Sum1' */\r\n    ang_sin = (ang_sin - st_idx_1) + ct_idx_0;\r\n    Time_Varying_Model_2022a_B.Sum1_l[1] = ang_sin;\r\n\r\n    /* Product: '<S128>/w ' */\r\n    Time_Varying_Model_2022a_B.w_i[1] = ang_sin / ang_cos;\r\n\r\n    /* Product: '<S128>/w 1' */\r\n    Time_Varying_Model_2022a_B.w1[0] =\r\n      Time_Varying_Model_2022a_B.sigma_ugsigma_vg *\r\n      Time_Varying_Model_2022a_B.vgw_p2[0];\r\n    Time_Varying_Model_2022a_B.w1[1] =\r\n      Time_Varying_Model_2022a_B.MediumHighAltitudeIntensity *\r\n      Time_Varying_Model_2022a_B.vgw_p2[1];\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S114>/Hvgw(s)' */\r\n\r\n  /* Gain: '<S120>/Lw' */\r\n  Time_Varying_Model_2022a_B.Lw[0] = Time_Varying_Model_2022a_P.Lw_Gain *\r\n    Time_Varying_Model_2022a_B.LimitFunction10ftto1000ft;\r\n  Time_Varying_Model_2022a_B.Lw[1] = Time_Varying_Model_2022a_P.Lw_Gain *\r\n    Time_Varying_Model_2022a_B.UnitConversion_f;\r\n\r\n  /* Outputs for Enabled SubSystem: '<S114>/Hwgw(s)' incorporates:\r\n   *  EnablePort: '<S129>/Enable'\r\n   */\r\n  if ((rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n       Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) &&\r\n      rtsiIsModeUpdateTimeStep(&Time_Varying_Model_2022a_M->solverInfo)) {\r\n    /* Constant: '<S114>/Constant' */\r\n    if (Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_c > 0.0) {\r\n      if (!Time_Varying_Model_2022a_DW.Hwgws_MODE) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.wg_p1_CSTATE), 0,\r\n                      4*sizeof(boolean_T));\r\n\r\n        /* InitializeConditions for Integrator: '<S129>/wg_p1' */\r\n        Time_Varying_Model_2022a_X.wg_p1_CSTATE[0] =\r\n          Time_Varying_Model_2022a_P.wg_p1_IC;\r\n\r\n        /* InitializeConditions for Integrator: '<S129>/wg_p2' */\r\n        Time_Varying_Model_2022a_X.wg_p2_CSTATE[0] =\r\n          Time_Varying_Model_2022a_P.wg_p2_IC;\r\n\r\n        /* InitializeConditions for Integrator: '<S129>/wg_p1' */\r\n        Time_Varying_Model_2022a_X.wg_p1_CSTATE[1] =\r\n          Time_Varying_Model_2022a_P.wg_p1_IC;\r\n\r\n        /* InitializeConditions for Integrator: '<S129>/wg_p2' */\r\n        Time_Varying_Model_2022a_X.wg_p2_CSTATE[1] =\r\n          Time_Varying_Model_2022a_P.wg_p2_IC;\r\n        Time_Varying_Model_2022a_DW.Hwgws_MODE = true;\r\n      }\r\n    } else {\r\n      /* Outputs for Enabled SubSystem: '<S114>/Hugw(s)' incorporates:\r\n       *  EnablePort: '<S127>/Enable'\r\n       */\r\n      ang_cos = rtmGetTStart(Time_Varying_Model_2022a_M);\r\n\r\n      /* End of Outputs for SubSystem: '<S114>/Hugw(s)' */\r\n      if ((((Time_Varying_Model_2022a_M->Timing.clockTick1+\r\n             Time_Varying_Model_2022a_M->Timing.clockTickH1* 4294967296.0)) *\r\n           0.01) == ang_cos) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.wg_p1_CSTATE), 1,\r\n                      4*sizeof(boolean_T));\r\n      }\r\n\r\n      if (Time_Varying_Model_2022a_DW.Hwgws_MODE) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.wg_p1_CSTATE), 1,\r\n                      4*sizeof(boolean_T));\r\n\r\n        /* Disable for Product: '<S129>/Lwg//V 1' incorporates:\r\n         *  Outport: '<S129>/wgw'\r\n         */\r\n        Time_Varying_Model_2022a_B.LwgV1[0] = Time_Varying_Model_2022a_P.wgw_Y0;\r\n        Time_Varying_Model_2022a_B.LwgV1[1] = Time_Varying_Model_2022a_P.wgw_Y0;\r\n        Time_Varying_Model_2022a_DW.Hwgws_MODE = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (Time_Varying_Model_2022a_DW.Hwgws_MODE) {\r\n    /* Product: '<S129>/Lwg//V' */\r\n    ang_cos = Time_Varying_Model_2022a_B.Lw[0] /\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n    Time_Varying_Model_2022a_B.LwgV[0] = ang_cos;\r\n\r\n    /* Gain: '<S129>/1//pi' */\r\n    Time_Varying_Model_2022a_B.upi[0] = Time_Varying_Model_2022a_P.upi_Gain_l *\r\n      ang_cos;\r\n\r\n    /* Sqrt: '<S129>/sqrt1' */\r\n    ang_sin = sqrt(Time_Varying_Model_2022a_B.upi[0]);\r\n    Time_Varying_Model_2022a_B.sqrt1[0] = ang_sin;\r\n\r\n    /* Product: '<S129>/Lug//V1' */\r\n    ang_sin *= Time_Varying_Model_2022a_B.Product_p[2];\r\n    Time_Varying_Model_2022a_B.LugV1[0] = ang_sin;\r\n\r\n    /* Integrator: '<S129>/wg_p1' */\r\n    st_idx_1 = Time_Varying_Model_2022a_X.wg_p1_CSTATE[0];\r\n    Time_Varying_Model_2022a_B.wg_p1[0] = st_idx_1;\r\n\r\n    /* Sum: '<S129>/Sum' */\r\n    ang_sin -= st_idx_1;\r\n    Time_Varying_Model_2022a_B.Sum_ht[0] = ang_sin;\r\n\r\n    /* Product: '<S129>/w' */\r\n    Time_Varying_Model_2022a_B.w[0] = ang_sin / ang_cos;\r\n\r\n    /* Product: '<S129>/Lwg//V' */\r\n    ang_cos = Time_Varying_Model_2022a_B.Lw[1] /\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n    Time_Varying_Model_2022a_B.LwgV[1] = ang_cos;\r\n\r\n    /* Gain: '<S129>/1//pi' */\r\n    Time_Varying_Model_2022a_B.upi[1] = Time_Varying_Model_2022a_P.upi_Gain_l *\r\n      ang_cos;\r\n\r\n    /* Sqrt: '<S129>/sqrt1' */\r\n    ang_sin = sqrt(Time_Varying_Model_2022a_B.upi[1]);\r\n    Time_Varying_Model_2022a_B.sqrt1[1] = ang_sin;\r\n\r\n    /* Product: '<S129>/Lug//V1' */\r\n    ang_sin *= Time_Varying_Model_2022a_B.Product_p[2];\r\n    Time_Varying_Model_2022a_B.LugV1[1] = ang_sin;\r\n\r\n    /* Integrator: '<S129>/wg_p1' */\r\n    st_idx_1 = Time_Varying_Model_2022a_X.wg_p1_CSTATE[1];\r\n    Time_Varying_Model_2022a_B.wg_p1[1] = st_idx_1;\r\n\r\n    /* Sum: '<S129>/Sum' */\r\n    ang_sin -= st_idx_1;\r\n    Time_Varying_Model_2022a_B.Sum_ht[1] = ang_sin;\r\n\r\n    /* Product: '<S129>/w' */\r\n    Time_Varying_Model_2022a_B.w[1] = ang_sin / ang_cos;\r\n    if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n        Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n      /* Sqrt: '<S129>/sqrt' incorporates:\r\n       *  Constant: '<S129>/Constant'\r\n       */\r\n      Time_Varying_Model_2022a_B.sqrt_d = sqrt\r\n        (Time_Varying_Model_2022a_P.Constant_Value);\r\n    }\r\n\r\n    /* Product: '<S129>/Lwg//V ' */\r\n    ang_cos = Time_Varying_Model_2022a_B.LwgV[0];\r\n\r\n    /* Product: '<S129>/Lwg//V ' */\r\n    ang_sin = Time_Varying_Model_2022a_B.w[0] *\r\n      Time_Varying_Model_2022a_B.sqrt_d * ang_cos;\r\n    Time_Varying_Model_2022a_B.LwgV_p[0] = ang_sin;\r\n\r\n    /* Integrator: '<S129>/wg_p2' */\r\n    st_idx_1 = Time_Varying_Model_2022a_X.wg_p2_CSTATE[0];\r\n    Time_Varying_Model_2022a_B.wg_p2[0] = st_idx_1;\r\n\r\n    /* Sum: '<S129>/Sum1' */\r\n    ang_sin += Time_Varying_Model_2022a_B.wg_p1[0] - st_idx_1;\r\n    Time_Varying_Model_2022a_B.Sum1_b[0] = ang_sin;\r\n\r\n    /* Product: '<S129>/w ' */\r\n    Time_Varying_Model_2022a_B.w_o[0] = ang_sin / ang_cos;\r\n\r\n    /* Product: '<S129>/Lwg//V ' */\r\n    ang_cos = Time_Varying_Model_2022a_B.LwgV[1];\r\n\r\n    /* Product: '<S129>/Lwg//V ' */\r\n    ang_sin = Time_Varying_Model_2022a_B.w[1] *\r\n      Time_Varying_Model_2022a_B.sqrt_d * ang_cos;\r\n    Time_Varying_Model_2022a_B.LwgV_p[1] = ang_sin;\r\n\r\n    /* Integrator: '<S129>/wg_p2' */\r\n    st_idx_1 = Time_Varying_Model_2022a_X.wg_p2_CSTATE[1];\r\n    Time_Varying_Model_2022a_B.wg_p2[1] = st_idx_1;\r\n\r\n    /* Sum: '<S129>/Sum1' */\r\n    ang_sin += Time_Varying_Model_2022a_B.wg_p1[1] - st_idx_1;\r\n    Time_Varying_Model_2022a_B.Sum1_b[1] = ang_sin;\r\n\r\n    /* Product: '<S129>/w ' */\r\n    Time_Varying_Model_2022a_B.w_o[1] = ang_sin / ang_cos;\r\n\r\n    /* Product: '<S129>/Lwg//V 1' */\r\n    Time_Varying_Model_2022a_B.LwgV1[0] = Time_Varying_Model_2022a_B.sigma_wg *\r\n      Time_Varying_Model_2022a_B.wg_p2[0];\r\n    Time_Varying_Model_2022a_B.LwgV1[1] =\r\n      Time_Varying_Model_2022a_B.MediumHighAltitudeIntensity *\r\n      Time_Varying_Model_2022a_B.wg_p2[1];\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S114>/Hwgw(s)' */\r\n\r\n  /* MATLAB Function: '<S41>/RPY to DCM' */\r\n  /* :  DCM=zeros(3); */\r\n  /* :  eul = [yaw pitch roll]; */\r\n  ang_sin = Time_Varying_Model_2022a_B.Integrator3;\r\n  st_idx_1 = Time_Varying_Model_2022a_B.Integrator4;\r\n  ang_cos = Time_Varying_Model_2022a_B.Integrator5;\r\n\r\n  /* :  rotmZYX = eul2rotm(eul); */\r\n  st = ang_sin;\r\n  ct_idx_2 = st;\r\n  ct_idx_2 = cos(ct_idx_2);\r\n  ct_idx_0 = ct_idx_2;\r\n  st = sin(st);\r\n  ang_sin = st;\r\n  st = st_idx_1;\r\n  ct_idx_2 = st;\r\n  ct_idx_2 = cos(ct_idx_2);\r\n  ct_idx_1 = ct_idx_2;\r\n  st = sin(st);\r\n  st_idx_1 = st;\r\n  st = ang_cos;\r\n  ct_idx_2 = st;\r\n  ct_idx_2 = cos(ct_idx_2);\r\n  st = sin(st);\r\n  ang_cos = st;\r\n  rotmZYX[0] = ct_idx_0 * ct_idx_1;\r\n  st = st_idx_1 * ang_cos;\r\n  rotmZYX[3] = st * ct_idx_0 - ang_sin * ct_idx_2;\r\n  rotmZYX_tmp = st_idx_1 * ct_idx_2;\r\n  rotmZYX[6] = rotmZYX_tmp * ct_idx_0 + ang_sin * ang_cos;\r\n  rotmZYX[1] = ang_sin * ct_idx_1;\r\n  rotmZYX[4] = st * ang_sin + ct_idx_0 * ct_idx_2;\r\n  rotmZYX[7] = rotmZYX_tmp * ang_sin - ct_idx_0 * ang_cos;\r\n  rotmZYX[2] = -st_idx_1;\r\n  rotmZYX[5] = ct_idx_1 * ang_cos;\r\n  rotmZYX[8] = ct_idx_1 * ct_idx_2;\r\n\r\n  /* :  DCM = rotmZYX.'; */\r\n  for (i_0 = 0; i_0 < 3; i_0++) {\r\n    Time_Varying_Model_2022a_B.DCM[3 * i_0] = rotmZYX[i_0];\r\n    Time_Varying_Model_2022a_B.DCM[3 * i_0 + 1] = rotmZYX[i_0 + 3];\r\n    Time_Varying_Model_2022a_B.DCM[3 * i_0 + 2] = rotmZYX[i_0 + 6];\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S41>/RPY to DCM' */\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n    /* UnitConversion: '<S112>/Unit Conversion' incorporates:\r\n     *  Constant: '<S110>/Wind direction'\r\n     */\r\n    /* Unit Conversion - from: deg to: rad\r\n       Expression: output = (0.0174533*input) + (0) */\r\n    Time_Varying_Model_2022a_B.UnitConversion_gl = 0.017453292519943295 *\r\n      Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_m;\r\n  }\r\n\r\n  /* If: '<S119>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' incorporates:\r\n   *  Merge: '<S143>/Merge'\r\n   *  Product: '<S146>/Product'\r\n   */\r\n  if (rtsiIsModeUpdateTimeStep(&Time_Varying_Model_2022a_M->solverInfo)) {\r\n    if (Time_Varying_Model_2022a_B.UnitConversion <= 1000.0) {\r\n      rtAction = 0;\r\n    } else if (Time_Varying_Model_2022a_B.UnitConversion >= 2000.0) {\r\n      rtAction = 1;\r\n    } else {\r\n      rtAction = 2;\r\n    }\r\n\r\n    Time_Varying_Model_2022a_DW.ifHeightMaxlowaltitudeelseifHei = rtAction;\r\n  } else {\r\n    rtAction = Time_Varying_Model_2022a_DW.ifHeightMaxlowaltitudeelseifHei;\r\n  }\r\n\r\n  switch (rtAction) {\r\n   case 0:\r\n    /* Outputs for IfAction SubSystem: '<S119>/Low altitude  velocities' incorporates:\r\n     *  ActionPort: '<S141>/Action Port'\r\n     */\r\n    /* SignalConversion generated from: '<S146>/Vector Concatenate' incorporates:\r\n     *  Concatenate: '<S146>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate_b[2] =\r\n      Time_Varying_Model_2022a_B.LwgV1[0];\r\n\r\n    /* Trigonometry: '<S147>/Trigonometric Function' */\r\n    ang_sin = Time_Varying_Model_2022a_B.UnitConversion_gl;\r\n    ang_cos = sin(ang_sin);\r\n    ang_sin = cos(ang_sin);\r\n\r\n    /* Trigonometry: '<S147>/Trigonometric Function' */\r\n    Time_Varying_Model_2022a_B.TrigonometricFunction_o1_h = ang_cos;\r\n\r\n    /* Trigonometry: '<S147>/Trigonometric Function' */\r\n    Time_Varying_Model_2022a_B.TrigonometricFunction_o2_j = ang_sin;\r\n\r\n    /* Product: '<S147>/Product2' */\r\n    Time_Varying_Model_2022a_B.Product2_l[0] = Time_Varying_Model_2022a_B.w1_a[0]\r\n      * Time_Varying_Model_2022a_B.TrigonometricFunction_o2_j;\r\n    Time_Varying_Model_2022a_B.Product2_l[1] = Time_Varying_Model_2022a_B.w1[0] *\r\n      Time_Varying_Model_2022a_B.TrigonometricFunction_o2_j;\r\n\r\n    /* Product: '<S147>/Product1' */\r\n    Time_Varying_Model_2022a_B.Product1_m[0] =\r\n      Time_Varying_Model_2022a_B.TrigonometricFunction_o1_h *\r\n      Time_Varying_Model_2022a_B.w1_a[0];\r\n    Time_Varying_Model_2022a_B.Product1_m[1] =\r\n      Time_Varying_Model_2022a_B.TrigonometricFunction_o1_h *\r\n      Time_Varying_Model_2022a_B.w1[0];\r\n\r\n    /* Sum: '<S147>/Sum' incorporates:\r\n     *  Concatenate: '<S146>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate_b[0] =\r\n      Time_Varying_Model_2022a_B.Product2_l[0] -\r\n      Time_Varying_Model_2022a_B.Product1_m[1];\r\n\r\n    /* Sum: '<S147>/Sum1' incorporates:\r\n     *  Concatenate: '<S146>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate_b[1] =\r\n      Time_Varying_Model_2022a_B.Product1_m[0] +\r\n      Time_Varying_Model_2022a_B.Product2_l[1];\r\n\r\n    /* Product: '<S146>/Product' incorporates:\r\n     *  Concatenate: '<S146>/Vector Concatenate'\r\n     */\r\n    memcpy(&rotmZYX[0], &Time_Varying_Model_2022a_B.DCM[0], 9U * sizeof(real_T));\r\n    ang_sin = Time_Varying_Model_2022a_B.VectorConcatenate_b[0];\r\n    st_idx_1 = Time_Varying_Model_2022a_B.VectorConcatenate_b[1];\r\n    ang_cos = Time_Varying_Model_2022a_B.VectorConcatenate_b[2];\r\n\r\n    /* End of Outputs for SubSystem: '<S119>/Low altitude  velocities' */\r\n    for (i = 0; i <= 0; i += 2) {\r\n      /* Outputs for IfAction SubSystem: '<S119>/Low altitude  velocities' incorporates:\r\n       *  ActionPort: '<S141>/Action Port'\r\n       */\r\n      tmp_0 = _mm_loadu_pd(&rotmZYX[i]);\r\n      tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(ang_sin));\r\n      tmp_1 = _mm_loadu_pd(&rotmZYX[i + 3]);\r\n      tmp_1 = _mm_mul_pd(tmp_1, _mm_set1_pd(st_idx_1));\r\n\r\n      /* End of Outputs for SubSystem: '<S119>/Low altitude  velocities' */\r\n      tmp_0 = _mm_add_pd(tmp_1, tmp_0);\r\n\r\n      /* Outputs for IfAction SubSystem: '<S119>/Low altitude  velocities' incorporates:\r\n       *  ActionPort: '<S141>/Action Port'\r\n       */\r\n      tmp_1 = _mm_loadu_pd(&rotmZYX[i + 6]);\r\n      tmp_1 = _mm_mul_pd(tmp_1, _mm_set1_pd(ang_cos));\r\n\r\n      /* End of Outputs for SubSystem: '<S119>/Low altitude  velocities' */\r\n      tmp_0 = _mm_add_pd(tmp_1, tmp_0);\r\n\r\n      /* Outputs for IfAction SubSystem: '<S119>/Low altitude  velocities' incorporates:\r\n       *  ActionPort: '<S141>/Action Port'\r\n       */\r\n      _mm_storeu_pd(&Time_Varying_Model_2022a_B.Product_i[i], tmp_0);\r\n      _mm_storeu_pd(&Time_Varying_Model_2022a_B.Merge[i], tmp_0);\r\n\r\n      /* End of Outputs for SubSystem: '<S119>/Low altitude  velocities' */\r\n    }\r\n\r\n    /* Outputs for IfAction SubSystem: '<S119>/Low altitude  velocities' incorporates:\r\n     *  ActionPort: '<S141>/Action Port'\r\n     */\r\n    for (i = 2; i < 3; i++) {\r\n      /* Product: '<S146>/Product' */\r\n      ct_idx_0 = rotmZYX[i] * ang_sin;\r\n      ct_idx_0 += rotmZYX[i + 3] * st_idx_1;\r\n      ct_idx_0 += rotmZYX[i + 6] * ang_cos;\r\n      Time_Varying_Model_2022a_B.Product_i[i] = ct_idx_0;\r\n\r\n      /* Merge: '<S143>/Merge' incorporates:\r\n       *  Product: '<S146>/Product'\r\n       *  Reshape: '<S146>/Reshape1'\r\n       */\r\n      Time_Varying_Model_2022a_B.Merge[i] = ct_idx_0;\r\n    }\r\n\r\n    /* End of Outputs for SubSystem: '<S119>/Low altitude  velocities' */\r\n    break;\r\n\r\n   case 1:\r\n    /* Outputs for IfAction SubSystem: '<S119>/Medium//High  altitude velocities' incorporates:\r\n     *  ActionPort: '<S142>/Action Port'\r\n     */\r\n    /* Merge: '<S143>/Merge' incorporates:\r\n     *  Gain: '<S142>/Gain'\r\n     */\r\n    Time_Varying_Model_2022a_B.Merge[0] = Time_Varying_Model_2022a_P.Gain_Gain_o\r\n      * Time_Varying_Model_2022a_B.w1_a[1];\r\n    Time_Varying_Model_2022a_B.Merge[1] = Time_Varying_Model_2022a_P.Gain_Gain_o\r\n      * Time_Varying_Model_2022a_B.w1[1];\r\n    Time_Varying_Model_2022a_B.Merge[2] = Time_Varying_Model_2022a_P.Gain_Gain_o\r\n      * Time_Varying_Model_2022a_B.LwgV1[1];\r\n\r\n    /* End of Outputs for SubSystem: '<S119>/Medium//High  altitude velocities' */\r\n    break;\r\n\r\n   default:\r\n    /* Outputs for IfAction SubSystem: '<S119>/Interpolate  velocities' incorporates:\r\n     *  ActionPort: '<S140>/Action Port'\r\n     */\r\n    /* Trigonometry: '<S145>/Trigonometric Function' */\r\n    ang_sin = Time_Varying_Model_2022a_B.UnitConversion_gl;\r\n    ang_cos = sin(ang_sin);\r\n    ang_sin = cos(ang_sin);\r\n\r\n    /* Trigonometry: '<S145>/Trigonometric Function' */\r\n    Time_Varying_Model_2022a_B.TrigonometricFunction_o1 = ang_cos;\r\n\r\n    /* Trigonometry: '<S145>/Trigonometric Function' */\r\n    Time_Varying_Model_2022a_B.TrigonometricFunction_o2 = ang_sin;\r\n\r\n    /* Product: '<S145>/Product2' */\r\n    Time_Varying_Model_2022a_B.Product2_jq[0] = Time_Varying_Model_2022a_B.w1_a\r\n      [0] * Time_Varying_Model_2022a_B.TrigonometricFunction_o2;\r\n    Time_Varying_Model_2022a_B.Product2_jq[1] = Time_Varying_Model_2022a_B.w1[0]\r\n      * Time_Varying_Model_2022a_B.TrigonometricFunction_o2;\r\n\r\n    /* Product: '<S145>/Product1' */\r\n    Time_Varying_Model_2022a_B.Product1_o[0] =\r\n      Time_Varying_Model_2022a_B.TrigonometricFunction_o1 *\r\n      Time_Varying_Model_2022a_B.w1_a[0];\r\n    Time_Varying_Model_2022a_B.Product1_o[1] =\r\n      Time_Varying_Model_2022a_B.TrigonometricFunction_o1 *\r\n      Time_Varying_Model_2022a_B.w1[0];\r\n\r\n    /* Sum: '<S145>/Sum' incorporates:\r\n     *  Concatenate: '<S144>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate[0] =\r\n      Time_Varying_Model_2022a_B.Product2_jq[0] -\r\n      Time_Varying_Model_2022a_B.Product1_o[1];\r\n\r\n    /* Sum: '<S145>/Sum1' incorporates:\r\n     *  Concatenate: '<S144>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate[1] =\r\n      Time_Varying_Model_2022a_B.Product1_o[0] +\r\n      Time_Varying_Model_2022a_B.Product2_jq[1];\r\n\r\n    /* SignalConversion generated from: '<S144>/Vector Concatenate' incorporates:\r\n     *  Concatenate: '<S144>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate[2] =\r\n      Time_Varying_Model_2022a_B.LwgV1[0];\r\n\r\n    /* Product: '<S144>/Product' incorporates:\r\n     *  Concatenate: '<S144>/Vector Concatenate'\r\n     */\r\n    memcpy(&rotmZYX[0], &Time_Varying_Model_2022a_B.DCM[0], 9U * sizeof(real_T));\r\n    ang_sin = Time_Varying_Model_2022a_B.VectorConcatenate[0];\r\n    st_idx_1 = Time_Varying_Model_2022a_B.VectorConcatenate[1];\r\n    ang_cos = Time_Varying_Model_2022a_B.VectorConcatenate[2];\r\n\r\n    /* End of Outputs for SubSystem: '<S119>/Interpolate  velocities' */\r\n    for (i_0 = 0; i_0 <= 0; i_0 += 2) {\r\n      /* Outputs for IfAction SubSystem: '<S119>/Interpolate  velocities' incorporates:\r\n       *  ActionPort: '<S140>/Action Port'\r\n       */\r\n      tmp_0 = _mm_loadu_pd(&rotmZYX[i_0]);\r\n      tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(ang_sin));\r\n      tmp_1 = _mm_loadu_pd(&rotmZYX[i_0 + 3]);\r\n      tmp_1 = _mm_mul_pd(tmp_1, _mm_set1_pd(st_idx_1));\r\n\r\n      /* End of Outputs for SubSystem: '<S119>/Interpolate  velocities' */\r\n      tmp_0 = _mm_add_pd(tmp_1, tmp_0);\r\n\r\n      /* Outputs for IfAction SubSystem: '<S119>/Interpolate  velocities' incorporates:\r\n       *  ActionPort: '<S140>/Action Port'\r\n       */\r\n      tmp_1 = _mm_loadu_pd(&rotmZYX[i_0 + 6]);\r\n      tmp_1 = _mm_mul_pd(tmp_1, _mm_set1_pd(ang_cos));\r\n\r\n      /* End of Outputs for SubSystem: '<S119>/Interpolate  velocities' */\r\n      tmp_0 = _mm_add_pd(tmp_1, tmp_0);\r\n\r\n      /* Outputs for IfAction SubSystem: '<S119>/Interpolate  velocities' incorporates:\r\n       *  ActionPort: '<S140>/Action Port'\r\n       */\r\n      _mm_storeu_pd(&Time_Varying_Model_2022a_B.Product_oc[i_0], tmp_0);\r\n\r\n      /* End of Outputs for SubSystem: '<S119>/Interpolate  velocities' */\r\n    }\r\n\r\n    /* Outputs for IfAction SubSystem: '<S119>/Interpolate  velocities' incorporates:\r\n     *  ActionPort: '<S140>/Action Port'\r\n     */\r\n    for (i_0 = 2; i_0 < 3; i_0++) {\r\n      /* Product: '<S144>/Product' */\r\n      ct_idx_0 = rotmZYX[i_0] * ang_sin;\r\n      ct_idx_0 += rotmZYX[i_0 + 3] * st_idx_1;\r\n      ct_idx_0 += rotmZYX[i_0 + 6] * ang_cos;\r\n      Time_Varying_Model_2022a_B.Product_oc[i_0] = ct_idx_0;\r\n    }\r\n\r\n    /* Sum: '<S140>/Sum2' incorporates:\r\n     *  Product: '<S144>/Product'\r\n     */\r\n    Time_Varying_Model_2022a_B.Sum2_np[0] = Time_Varying_Model_2022a_B.w1_a[1] -\r\n      Time_Varying_Model_2022a_B.Product_oc[0];\r\n    Time_Varying_Model_2022a_B.Sum2_np[1] = Time_Varying_Model_2022a_B.w1[1] -\r\n      Time_Varying_Model_2022a_B.Product_oc[1];\r\n    Time_Varying_Model_2022a_B.Sum2_np[2] = Time_Varying_Model_2022a_B.LwgV1[1]\r\n      - Time_Varying_Model_2022a_B.Product_oc[2];\r\n\r\n    /* Sum: '<S140>/Sum1' incorporates:\r\n     *  Constant: '<S140>/max_height_low'\r\n     */\r\n    Time_Varying_Model_2022a_B.Sum1_kf =\r\n      Time_Varying_Model_2022a_B.UnitConversion -\r\n      Time_Varying_Model_2022a_P.max_height_low_Value_l;\r\n\r\n    /* Sum: '<S140>/Sum' incorporates:\r\n     *  Constant: '<S140>/max_height_low'\r\n     *  Constant: '<S140>/min_height_high'\r\n     */\r\n    Time_Varying_Model_2022a_B.Sum_jj =\r\n      Time_Varying_Model_2022a_P.min_height_high_Value_h -\r\n      Time_Varying_Model_2022a_P.max_height_low_Value_l;\r\n\r\n    /* Product: '<S140>/Product1' */\r\n    ang_cos = Time_Varying_Model_2022a_B.Sum2_np[0] *\r\n      Time_Varying_Model_2022a_B.Sum1_kf / Time_Varying_Model_2022a_B.Sum_jj;\r\n\r\n    /* End of Outputs for SubSystem: '<S119>/Interpolate  velocities' */\r\n    Time_Varying_Model_2022a_B.Product1_h[0] = ang_cos;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S119>/Interpolate  velocities' incorporates:\r\n     *  ActionPort: '<S140>/Action Port'\r\n     */\r\n    /* Merge: '<S143>/Merge' incorporates:\r\n     *  Sum: '<S140>/Sum3'\r\n     */\r\n    Time_Varying_Model_2022a_B.Merge[0] = Time_Varying_Model_2022a_B.Product_oc\r\n      [0] + ang_cos;\r\n\r\n    /* Product: '<S140>/Product1' */\r\n    ang_cos = Time_Varying_Model_2022a_B.Sum2_np[1] *\r\n      Time_Varying_Model_2022a_B.Sum1_kf / Time_Varying_Model_2022a_B.Sum_jj;\r\n\r\n    /* End of Outputs for SubSystem: '<S119>/Interpolate  velocities' */\r\n    Time_Varying_Model_2022a_B.Product1_h[1] = ang_cos;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S119>/Interpolate  velocities' incorporates:\r\n     *  ActionPort: '<S140>/Action Port'\r\n     */\r\n    /* Merge: '<S143>/Merge' incorporates:\r\n     *  Sum: '<S140>/Sum3'\r\n     */\r\n    Time_Varying_Model_2022a_B.Merge[1] = Time_Varying_Model_2022a_B.Product_oc\r\n      [1] + ang_cos;\r\n\r\n    /* Product: '<S140>/Product1' */\r\n    ang_cos = Time_Varying_Model_2022a_B.Sum2_np[2] *\r\n      Time_Varying_Model_2022a_B.Sum1_kf / Time_Varying_Model_2022a_B.Sum_jj;\r\n\r\n    /* End of Outputs for SubSystem: '<S119>/Interpolate  velocities' */\r\n    Time_Varying_Model_2022a_B.Product1_h[2] = ang_cos;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S119>/Interpolate  velocities' incorporates:\r\n     *  ActionPort: '<S140>/Action Port'\r\n     */\r\n    /* Merge: '<S143>/Merge' incorporates:\r\n     *  Sum: '<S140>/Sum3'\r\n     */\r\n    Time_Varying_Model_2022a_B.Merge[2] = Time_Varying_Model_2022a_B.Product_oc\r\n      [2] + ang_cos;\r\n\r\n    /* End of Outputs for SubSystem: '<S119>/Interpolate  velocities' */\r\n    break;\r\n  }\r\n\r\n  /* End of If: '<S119>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' */\r\n\r\n  /* UnitConversion: '<S110>/Unit Conversion' */\r\n  /* Unit Conversion - from: ft/s to: m/s\r\n     Expression: output = (0.3048*input) + (0) */\r\n  Time_Varying_Model_2022a_B.UnitConversion_j[0] = 0.3048 *\r\n    Time_Varying_Model_2022a_B.Merge[0];\r\n\r\n  /* Integrator: '<S41>/Integrator' */\r\n  Time_Varying_Model_2022a_B.Integrator_o[0] =\r\n    Time_Varying_Model_2022a_X.Integrator_CSTATE_m[0];\r\n\r\n  /* UnitConversion: '<S110>/Unit Conversion' */\r\n  Time_Varying_Model_2022a_B.UnitConversion_j[1] = 0.3048 *\r\n    Time_Varying_Model_2022a_B.Merge[1];\r\n\r\n  /* Integrator: '<S41>/Integrator' */\r\n  Time_Varying_Model_2022a_B.Integrator_o[1] =\r\n    Time_Varying_Model_2022a_X.Integrator_CSTATE_m[1];\r\n\r\n  /* UnitConversion: '<S110>/Unit Conversion' */\r\n  Time_Varying_Model_2022a_B.UnitConversion_j[2] = 0.3048 *\r\n    Time_Varying_Model_2022a_B.Merge[2];\r\n\r\n  /* Integrator: '<S41>/Integrator' */\r\n  Time_Varying_Model_2022a_B.Integrator_o[2] =\r\n    Time_Varying_Model_2022a_X.Integrator_CSTATE_m[2];\r\n\r\n  /* Sum: '<Root>/Sum' incorporates:\r\n   *  Constant: '<Root>/Windspeed'\r\n   */\r\n  Time_Varying_Model_2022a_B.Sum = Time_Varying_Model_2022a_B.UnitConversion_j[0]\r\n    + Time_Varying_Model_2022a_P.Windspeed_Value;\r\n\r\n  /* MATLAB Function: '<S1>/MATLAB Function4' */\r\n  /* :  ang_cos = cos(angle); */\r\n  ang_cos = cos(Time_Varying_Model_2022a_B.Integrator_o[0]);\r\n\r\n  /* :  ang_sin = sin(angle); */\r\n  ang_sin = sin(Time_Varying_Model_2022a_B.Integrator_o[0]);\r\n\r\n  /* :  if abs(ang_cos) < 1e-4 */\r\n  if (fabs(ang_cos) < 0.0001) {\r\n    /* :  ang_cos = 0; */\r\n    ang_cos = 0.0;\r\n  }\r\n\r\n  /* :  if abs(ang_sin) < 1e-4 */\r\n  if (fabs(ang_sin) < 0.0001) {\r\n    /* :  ang_sin = 0; */\r\n    ang_sin = 0.0;\r\n  }\r\n\r\n  /* :  windVector = [0; speed*ang_sin; speed*ang_cos]; */\r\n  Time_Varying_Model_2022a_B.windVector[0] = 0.0;\r\n  Time_Varying_Model_2022a_B.windVector[1] = Time_Varying_Model_2022a_B.Sum *\r\n    ang_sin;\r\n  Time_Varying_Model_2022a_B.windVector[2] = Time_Varying_Model_2022a_B.Sum *\r\n    ang_cos;\r\n\r\n  /* End of MATLAB Function: '<S1>/MATLAB Function4' */\r\n\r\n  /* Sum: '<S1>/Add' incorporates:\r\n   *  Constant: '<S1>/Constant1'\r\n   */\r\n  Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[0] =\r\n    Time_Varying_Model_2022a_B.windVector[0] +\r\n    Time_Varying_Model_2022a_B.OpenRocketVelocity;\r\n  Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[1] =\r\n    Time_Varying_Model_2022a_B.windVector[1] +\r\n    Time_Varying_Model_2022a_P.Constant1_Value_a;\r\n  Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[2] =\r\n    Time_Varying_Model_2022a_B.windVector[2] +\r\n    Time_Varying_Model_2022a_P.Constant1_Value_a;\r\n\r\n  /* Gain: '<S1>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_n = Time_Varying_Model_2022a_P.Gain_Gain_e *\r\n    Time_Varying_Model_2022a_B.Integrator3;\r\n\r\n  /* Gain: '<S45>/1//2' */\r\n  Time_Varying_Model_2022a_B.u2[0] = Time_Varying_Model_2022a_P.u2_Gain *\r\n    Time_Varying_Model_2022a_B.Integrator5;\r\n  Time_Varying_Model_2022a_B.u2[1] = Time_Varying_Model_2022a_P.u2_Gain *\r\n    Time_Varying_Model_2022a_B.Integrator4;\r\n  Time_Varying_Model_2022a_B.u2[2] = Time_Varying_Model_2022a_P.u2_Gain *\r\n    Time_Varying_Model_2022a_B.Gain_n;\r\n\r\n  /* Trigonometry: '<S45>/sincos' */\r\n  ang_sin = Time_Varying_Model_2022a_B.u2[0];\r\n  ang_cos = sin(ang_sin);\r\n  ang_sin = cos(ang_sin);\r\n  Time_Varying_Model_2022a_B.sincos_o1[0] = ang_cos;\r\n  Time_Varying_Model_2022a_B.sincos_o2[0] = ang_sin;\r\n  ang_sin = Time_Varying_Model_2022a_B.u2[1];\r\n  ang_cos = sin(ang_sin);\r\n  ang_sin = cos(ang_sin);\r\n  Time_Varying_Model_2022a_B.sincos_o1[1] = ang_cos;\r\n  Time_Varying_Model_2022a_B.sincos_o2[1] = ang_sin;\r\n  ang_sin = Time_Varying_Model_2022a_B.u2[2];\r\n  ang_cos = sin(ang_sin);\r\n  ang_sin = cos(ang_sin);\r\n  Time_Varying_Model_2022a_B.sincos_o1[2] = ang_cos;\r\n  Time_Varying_Model_2022a_B.sincos_o2[2] = ang_sin;\r\n\r\n  /* Fcn: '<S45>/q2' */\r\n  Time_Varying_Model_2022a_B.q2 = Time_Varying_Model_2022a_B.sincos_o2[0] *\r\n    Time_Varying_Model_2022a_B.sincos_o1[1] *\r\n    Time_Varying_Model_2022a_B.sincos_o2[2] -\r\n    Time_Varying_Model_2022a_B.sincos_o1[0] *\r\n    Time_Varying_Model_2022a_B.sincos_o2[1] *\r\n    Time_Varying_Model_2022a_B.sincos_o1[2];\r\n\r\n  /* Fcn: '<S45>/q0' */\r\n  Time_Varying_Model_2022a_B.q0 = Time_Varying_Model_2022a_B.sincos_o2[0] *\r\n    Time_Varying_Model_2022a_B.sincos_o2[1] *\r\n    Time_Varying_Model_2022a_B.sincos_o2[2] -\r\n    Time_Varying_Model_2022a_B.sincos_o1[0] *\r\n    Time_Varying_Model_2022a_B.sincos_o1[1] *\r\n    Time_Varying_Model_2022a_B.sincos_o1[2];\r\n\r\n  /* Product: '<S51>/Product' */\r\n  Time_Varying_Model_2022a_B.Product_e = Time_Varying_Model_2022a_B.q0 *\r\n    Time_Varying_Model_2022a_B.q0;\r\n\r\n  /* Fcn: '<S45>/q1' */\r\n  Time_Varying_Model_2022a_B.q1 = Time_Varying_Model_2022a_B.sincos_o2[0] *\r\n    Time_Varying_Model_2022a_B.sincos_o1[1] *\r\n    Time_Varying_Model_2022a_B.sincos_o1[2] +\r\n    Time_Varying_Model_2022a_B.sincos_o1[0] *\r\n    Time_Varying_Model_2022a_B.sincos_o2[1] *\r\n    Time_Varying_Model_2022a_B.sincos_o2[2];\r\n\r\n  /* Product: '<S51>/Product1' */\r\n  Time_Varying_Model_2022a_B.Product1 = Time_Varying_Model_2022a_B.q1 *\r\n    Time_Varying_Model_2022a_B.q1;\r\n\r\n  /* Product: '<S51>/Product2' */\r\n  Time_Varying_Model_2022a_B.Product2 = Time_Varying_Model_2022a_B.q2 *\r\n    Time_Varying_Model_2022a_B.q2;\r\n\r\n  /* Fcn: '<S45>/q3' */\r\n  Time_Varying_Model_2022a_B.q3 = Time_Varying_Model_2022a_B.sincos_o2[0] *\r\n    Time_Varying_Model_2022a_B.sincos_o2[1] *\r\n    Time_Varying_Model_2022a_B.sincos_o1[2] +\r\n    Time_Varying_Model_2022a_B.sincos_o1[0] *\r\n    Time_Varying_Model_2022a_B.sincos_o1[1] *\r\n    Time_Varying_Model_2022a_B.sincos_o2[2];\r\n\r\n  /* Product: '<S51>/Product3' */\r\n  Time_Varying_Model_2022a_B.Product3 = Time_Varying_Model_2022a_B.q3 *\r\n    Time_Varying_Model_2022a_B.q3;\r\n\r\n  /* Sum: '<S51>/Sum' */\r\n  Time_Varying_Model_2022a_B.Sum_l = ((Time_Varying_Model_2022a_B.Product_e +\r\n    Time_Varying_Model_2022a_B.Product1) + Time_Varying_Model_2022a_B.Product2)\r\n    + Time_Varying_Model_2022a_B.Product3;\r\n\r\n  /* Sqrt: '<S50>/sqrt' */\r\n  Time_Varying_Model_2022a_B.sqrt_e = sqrt(Time_Varying_Model_2022a_B.Sum_l);\r\n\r\n  /* Product: '<S46>/Product2' */\r\n  Time_Varying_Model_2022a_B.Product2_m = Time_Varying_Model_2022a_B.q2 /\r\n    Time_Varying_Model_2022a_B.sqrt_e;\r\n\r\n  /* Product: '<S47>/Product6' */\r\n  Time_Varying_Model_2022a_B.Product6 = Time_Varying_Model_2022a_B.Product2_m *\r\n    Time_Varying_Model_2022a_B.Product2_m;\r\n\r\n  /* Product: '<S46>/Product3' */\r\n  Time_Varying_Model_2022a_B.Product3_a = Time_Varying_Model_2022a_B.q3 /\r\n    Time_Varying_Model_2022a_B.sqrt_e;\r\n\r\n  /* Product: '<S47>/Product7' */\r\n  Time_Varying_Model_2022a_B.Product7 = Time_Varying_Model_2022a_B.Product3_a *\r\n    Time_Varying_Model_2022a_B.Product3_a;\r\n\r\n  /* Sum: '<S47>/Sum3' incorporates:\r\n   *  Constant: '<S47>/Constant'\r\n   */\r\n  Time_Varying_Model_2022a_B.Sum3 =\r\n    (Time_Varying_Model_2022a_P.Constant_Value_lw -\r\n     Time_Varying_Model_2022a_B.Product6) - Time_Varying_Model_2022a_B.Product7;\r\n\r\n  /* Gain: '<S47>/Gain2' */\r\n  Time_Varying_Model_2022a_B.Gain2 = Time_Varying_Model_2022a_P.Gain2_Gain *\r\n    Time_Varying_Model_2022a_B.Sum3;\r\n\r\n  /* Product: '<S47>/Product8' */\r\n  Time_Varying_Model_2022a_B.Product8 =\r\n    Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[0] *\r\n    Time_Varying_Model_2022a_B.Gain2;\r\n\r\n  /* Product: '<S46>/Product1' */\r\n  Time_Varying_Model_2022a_B.Product1_i = Time_Varying_Model_2022a_B.q1 /\r\n    Time_Varying_Model_2022a_B.sqrt_e;\r\n\r\n  /* Product: '<S47>/Product' */\r\n  Time_Varying_Model_2022a_B.Product_a = Time_Varying_Model_2022a_B.Product1_i *\r\n    Time_Varying_Model_2022a_B.Product2_m;\r\n\r\n  /* Product: '<S46>/Product' */\r\n  Time_Varying_Model_2022a_B.Product_f = Time_Varying_Model_2022a_B.q0 /\r\n    Time_Varying_Model_2022a_B.sqrt_e;\r\n\r\n  /* Product: '<S47>/Product1' */\r\n  Time_Varying_Model_2022a_B.Product1_d = Time_Varying_Model_2022a_B.Product_f *\r\n    Time_Varying_Model_2022a_B.Product3_a;\r\n\r\n  /* Sum: '<S47>/Sum1' */\r\n  Time_Varying_Model_2022a_B.Sum1_k = Time_Varying_Model_2022a_B.Product_a +\r\n    Time_Varying_Model_2022a_B.Product1_d;\r\n\r\n  /* Gain: '<S47>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_nk = Time_Varying_Model_2022a_P.Gain_Gain_k *\r\n    Time_Varying_Model_2022a_B.Sum1_k;\r\n\r\n  /* Product: '<S47>/Product4' */\r\n  Time_Varying_Model_2022a_B.Product4 = Time_Varying_Model_2022a_B.Gain_nk *\r\n    Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[1];\r\n\r\n  /* Product: '<S47>/Product2' */\r\n  Time_Varying_Model_2022a_B.Product2_c = Time_Varying_Model_2022a_B.Product_f *\r\n    Time_Varying_Model_2022a_B.Product2_m;\r\n\r\n  /* Product: '<S47>/Product3' */\r\n  Time_Varying_Model_2022a_B.Product3_h = Time_Varying_Model_2022a_B.Product1_i *\r\n    Time_Varying_Model_2022a_B.Product3_a;\r\n\r\n  /* Sum: '<S47>/Sum2' */\r\n  Time_Varying_Model_2022a_B.Sum2 = Time_Varying_Model_2022a_B.Product3_h -\r\n    Time_Varying_Model_2022a_B.Product2_c;\r\n\r\n  /* Gain: '<S47>/Gain1' */\r\n  Time_Varying_Model_2022a_B.Gain1 = Time_Varying_Model_2022a_P.Gain1_Gain *\r\n    Time_Varying_Model_2022a_B.Sum2;\r\n\r\n  /* Product: '<S47>/Product5' */\r\n  Time_Varying_Model_2022a_B.Product5 = Time_Varying_Model_2022a_B.Gain1 *\r\n    Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[2];\r\n\r\n  /* Sum: '<S47>/Sum' */\r\n  Time_Varying_Model_2022a_B.Sum_a = (Time_Varying_Model_2022a_B.Product8 +\r\n    Time_Varying_Model_2022a_B.Product4) + Time_Varying_Model_2022a_B.Product5;\r\n\r\n  /* Outport: '<Root>/airspeed_x' */\r\n  Time_Varying_Model_2022a_Y.airspeed_x = Time_Varying_Model_2022a_B.Sum_a;\r\n\r\n  /* Product: '<S48>/Product' */\r\n  Time_Varying_Model_2022a_B.Product_ee = Time_Varying_Model_2022a_B.Product1_i *\r\n    Time_Varying_Model_2022a_B.Product2_m;\r\n\r\n  /* Product: '<S48>/Product1' */\r\n  Time_Varying_Model_2022a_B.Product1_b = Time_Varying_Model_2022a_B.Product_f *\r\n    Time_Varying_Model_2022a_B.Product3_a;\r\n\r\n  /* Sum: '<S48>/Sum1' */\r\n  Time_Varying_Model_2022a_B.Sum1_f = Time_Varying_Model_2022a_B.Product_ee -\r\n    Time_Varying_Model_2022a_B.Product1_b;\r\n\r\n  /* Gain: '<S48>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_p = Time_Varying_Model_2022a_P.Gain_Gain_ev *\r\n    Time_Varying_Model_2022a_B.Sum1_f;\r\n\r\n  /* Product: '<S48>/Product4' */\r\n  Time_Varying_Model_2022a_B.Product4_j =\r\n    Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[0] *\r\n    Time_Varying_Model_2022a_B.Gain_p;\r\n\r\n  /* Product: '<S48>/Product6' */\r\n  Time_Varying_Model_2022a_B.Product6_f = Time_Varying_Model_2022a_B.Product1_i *\r\n    Time_Varying_Model_2022a_B.Product1_i;\r\n\r\n  /* Product: '<S48>/Product7' */\r\n  Time_Varying_Model_2022a_B.Product7_h = Time_Varying_Model_2022a_B.Product3_a *\r\n    Time_Varying_Model_2022a_B.Product3_a;\r\n\r\n  /* Sum: '<S48>/Sum3' incorporates:\r\n   *  Constant: '<S48>/Constant'\r\n   */\r\n  Time_Varying_Model_2022a_B.Sum3_a =\r\n    (Time_Varying_Model_2022a_P.Constant_Value_o -\r\n     Time_Varying_Model_2022a_B.Product6_f) -\r\n    Time_Varying_Model_2022a_B.Product7_h;\r\n\r\n  /* Gain: '<S48>/Gain2' */\r\n  Time_Varying_Model_2022a_B.Gain2_p = Time_Varying_Model_2022a_P.Gain2_Gain_o *\r\n    Time_Varying_Model_2022a_B.Sum3_a;\r\n\r\n  /* Product: '<S48>/Product8' */\r\n  Time_Varying_Model_2022a_B.Product8_g = Time_Varying_Model_2022a_B.Gain2_p *\r\n    Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[1];\r\n\r\n  /* Product: '<S48>/Product2' */\r\n  Time_Varying_Model_2022a_B.Product2_b = Time_Varying_Model_2022a_B.Product_f *\r\n    Time_Varying_Model_2022a_B.Product1_i;\r\n\r\n  /* Product: '<S48>/Product3' */\r\n  Time_Varying_Model_2022a_B.Product3_l = Time_Varying_Model_2022a_B.Product2_m *\r\n    Time_Varying_Model_2022a_B.Product3_a;\r\n\r\n  /* Sum: '<S48>/Sum2' */\r\n  Time_Varying_Model_2022a_B.Sum2_k = Time_Varying_Model_2022a_B.Product2_b +\r\n    Time_Varying_Model_2022a_B.Product3_l;\r\n\r\n  /* Gain: '<S48>/Gain1' */\r\n  Time_Varying_Model_2022a_B.Gain1_l = Time_Varying_Model_2022a_P.Gain1_Gain_d *\r\n    Time_Varying_Model_2022a_B.Sum2_k;\r\n\r\n  /* Product: '<S48>/Product5' */\r\n  Time_Varying_Model_2022a_B.Product5_a = Time_Varying_Model_2022a_B.Gain1_l *\r\n    Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[2];\r\n\r\n  /* Sum: '<S48>/Sum' */\r\n  Time_Varying_Model_2022a_B.Sum_n = (Time_Varying_Model_2022a_B.Product4_j +\r\n    Time_Varying_Model_2022a_B.Product8_g) +\r\n    Time_Varying_Model_2022a_B.Product5_a;\r\n\r\n  /* Outport: '<Root>/airspeed_y' */\r\n  Time_Varying_Model_2022a_Y.airspeed_y = Time_Varying_Model_2022a_B.Sum_n;\r\n\r\n  /* Product: '<S49>/Product' */\r\n  Time_Varying_Model_2022a_B.Product_d = Time_Varying_Model_2022a_B.Product1_i *\r\n    Time_Varying_Model_2022a_B.Product3_a;\r\n\r\n  /* Product: '<S49>/Product1' */\r\n  Time_Varying_Model_2022a_B.Product1_k = Time_Varying_Model_2022a_B.Product_f *\r\n    Time_Varying_Model_2022a_B.Product2_m;\r\n\r\n  /* Sum: '<S49>/Sum1' */\r\n  Time_Varying_Model_2022a_B.Sum1_m = Time_Varying_Model_2022a_B.Product_d +\r\n    Time_Varying_Model_2022a_B.Product1_k;\r\n\r\n  /* Gain: '<S49>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_i = Time_Varying_Model_2022a_P.Gain_Gain_ob *\r\n    Time_Varying_Model_2022a_B.Sum1_m;\r\n\r\n  /* Product: '<S49>/Product4' */\r\n  Time_Varying_Model_2022a_B.Product4_n =\r\n    Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[0] *\r\n    Time_Varying_Model_2022a_B.Gain_i;\r\n\r\n  /* Product: '<S49>/Product2' */\r\n  Time_Varying_Model_2022a_B.Product2_a = Time_Varying_Model_2022a_B.Product_f *\r\n    Time_Varying_Model_2022a_B.Product1_i;\r\n\r\n  /* Product: '<S49>/Product3' */\r\n  Time_Varying_Model_2022a_B.Product3_n = Time_Varying_Model_2022a_B.Product2_m *\r\n    Time_Varying_Model_2022a_B.Product3_a;\r\n\r\n  /* Sum: '<S49>/Sum2' */\r\n  Time_Varying_Model_2022a_B.Sum2_n = Time_Varying_Model_2022a_B.Product3_n -\r\n    Time_Varying_Model_2022a_B.Product2_a;\r\n\r\n  /* Gain: '<S49>/Gain1' */\r\n  Time_Varying_Model_2022a_B.Gain1_k = Time_Varying_Model_2022a_P.Gain1_Gain_k *\r\n    Time_Varying_Model_2022a_B.Sum2_n;\r\n\r\n  /* Product: '<S49>/Product5' */\r\n  Time_Varying_Model_2022a_B.Product5_b = Time_Varying_Model_2022a_B.Gain1_k *\r\n    Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[1];\r\n\r\n  /* Product: '<S49>/Product6' */\r\n  Time_Varying_Model_2022a_B.Product6_a = Time_Varying_Model_2022a_B.Product1_i *\r\n    Time_Varying_Model_2022a_B.Product1_i;\r\n\r\n  /* Product: '<S49>/Product7' */\r\n  Time_Varying_Model_2022a_B.Product7_l = Time_Varying_Model_2022a_B.Product2_m *\r\n    Time_Varying_Model_2022a_B.Product2_m;\r\n\r\n  /* Sum: '<S49>/Sum3' incorporates:\r\n   *  Constant: '<S49>/Constant'\r\n   */\r\n  Time_Varying_Model_2022a_B.Sum3_p =\r\n    (Time_Varying_Model_2022a_P.Constant_Value_f -\r\n     Time_Varying_Model_2022a_B.Product6_a) -\r\n    Time_Varying_Model_2022a_B.Product7_l;\r\n\r\n  /* Gain: '<S49>/Gain2' */\r\n  Time_Varying_Model_2022a_B.Gain2_b = Time_Varying_Model_2022a_P.Gain2_Gain_a *\r\n    Time_Varying_Model_2022a_B.Sum3_p;\r\n\r\n  /* Product: '<S49>/Product8' */\r\n  Time_Varying_Model_2022a_B.Product8_b = Time_Varying_Model_2022a_B.Gain2_b *\r\n    Time_Varying_Model_2022a_B.airspeedvectoringlobalframe[2];\r\n\r\n  /* Sum: '<S49>/Sum' */\r\n  Time_Varying_Model_2022a_B.Sum_ai = (Time_Varying_Model_2022a_B.Product4_n +\r\n    Time_Varying_Model_2022a_B.Product5_b) +\r\n    Time_Varying_Model_2022a_B.Product8_b;\r\n\r\n  /* Outport: '<Root>/airspeed_z' */\r\n  Time_Varying_Model_2022a_Y.airspeed_z = Time_Varying_Model_2022a_B.Sum_ai;\r\n\r\n  /* SignalConversion generated from: '<S43>/ SFunction ' incorporates:\r\n   *  MATLAB Function: '<S1>/MATLAB Function5'\r\n   */\r\n  Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctionI[0] =\r\n    Time_Varying_Model_2022a_B.Sum_a;\r\n  Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctionI[1] =\r\n    Time_Varying_Model_2022a_B.Sum_n;\r\n  Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctionI[2] =\r\n    Time_Varying_Model_2022a_B.Sum_ai;\r\n\r\n  /* SignalConversion generated from: '<S43>/ SFunction ' incorporates:\r\n   *  Constant: '<S1>/Constant'\r\n   *  Constant: '<S1>/Constant16'\r\n   *  MATLAB Function: '<S1>/MATLAB Function5'\r\n   */\r\n  Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctio_d[0] =\r\n    Time_Varying_Model_2022a_P.Constant_Value_ji;\r\n  Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctio_d[1] =\r\n    Time_Varying_Model_2022a_P.Constant16_Value;\r\n  Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctio_d[2] =\r\n    Time_Varying_Model_2022a_P.Constant16_Value;\r\n\r\n  /* MATLAB Function: '<S1>/MATLAB Function5' incorporates:\r\n   *  SignalConversion generated from: '<S43>/ SFunction '\r\n   */\r\n  /* :  airspeedVector_xy = [airspeedVector(1); airspeedVector(2); 0]; */\r\n  ang_sin = Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctionI[0];\r\n  st_idx_1 = Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctionI[1];\r\n\r\n  /* :  airspeedVector_xz = [airspeedVector(1); 0; airspeedVector(3)]; */\r\n  ct_idx_0 = Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctionI[0];\r\n  ct_idx_2 = Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctionI[2];\r\n\r\n  /* :  alpha = atan2(airspeedVector_xz(3), airspeedVector_xz(1)); */\r\n  /* :  beta = atan2(airspeedVector_xy(2), airspeedVector_xy(1)); */\r\n  /* :  alphaTotal = acos(dot(airspeedVector, rocketVector)/(norm(airspeedVector)*norm(rocketVector))); */\r\n  ang_cos = Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctionI[0] *\r\n    Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctio_d[0];\r\n  ang_cos += Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctionI[1] *\r\n    Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctio_d[1];\r\n  ang_cos += Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctionI[2] *\r\n    Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctio_d[2];\r\n\r\n  /* :  windAngles = [alpha; beta; alphaTotal]; */\r\n  ct_idx_0 = rt_atan2d_snf(ct_idx_2, ct_idx_0);\r\n  ang_sin = rt_atan2d_snf(st_idx_1, ang_sin);\r\n  st_idx_1 = Time_Varying_Model_2022a_norm\r\n    (Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctionI);\r\n  ct_idx_2 = Time_Varying_Model_2022a_norm\r\n    (Time_Varying_Model_2022a_B.TmpSignalConversionAtSFunctio_d);\r\n  st_idx_1 = acos(ang_cos / (st_idx_1 * ct_idx_2));\r\n  Time_Varying_Model_2022a_B.windAngles[0] = ct_idx_0;\r\n  Time_Varying_Model_2022a_B.windAngles[1] = ang_sin;\r\n  Time_Varying_Model_2022a_B.windAngles[2] = st_idx_1;\r\n\r\n  /* Gain: '<S27>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_gn = Time_Varying_Model_2022a_P.Gain_Gain_fn *\r\n    Time_Varying_Model_2022a_B.windAngles[0];\r\n\r\n  /* Outport: '<Root>/alphaOut' */\r\n  Time_Varying_Model_2022a_Y.alpha = Time_Varying_Model_2022a_B.Gain_gn;\r\n\r\n  /* Gain: '<S28>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_lo = Time_Varying_Model_2022a_P.Gain_Gain_kf *\r\n    Time_Varying_Model_2022a_B.windAngles[1];\r\n\r\n  /* Outport: '<Root>/betaOut' */\r\n  Time_Varying_Model_2022a_Y.beta = Time_Varying_Model_2022a_B.Gain_lo;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n  }\r\n\r\n  /* Gain: '<S19>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_ly = Time_Varying_Model_2022a_P.Gain_Gain_ou *\r\n    Time_Varying_Model_2022a_B.windAngles[0];\r\n\r\n  /* Gain: '<S20>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_b = Time_Varying_Model_2022a_P.Gain_Gain_d *\r\n    Time_Varying_Model_2022a_B.windAngles[1];\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n  }\r\n\r\n  /* MATLAB Function: '<Root>/MATLAB Function' incorporates:\r\n   *  Constant: '<Root>/Constant32'\r\n   *  Constant: '<Root>/Constant33'\r\n   *  Constant: '<Root>/Constant34'\r\n   *  Constant: '<Root>/Constant6'\r\n   */\r\n  /* :  if alpha == 0 */\r\n  if (Time_Varying_Model_2022a_B.windAngles[2] == 0.0) {\r\n    /* :  a1 = 1; */\r\n    ang_cos = 1.0;\r\n\r\n    /* :  a2 = 0; */\r\n    ang_sin = 0.0;\r\n  } else {\r\n    /* :  else */\r\n    /* :  a1  = sin(alpha)/alpha; */\r\n    ang_cos = sin(Time_Varying_Model_2022a_B.windAngles[2]) /\r\n      Time_Varying_Model_2022a_B.windAngles[2];\r\n\r\n    /* :  a2  = (sin(alpha)^2)/alpha; */\r\n    ang_sin = sin(Time_Varying_Model_2022a_B.windAngles[2]);\r\n    ang_sin = ang_sin * ang_sin / Time_Varying_Model_2022a_B.windAngles[2];\r\n  }\r\n\r\n  /* :  CNa_nose = (2/A_ref)*(A_l-A_0)*a1+K*(A_plan/A_ref)*a2; */\r\n  Time_Varying_Model_2022a_B.CNa_nose = 2.0 /\r\n    Time_Varying_Model_2022a_P.Constant6_Value *\r\n    (Time_Varying_Model_2022a_P.Constant6_Value -\r\n     Time_Varying_Model_2022a_P.Constant32_Value) * ang_cos +\r\n    Time_Varying_Model_2022a_P.Constant33_Value /\r\n    Time_Varying_Model_2022a_P.Constant6_Value *\r\n    Time_Varying_Model_2022a_P.Constant34_Value * ang_sin;\r\n\r\n  /* End of MATLAB Function: '<Root>/MATLAB Function' */\r\n\r\n  /* Product: '<S5>/Product' incorporates:\r\n   *  Constant: '<Root>/Constant22'\r\n   */\r\n  Time_Varying_Model_2022a_B.Product_k = Time_Varying_Model_2022a_B.CNa_nose *\r\n    Time_Varying_Model_2022a_P.Constant22_Value;\r\n\r\n  /* MATLAB Function: '<Root>/MATLAB Function2' incorporates:\r\n   *  Constant: '<Root>/Constant35'\r\n   *  Constant: '<Root>/Constant36'\r\n   *  Constant: '<Root>/Constant6'\r\n   */\r\n  /* :  if alpha == 0 */\r\n  if (Time_Varying_Model_2022a_B.windAngles[2] == 0.0) {\r\n    /* :  a1 = 1; */\r\n    ang_cos = 1.0;\r\n\r\n    /* :  a2 = 0; */\r\n    ang_sin = 0.0;\r\n  } else {\r\n    /* :  else */\r\n    /* :  a1  = sin(alpha)/alpha; */\r\n    ang_cos = sin(Time_Varying_Model_2022a_B.windAngles[2]) /\r\n      Time_Varying_Model_2022a_B.windAngles[2];\r\n\r\n    /* :  a2  = (sin(alpha)^2)/alpha; */\r\n    ang_sin = sin(Time_Varying_Model_2022a_B.windAngles[2]);\r\n    ang_sin = ang_sin * ang_sin / Time_Varying_Model_2022a_B.windAngles[2];\r\n  }\r\n\r\n  /* :  CNa_body = (2/A_ref)*(A_l-A_0)*a1+K*(A_plan/A_ref)*a2; */\r\n  Time_Varying_Model_2022a_B.CNa_body = 2.0 /\r\n    Time_Varying_Model_2022a_P.Constant6_Value *\r\n    (Time_Varying_Model_2022a_P.Constant6_Value -\r\n     Time_Varying_Model_2022a_P.Constant6_Value) * ang_cos +\r\n    Time_Varying_Model_2022a_P.Constant35_Value /\r\n    Time_Varying_Model_2022a_P.Constant6_Value *\r\n    Time_Varying_Model_2022a_P.Constant36_Value * ang_sin;\r\n\r\n  /* End of MATLAB Function: '<Root>/MATLAB Function2' */\r\n\r\n  /* Product: '<S5>/Product1' incorporates:\r\n   *  Constant: '<Root>/Constant23'\r\n   */\r\n  Time_Varying_Model_2022a_B.Product1_a = Time_Varying_Model_2022a_B.CNa_body *\r\n    Time_Varying_Model_2022a_P.Constant23_Value;\r\n\r\n  /* Lookup_n-D: '<Root>/OpenRocket Mach No' incorporates:\r\n   *  Clock: '<Root>/Clock'\r\n   */\r\n  Time_Varying_Model_2022a_B.OpenRocketMachNo = look1_binlxpw\r\n    (Time_Varying_Model_2022a_B.Clock,\r\n     Time_Varying_Model_2022a_P.OpenRocketMachNo_bp01Data,\r\n     Time_Varying_Model_2022a_P.OpenRocketMachNo_tableData, 222U);\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n    /* Gain: '<Root>/Gain2' incorporates:\r\n     *  Constant: '<Root>/Constant11'\r\n     */\r\n    Time_Varying_Model_2022a_B.Gain2_j =\r\n      Time_Varying_Model_2022a_P.Gain2_Gain_a5 *\r\n      Time_Varying_Model_2022a_P.Constant11_Value;\r\n  }\r\n\r\n  /* MATLAB Function: '<Root>/MATLAB Function1' incorporates:\r\n   *  Constant: '<Root>/Constant39'\r\n   *  Constant: '<Root>/Constant40'\r\n   *  Constant: '<Root>/Constant41'\r\n   *  Constant: '<Root>/Constant6'\r\n   */\r\n  /* :  CNa1_num = 2*pi()*(s^2/A_ref); */\r\n  /* :  CNa1_den = 1 + sqrt(1+(((s^2)*sqrt(1-M^2))/(A_fin*cos(G_c)))^2); */\r\n  ang_sin = sqrt(1.0 - Time_Varying_Model_2022a_B.OpenRocketMachNo *\r\n                 Time_Varying_Model_2022a_B.OpenRocketMachNo) *\r\n    (Time_Varying_Model_2022a_P.Constant39_Value *\r\n     Time_Varying_Model_2022a_P.Constant39_Value) /\r\n    (Time_Varying_Model_2022a_P.Constant40_Value * cos\r\n     (Time_Varying_Model_2022a_P.Constant41_Value));\r\n\r\n  /* :  CNa1 = CNa1_num / CNa1_den; */\r\n  /* :  CNa4 = 2*CNa1; */\r\n  /* :  K_TB = 1 + r_t/(s+r_t); */\r\n  /* :  CNa_fins = K_TB*CNa4; */\r\n  Time_Varying_Model_2022a_B.CNa_fins =\r\n    Time_Varying_Model_2022a_P.Constant39_Value *\r\n    Time_Varying_Model_2022a_P.Constant39_Value /\r\n    Time_Varying_Model_2022a_P.Constant6_Value * 6.2831853071795862 / (sqrt\r\n    (ang_sin * ang_sin + 1.0) + 1.0) * 2.0 * (Time_Varying_Model_2022a_B.Gain2_j\r\n    / (Time_Varying_Model_2022a_P.Constant39_Value +\r\n       Time_Varying_Model_2022a_B.Gain2_j) + 1.0);\r\n\r\n  /* Product: '<S5>/Product2' incorporates:\r\n   *  Constant: '<Root>/Constant24'\r\n   */\r\n  Time_Varying_Model_2022a_B.Product2_j = Time_Varying_Model_2022a_B.CNa_fins *\r\n    Time_Varying_Model_2022a_P.Constant24_Value;\r\n\r\n  /* Sum: '<S5>/Sum of Elements' */\r\n  Time_Varying_Model_2022a_B.SumofElements =\r\n    (Time_Varying_Model_2022a_B.Product_k +\r\n     Time_Varying_Model_2022a_B.Product1_a) +\r\n    Time_Varying_Model_2022a_B.Product2_j;\r\n\r\n  /* Sum: '<S5>/Sum of Elements1' */\r\n  Time_Varying_Model_2022a_B.SumofElements1 =\r\n    (Time_Varying_Model_2022a_B.CNa_nose + Time_Varying_Model_2022a_B.CNa_body)\r\n    + Time_Varying_Model_2022a_B.CNa_fins;\r\n\r\n  /* Product: '<S5>/Divide' */\r\n  Time_Varying_Model_2022a_B.Divide_c = Time_Varying_Model_2022a_B.SumofElements\r\n    / Time_Varying_Model_2022a_B.SumofElements1;\r\n\r\n  /* MATLAB Function: '<Root>/MATLAB Function4' */\r\n  /* :  T0 = 288.15; */\r\n  /* :  rho0 = 1.2256; */\r\n  /* :  L = 0.0065; */\r\n  /* :  g = 9.81; */\r\n  /* :  R = 287.26; */\r\n  /* :  rho = rho0*((T0-L*h)/T0)^((g/(L*R))-1); */\r\n  Time_Varying_Model_2022a_B.rho = rt_powd_snf((288.15 - 0.0065 *\r\n    Time_Varying_Model_2022a_B.OpenRocketalt) / 288.15, 4.2538841788998445) *\r\n    1.2256;\r\n\r\n  /* Sum: '<S8>/Sum4' */\r\n  Time_Varying_Model_2022a_B.Sum4 = Time_Varying_Model_2022a_B.rho;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n  }\r\n\r\n  /* Sum: '<S8>/Sum3' */\r\n  Time_Varying_Model_2022a_B.Sum3_d =\r\n    Time_Varying_Model_2022a_B.OpenRocketVelocity;\r\n\r\n  /* Math: '<S8>/Square' */\r\n  Time_Varying_Model_2022a_B.Square = Time_Varying_Model_2022a_B.Sum3_d *\r\n    Time_Varying_Model_2022a_B.Sum3_d;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n  }\r\n\r\n  /* Product: '<S8>/Product' */\r\n  Time_Varying_Model_2022a_B.Product_ax = Time_Varying_Model_2022a_B.Sum4 *\r\n    Time_Varying_Model_2022a_B.Square;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n  }\r\n\r\n  /* Sum: '<S8>/Sum' */\r\n  Time_Varying_Model_2022a_B.Sum_b = Time_Varying_Model_2022a_B.Product_ax;\r\n\r\n  /* RateTransition: '<S8>/Rate Transition1' */\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n    if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n        Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[3] == 0) {\r\n      Time_Varying_Model_2022a_DW.RateTransition1_Buffer =\r\n        Time_Varying_Model_2022a_B.Sum_b;\r\n    }\r\n\r\n    /* MATLAB Function: '<S102>/SqrtUsedFcn' incorporates:\r\n     *  Constant: '<S102>/isSqrtUsed'\r\n     *  Constant: '<S53>/CovarianceZ'\r\n     */\r\n    /* :  if isSqrtUsed */\r\n    if (Time_Varying_Model_2022a_P.isSqrtUsed_Value) {\r\n      /* :  P = u*u.'; */\r\n      Time_Varying_Model_2022a_B.P =\r\n        Time_Varying_Model_2022a_P.CovarianceZ_Value *\r\n        Time_Varying_Model_2022a_P.CovarianceZ_Value;\r\n    } else {\r\n      /* :  else */\r\n      /* :  P = u; */\r\n      Time_Varying_Model_2022a_B.P =\r\n        Time_Varying_Model_2022a_P.CovarianceZ_Value;\r\n    }\r\n\r\n    /* End of MATLAB Function: '<S102>/SqrtUsedFcn' */\r\n  }\r\n\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[3] == 0) {\r\n    /* RateTransition: '<S8>/Rate Transition1' */\r\n    Time_Varying_Model_2022a_B.RateTransition1 =\r\n      Time_Varying_Model_2022a_DW.RateTransition1_Buffer;\r\n\r\n    /* Delay: '<S52>/MemoryX' incorporates:\r\n     *  Constant: '<S52>/X0'\r\n     */\r\n    if (Time_Varying_Model_2022a_DW.icLoad) {\r\n      Time_Varying_Model_2022a_DW.MemoryX_DSTATE =\r\n        Time_Varying_Model_2022a_P.X0_Value;\r\n    }\r\n\r\n    /* Delay: '<S52>/MemoryX' */\r\n    Time_Varying_Model_2022a_B.MemoryX =\r\n      Time_Varying_Model_2022a_DW.MemoryX_DSTATE;\r\n\r\n    /* Outputs for Enabled SubSystem: '<S80>/Enabled Subsystem' incorporates:\r\n     *  EnablePort: '<S106>/Enable'\r\n     */\r\n    if (rtsiIsModeUpdateTimeStep(&Time_Varying_Model_2022a_M->solverInfo)) {\r\n      if (Time_Varying_Model_2022a_P.Enable_Value) {\r\n        Time_Varying_Model_2022a_DW.EnabledSubsystem_MODE = true;\r\n      } else if (Time_Varying_Model_2022a_DW.EnabledSubsystem_MODE) {\r\n        /* Disable for Product: '<S106>/Product2' incorporates:\r\n         *  Outport: '<S106>/deltax'\r\n         */\r\n        Time_Varying_Model_2022a_B.Product2_cw =\r\n          Time_Varying_Model_2022a_P.deltax_Y0;\r\n        Time_Varying_Model_2022a_DW.EnabledSubsystem_MODE = false;\r\n      }\r\n    }\r\n\r\n    if (Time_Varying_Model_2022a_DW.EnabledSubsystem_MODE) {\r\n      /* Product: '<S106>/Product' incorporates:\r\n       *  Constant: '<S52>/C'\r\n       */\r\n      ang_sin = Time_Varying_Model_2022a_P.C_Value;\r\n      ang_cos = Time_Varying_Model_2022a_B.MemoryX;\r\n\r\n      /* Product: '<S106>/Product' */\r\n      Time_Varying_Model_2022a_B.Product_n = ang_sin * ang_cos;\r\n\r\n      /* Sum: '<S106>/Add1' */\r\n      Time_Varying_Model_2022a_B.Add1 =\r\n        Time_Varying_Model_2022a_B.RateTransition1 -\r\n        Time_Varying_Model_2022a_B.Product_n;\r\n\r\n      /* Product: '<S106>/Product2' incorporates:\r\n       *  Constant: '<S53>/KalmanGainM'\r\n       */\r\n      ang_sin = Time_Varying_Model_2022a_P.KalmanGainM_Value;\r\n      ang_cos = Time_Varying_Model_2022a_B.Add1;\r\n\r\n      /* Product: '<S106>/Product2' */\r\n      Time_Varying_Model_2022a_B.Product2_cw = ang_sin * ang_cos;\r\n    }\r\n\r\n    /* End of Outputs for SubSystem: '<S80>/Enabled Subsystem' */\r\n\r\n    /* Sum: '<S80>/Add' incorporates:\r\n     *  Constant: '<S52>/Enable'\r\n     */\r\n    Time_Varying_Model_2022a_B.Add = Time_Varying_Model_2022a_B.Product2_cw +\r\n      Time_Varying_Model_2022a_B.MemoryX;\r\n\r\n    /* Gain: '<S8>/Gain3' */\r\n    Time_Varying_Model_2022a_B.Gain3 = Time_Varying_Model_2022a_P.Gain3_Gain *\r\n      Time_Varying_Model_2022a_B.Add;\r\n  }\r\n\r\n  /* End of RateTransition: '<S8>/Rate Transition1' */\r\n\r\n  /* RateTransition: '<S8>/Rate Transition' */\r\n  if ((rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n       Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) &&\r\n      (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n       Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[3] == 0)) {\r\n    Time_Varying_Model_2022a_DW.RateTransition_Buffer =\r\n      Time_Varying_Model_2022a_B.Square;\r\n  }\r\n\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[3] == 0) {\r\n    /* Product: '<S73>/A[k]*xhat[k|k-1]' incorporates:\r\n     *  Constant: '<S52>/A'\r\n     */\r\n    ang_sin = Time_Varying_Model_2022a_P.A_Value;\r\n    ang_cos = Time_Varying_Model_2022a_B.MemoryX;\r\n\r\n    /* Product: '<S73>/A[k]*xhat[k|k-1]' */\r\n    Time_Varying_Model_2022a_B.Akxhatkk1 = ang_sin * ang_cos;\r\n\r\n    /* RateTransition: '<S8>/Rate Transition' */\r\n    Time_Varying_Model_2022a_B.RateTransition =\r\n      Time_Varying_Model_2022a_DW.RateTransition_Buffer;\r\n\r\n    /* Product: '<S73>/B[k]*u[k]' incorporates:\r\n     *  Constant: '<S52>/B'\r\n     */\r\n    ang_sin = Time_Varying_Model_2022a_P.B_Value;\r\n    ang_cos = Time_Varying_Model_2022a_B.RateTransition;\r\n\r\n    /* Product: '<S73>/B[k]*u[k]' */\r\n    Time_Varying_Model_2022a_B.Bkuk = ang_sin * ang_cos;\r\n\r\n    /* Outputs for Enabled SubSystem: '<S73>/MeasurementUpdate' incorporates:\r\n     *  EnablePort: '<S104>/Enable'\r\n     */\r\n    if (rtsiIsModeUpdateTimeStep(&Time_Varying_Model_2022a_M->solverInfo)) {\r\n      if (Time_Varying_Model_2022a_P.Enable_Value) {\r\n        Time_Varying_Model_2022a_DW.MeasurementUpdate_MODE = true;\r\n      } else if (Time_Varying_Model_2022a_DW.MeasurementUpdate_MODE) {\r\n        /* Disable for Product: '<S104>/Product3' incorporates:\r\n         *  Outport: '<S104>/L*(y[k]-yhat[k|k-1])'\r\n         */\r\n        Time_Varying_Model_2022a_B.Product3_lw =\r\n          Time_Varying_Model_2022a_P.Lykyhatkk1_Y0;\r\n        Time_Varying_Model_2022a_DW.MeasurementUpdate_MODE = false;\r\n      }\r\n    }\r\n\r\n    if (Time_Varying_Model_2022a_DW.MeasurementUpdate_MODE) {\r\n      /* Product: '<S104>/C[k]*xhat[k|k-1]' incorporates:\r\n       *  Constant: '<S52>/C'\r\n       */\r\n      ang_sin = Time_Varying_Model_2022a_P.C_Value;\r\n      ang_cos = Time_Varying_Model_2022a_B.MemoryX;\r\n\r\n      /* Product: '<S104>/C[k]*xhat[k|k-1]' */\r\n      Time_Varying_Model_2022a_B.Ckxhatkk1 = ang_sin * ang_cos;\r\n\r\n      /* Product: '<S104>/D[k]*u[k]' incorporates:\r\n       *  Constant: '<S52>/D'\r\n       */\r\n      ang_sin = Time_Varying_Model_2022a_P.D_Value;\r\n      ang_cos = Time_Varying_Model_2022a_B.RateTransition;\r\n\r\n      /* Product: '<S104>/D[k]*u[k]' */\r\n      Time_Varying_Model_2022a_B.Dkuk = ang_sin * ang_cos;\r\n\r\n      /* Sum: '<S104>/Add1' */\r\n      Time_Varying_Model_2022a_B.yhatkk1 = Time_Varying_Model_2022a_B.Ckxhatkk1\r\n        + Time_Varying_Model_2022a_B.Dkuk;\r\n\r\n      /* Sum: '<S104>/Sum' */\r\n      Time_Varying_Model_2022a_B.Sum_e =\r\n        Time_Varying_Model_2022a_B.RateTransition1 -\r\n        Time_Varying_Model_2022a_B.yhatkk1;\r\n\r\n      /* Product: '<S104>/Product3' incorporates:\r\n       *  Constant: '<S53>/KalmanGainL'\r\n       */\r\n      ang_sin = Time_Varying_Model_2022a_P.KalmanGainL_Value;\r\n      ang_cos = Time_Varying_Model_2022a_B.Sum_e;\r\n\r\n      /* Product: '<S104>/Product3' */\r\n      Time_Varying_Model_2022a_B.Product3_lw = ang_sin * ang_cos;\r\n    }\r\n\r\n    /* End of Outputs for SubSystem: '<S73>/MeasurementUpdate' */\r\n\r\n    /* Sum: '<S73>/Add' incorporates:\r\n     *  Constant: '<S52>/Enable'\r\n     */\r\n    Time_Varying_Model_2022a_B.Add_p = (Time_Varying_Model_2022a_B.Bkuk +\r\n      Time_Varying_Model_2022a_B.Akxhatkk1) +\r\n      Time_Varying_Model_2022a_B.Product3_lw;\r\n  }\r\n\r\n  /* End of RateTransition: '<S8>/Rate Transition' */\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n    /* Gain: '<Root>/Gain' incorporates:\r\n     *  Constant: '<Root>/Constant11'\r\n     */\r\n    Time_Varying_Model_2022a_B.Gain_h = Time_Varying_Model_2022a_P.Gain_Gain_du *\r\n      Time_Varying_Model_2022a_P.Constant11_Value;\r\n  }\r\n\r\n  /* MATLAB Function: '<Root>/MATLAB Function3' incorporates:\r\n   *  Constant: '<Root>/Constant28'\r\n   *  Constant: '<Root>/Constant37'\r\n   *  Constant: '<Root>/Constant38'\r\n   *  Constant: '<Root>/Constant6'\r\n   */\r\n  /* :  CNa1_num = 2*pi()*(s^2/A_ref); */\r\n  /* :  CNa1_den = 1 + sqrt(1+(((s^2)*sqrt(1-M^2))/(A_fin*cos(G_c)))^2); */\r\n  ang_sin = sqrt(1.0 - Time_Varying_Model_2022a_B.OpenRocketMachNo *\r\n                 Time_Varying_Model_2022a_B.OpenRocketMachNo) *\r\n    (Time_Varying_Model_2022a_P.Constant37_Value *\r\n     Time_Varying_Model_2022a_P.Constant37_Value) /\r\n    (Time_Varying_Model_2022a_P.Constant28_Value * cos\r\n     (Time_Varying_Model_2022a_P.Constant38_Value));\r\n\r\n  /* :  CNa1 = CNa1_num / CNa1_den; */\r\n  /* :  CNa4 = 2*CNa1; */\r\n  /* :  K_TB = 1 + r_t/(s+r_t); */\r\n  /* :  CNa_can = K_TB*CNa4; */\r\n  Time_Varying_Model_2022a_B.CNa_can =\r\n    Time_Varying_Model_2022a_P.Constant37_Value *\r\n    Time_Varying_Model_2022a_P.Constant37_Value /\r\n    Time_Varying_Model_2022a_P.Constant6_Value * 6.2831853071795862 / (sqrt\r\n    (ang_sin * ang_sin + 1.0) + 1.0) * 2.0 * (Time_Varying_Model_2022a_B.Gain_h /\r\n    (Time_Varying_Model_2022a_P.Constant37_Value +\r\n     Time_Varying_Model_2022a_B.Gain_h) + 1.0);\r\n\r\n  /* Lookup_n-D: '<Root>/OpenRocket I_L' incorporates:\r\n   *  Clock: '<Root>/Clock'\r\n   */\r\n  Time_Varying_Model_2022a_B.OpenRocketI_L = look1_binlxpw\r\n    (Time_Varying_Model_2022a_B.Clock,\r\n     Time_Varying_Model_2022a_P.OpenRocketI_L_bp01Data,\r\n     Time_Varying_Model_2022a_P.OpenRocketI_L_tableData, 222U);\r\n\r\n  /* Lookup_n-D: '<Root>/OpenRocket I_R' incorporates:\r\n   *  Clock: '<Root>/Clock'\r\n   */\r\n  Time_Varying_Model_2022a_B.OpenRocketI_R = look1_binlxpw\r\n    (Time_Varying_Model_2022a_B.Clock,\r\n     Time_Varying_Model_2022a_P.OpenRocketI_R_bp01Data,\r\n     Time_Varying_Model_2022a_P.OpenRocketI_R_tableData, 222U);\r\n\r\n  /* Lookup_n-D: '<Root>/OpenRocket X_CG' incorporates:\r\n   *  Clock: '<Root>/Clock'\r\n   */\r\n  Time_Varying_Model_2022a_B.OpenRocketX_CG = look1_binlxpw\r\n    (Time_Varying_Model_2022a_B.Clock,\r\n     Time_Varying_Model_2022a_P.OpenRocketX_CG_bp01Data,\r\n     Time_Varying_Model_2022a_P.OpenRocketX_CG_tableData, 222U);\r\n\r\n  /* Lookup_n-D: '<Root>/OpenRocket mDot' incorporates:\r\n   *  Clock: '<Root>/Clock'\r\n   */\r\n  Time_Varying_Model_2022a_B.OpenRocketmDot = look1_binlxpw\r\n    (Time_Varying_Model_2022a_B.Clock,\r\n     Time_Varying_Model_2022a_P.OpenRocketmDot_bp01Data,\r\n     Time_Varying_Model_2022a_P.OpenRocketmDot_tableData, 222U);\r\n\r\n  /* Sum: '<Root>/Sum of Elements1' */\r\n  Time_Varying_Model_2022a_B.SumofElements1_g =\r\n    (Time_Varying_Model_2022a_B.CNa_fins + Time_Varying_Model_2022a_B.CNa_body)\r\n    + Time_Varying_Model_2022a_B.CNa_nose;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n    /* UnitConversion: '<S116>/Unit Conversion' incorporates:\r\n     *  Constant: '<S110>/Wingspan'\r\n     */\r\n    /* Unit Conversion - from: m to: ft\r\n       Expression: output = (3.28084*input) + (0) */\r\n    Time_Varying_Model_2022a_B.UnitConversion_n = 3.280839895013123 *\r\n      Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_j;\r\n\r\n    /* Outputs for Enabled SubSystem: '<S113>/Hpgw' incorporates:\r\n     *  EnablePort: '<S124>/Enable'\r\n     */\r\n    if (rtsiIsModeUpdateTimeStep(&Time_Varying_Model_2022a_M->solverInfo)) {\r\n      /* Constant: '<S113>/Constant1' */\r\n      if (Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_c > 0.0) {\r\n        if (!Time_Varying_Model_2022a_DW.Hpgw_MODE) {\r\n          (void) memset(&(Time_Varying_Model_2022a_XDis.pgw_p_CSTATE), 0,\r\n                        2*sizeof(boolean_T));\r\n\r\n          /* InitializeConditions for Integrator: '<S124>/pgw_p' */\r\n          Time_Varying_Model_2022a_X.pgw_p_CSTATE[0] =\r\n            Time_Varying_Model_2022a_P.pgw_p_IC;\r\n          Time_Varying_Model_2022a_X.pgw_p_CSTATE[1] =\r\n            Time_Varying_Model_2022a_P.pgw_p_IC;\r\n          Time_Varying_Model_2022a_DW.Hpgw_MODE = true;\r\n        }\r\n      } else {\r\n        /* Outputs for Enabled SubSystem: '<S114>/Hugw(s)' incorporates:\r\n         *  EnablePort: '<S127>/Enable'\r\n         */\r\n        ang_cos = rtmGetTStart(Time_Varying_Model_2022a_M);\r\n\r\n        /* End of Outputs for SubSystem: '<S114>/Hugw(s)' */\r\n        if ((((Time_Varying_Model_2022a_M->Timing.clockTick1+\r\n               Time_Varying_Model_2022a_M->Timing.clockTickH1* 4294967296.0)) *\r\n             0.01) == ang_cos) {\r\n          (void) memset(&(Time_Varying_Model_2022a_XDis.pgw_p_CSTATE), 1,\r\n                        2*sizeof(boolean_T));\r\n        }\r\n\r\n        if (Time_Varying_Model_2022a_DW.Hpgw_MODE) {\r\n          (void) memset(&(Time_Varying_Model_2022a_XDis.pgw_p_CSTATE), 1,\r\n                        2*sizeof(boolean_T));\r\n\r\n          /* Disable for Product: '<S124>/sigma_w' incorporates:\r\n           *  Outport: '<S124>/pgw'\r\n           */\r\n          Time_Varying_Model_2022a_B.sigma_w[0] =\r\n            Time_Varying_Model_2022a_P.pgw_Y0;\r\n          Time_Varying_Model_2022a_B.sigma_w[1] =\r\n            Time_Varying_Model_2022a_P.pgw_Y0;\r\n          Time_Varying_Model_2022a_DW.Hpgw_MODE = false;\r\n        }\r\n      }\r\n\r\n      /* End of Constant: '<S113>/Constant1' */\r\n    }\r\n\r\n    /* End of Outputs for SubSystem: '<S113>/Hpgw' */\r\n  }\r\n\r\n  /* Outputs for Enabled SubSystem: '<S113>/Hpgw' incorporates:\r\n   *  EnablePort: '<S124>/Enable'\r\n   */\r\n  if (Time_Varying_Model_2022a_DW.Hpgw_MODE) {\r\n    /* Math: '<S124>/L^1//3' incorporates:\r\n     *  Constant: '<S124>/Constant1'\r\n     */\r\n    ang_cos = Time_Varying_Model_2022a_B.Lw[0];\r\n    if ((ang_cos < 0.0) && (Time_Varying_Model_2022a_P.Constant1_Value > floor\r\n                            (Time_Varying_Model_2022a_P.Constant1_Value))) {\r\n      ang_cos = -rt_powd_snf(-ang_cos,\r\n        Time_Varying_Model_2022a_P.Constant1_Value);\r\n    } else {\r\n      ang_cos = rt_powd_snf(ang_cos, Time_Varying_Model_2022a_P.Constant1_Value);\r\n    }\r\n\r\n    /* Math: '<S124>/L^1//3' */\r\n    Time_Varying_Model_2022a_B.L13[0] = ang_cos;\r\n\r\n    /* Math: '<S124>/L^1//3' incorporates:\r\n     *  Constant: '<S124>/Constant1'\r\n     */\r\n    ang_cos = Time_Varying_Model_2022a_B.Lw[1];\r\n    if ((ang_cos < 0.0) && (Time_Varying_Model_2022a_P.Constant1_Value > floor\r\n                            (Time_Varying_Model_2022a_P.Constant1_Value))) {\r\n      ang_cos = -rt_powd_snf(-ang_cos,\r\n        Time_Varying_Model_2022a_P.Constant1_Value);\r\n    } else {\r\n      ang_cos = rt_powd_snf(ang_cos, Time_Varying_Model_2022a_P.Constant1_Value);\r\n    }\r\n\r\n    /* Math: '<S124>/L^1//3' */\r\n    Time_Varying_Model_2022a_B.L13[1] = ang_cos;\r\n    if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n        Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n      /* Product: '<S124>/w4' incorporates:\r\n       *  Constant: '<S124>/Constant3'\r\n       */\r\n      Time_Varying_Model_2022a_B.w4 = Time_Varying_Model_2022a_P.Constant3_Value\r\n        / Time_Varying_Model_2022a_B.UnitConversion_n;\r\n\r\n      /* Math: '<S124>/u^1//6' incorporates:\r\n       *  Constant: '<S124>/Constant2'\r\n       */\r\n      ang_sin = Time_Varying_Model_2022a_B.w4;\r\n      ang_cos = Time_Varying_Model_2022a_P.Constant2_Value;\r\n      if ((ang_sin < 0.0) && (ang_cos > floor(ang_cos))) {\r\n        /* Math: '<S124>/u^1//6' */\r\n        Time_Varying_Model_2022a_B.u16 = -rt_powd_snf(-ang_sin, ang_cos);\r\n      } else {\r\n        /* Math: '<S124>/u^1//6' */\r\n        Time_Varying_Model_2022a_B.u16 = rt_powd_snf(ang_sin, ang_cos);\r\n      }\r\n\r\n      /* End of Math: '<S124>/u^1//6' */\r\n    }\r\n\r\n    /* Fcn: '<S124>/sqrt(0.8//V)' */\r\n    ang_sin = 0.8 / Time_Varying_Model_2022a_B.UnitConversion_e;\r\n    if (ang_sin < 0.0) {\r\n      ang_sin = -sqrt(-ang_sin);\r\n    } else {\r\n      ang_sin = sqrt(ang_sin);\r\n    }\r\n\r\n    /* Fcn: '<S124>/sqrt(0.8//V)' */\r\n    Time_Varying_Model_2022a_B.sqrt08V = ang_sin;\r\n\r\n    /* Product: '<S124>/w3' */\r\n    Time_Varying_Model_2022a_B.w3 = Time_Varying_Model_2022a_B.UnitConversion_e *\r\n      Time_Varying_Model_2022a_B.w4;\r\n\r\n    /* Product: '<S124>/w1' */\r\n    ang_cos = Time_Varying_Model_2022a_B.sqrt08V /\r\n      Time_Varying_Model_2022a_B.L13[0];\r\n    Time_Varying_Model_2022a_B.w1_k[0] = ang_cos;\r\n\r\n    /* Product: '<S124>/w2' */\r\n    ang_cos *= Time_Varying_Model_2022a_B.u16;\r\n    Time_Varying_Model_2022a_B.w2[0] = ang_cos;\r\n\r\n    /* Product: '<S124>/Lug//V1' */\r\n    ang_cos *= Time_Varying_Model_2022a_B.Product_p[3];\r\n    Time_Varying_Model_2022a_B.LugV1_mq[0] = ang_cos;\r\n\r\n    /* Integrator: '<S124>/pgw_p' */\r\n    ang_sin = Time_Varying_Model_2022a_X.pgw_p_CSTATE[0];\r\n    Time_Varying_Model_2022a_B.pgw_p[0] = ang_sin;\r\n\r\n    /* Sum: '<S124>/Sum' */\r\n    ang_cos -= ang_sin;\r\n    Time_Varying_Model_2022a_B.Sum_b1[0] = ang_cos;\r\n\r\n    /* Product: '<S124>/w' */\r\n    Time_Varying_Model_2022a_B.w_m[0] = Time_Varying_Model_2022a_B.w3 * ang_cos;\r\n\r\n    /* Product: '<S124>/w1' */\r\n    ang_cos = Time_Varying_Model_2022a_B.sqrt08V /\r\n      Time_Varying_Model_2022a_B.L13[1];\r\n    Time_Varying_Model_2022a_B.w1_k[1] = ang_cos;\r\n\r\n    /* Product: '<S124>/w2' */\r\n    ang_cos *= Time_Varying_Model_2022a_B.u16;\r\n    Time_Varying_Model_2022a_B.w2[1] = ang_cos;\r\n\r\n    /* Product: '<S124>/Lug//V1' */\r\n    ang_cos *= Time_Varying_Model_2022a_B.Product_p[3];\r\n    Time_Varying_Model_2022a_B.LugV1_mq[1] = ang_cos;\r\n\r\n    /* Integrator: '<S124>/pgw_p' */\r\n    ang_sin = Time_Varying_Model_2022a_X.pgw_p_CSTATE[1];\r\n    Time_Varying_Model_2022a_B.pgw_p[1] = ang_sin;\r\n\r\n    /* Sum: '<S124>/Sum' */\r\n    ang_cos -= ang_sin;\r\n    Time_Varying_Model_2022a_B.Sum_b1[1] = ang_cos;\r\n\r\n    /* Product: '<S124>/w' */\r\n    Time_Varying_Model_2022a_B.w_m[1] = Time_Varying_Model_2022a_B.w3 * ang_cos;\r\n\r\n    /* Product: '<S124>/sigma_w' */\r\n    Time_Varying_Model_2022a_B.sigma_w[0] = Time_Varying_Model_2022a_B.sigma_wg *\r\n      Time_Varying_Model_2022a_B.pgw_p[0];\r\n    Time_Varying_Model_2022a_B.sigma_w[1] =\r\n      Time_Varying_Model_2022a_B.MediumHighAltitudeIntensity *\r\n      Time_Varying_Model_2022a_B.pgw_p[1];\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S113>/Hpgw' */\r\n\r\n  /* Outputs for Enabled SubSystem: '<S113>/Hqgw' incorporates:\r\n   *  EnablePort: '<S125>/Enable'\r\n   */\r\n  if ((rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n       Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) &&\r\n      rtsiIsModeUpdateTimeStep(&Time_Varying_Model_2022a_M->solverInfo)) {\r\n    /* Constant: '<S113>/Constant2' */\r\n    if (Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_c > 0.0) {\r\n      if (!Time_Varying_Model_2022a_DW.Hqgw_MODE) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.qgw_p_CSTATE), 0,\r\n                      2*sizeof(boolean_T));\r\n\r\n        /* InitializeConditions for Integrator: '<S125>/qgw_p' */\r\n        Time_Varying_Model_2022a_X.qgw_p_CSTATE[0] =\r\n          Time_Varying_Model_2022a_P.qgw_p_IC;\r\n        Time_Varying_Model_2022a_X.qgw_p_CSTATE[1] =\r\n          Time_Varying_Model_2022a_P.qgw_p_IC;\r\n        Time_Varying_Model_2022a_DW.Hqgw_MODE = true;\r\n      }\r\n    } else {\r\n      /* Outputs for Enabled SubSystem: '<S114>/Hugw(s)' incorporates:\r\n       *  EnablePort: '<S127>/Enable'\r\n       */\r\n      ang_cos = rtmGetTStart(Time_Varying_Model_2022a_M);\r\n\r\n      /* End of Outputs for SubSystem: '<S114>/Hugw(s)' */\r\n      if ((((Time_Varying_Model_2022a_M->Timing.clockTick1+\r\n             Time_Varying_Model_2022a_M->Timing.clockTickH1* 4294967296.0)) *\r\n           0.01) == ang_cos) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.qgw_p_CSTATE), 1,\r\n                      2*sizeof(boolean_T));\r\n      }\r\n\r\n      if (Time_Varying_Model_2022a_DW.Hqgw_MODE) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.qgw_p_CSTATE), 1,\r\n                      2*sizeof(boolean_T));\r\n\r\n        /* Disable for Product: '<S125>/w' incorporates:\r\n         *  Outport: '<S125>/qgw'\r\n         */\r\n        Time_Varying_Model_2022a_B.w_gw[0] = Time_Varying_Model_2022a_P.qgw_Y0;\r\n        Time_Varying_Model_2022a_B.w_gw[1] = Time_Varying_Model_2022a_P.qgw_Y0;\r\n        Time_Varying_Model_2022a_DW.Hqgw_MODE = false;\r\n      }\r\n    }\r\n\r\n    /* End of Constant: '<S113>/Constant2' */\r\n  }\r\n\r\n  if (Time_Varying_Model_2022a_DW.Hqgw_MODE) {\r\n    /* Gain: '<S125>/pi//4' */\r\n    Time_Varying_Model_2022a_B.pi4 = Time_Varying_Model_2022a_P.pi4_Gain *\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n\r\n    /* Product: '<S125>/wg//V' */\r\n    ang_cos = Time_Varying_Model_2022a_B.LwgV1[0] /\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n    Time_Varying_Model_2022a_B.wgV[0] = ang_cos;\r\n\r\n    /* Integrator: '<S125>/qgw_p' */\r\n    ang_sin = Time_Varying_Model_2022a_X.qgw_p_CSTATE[0];\r\n    Time_Varying_Model_2022a_B.qgw_p[0] = ang_sin;\r\n\r\n    /* Sum: '<S125>/Sum' */\r\n    ang_cos -= ang_sin;\r\n    Time_Varying_Model_2022a_B.Sum_m[0] = ang_cos;\r\n\r\n    /* Product: '<S125>/w' */\r\n    Time_Varying_Model_2022a_B.w_gw[0] = Time_Varying_Model_2022a_B.pi4 /\r\n      Time_Varying_Model_2022a_B.UnitConversion_n * ang_cos;\r\n\r\n    /* Product: '<S125>/wg//V' */\r\n    ang_cos = Time_Varying_Model_2022a_B.LwgV1[1] /\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n    Time_Varying_Model_2022a_B.wgV[1] = ang_cos;\r\n\r\n    /* Integrator: '<S125>/qgw_p' */\r\n    ang_sin = Time_Varying_Model_2022a_X.qgw_p_CSTATE[1];\r\n    Time_Varying_Model_2022a_B.qgw_p[1] = ang_sin;\r\n\r\n    /* Sum: '<S125>/Sum' */\r\n    ang_cos -= ang_sin;\r\n    Time_Varying_Model_2022a_B.Sum_m[1] = ang_cos;\r\n\r\n    /* Product: '<S125>/w' */\r\n    Time_Varying_Model_2022a_B.w_gw[1] = Time_Varying_Model_2022a_B.pi4 /\r\n      Time_Varying_Model_2022a_B.UnitConversion_n * ang_cos;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S113>/Hqgw' */\r\n\r\n  /* Outputs for Enabled SubSystem: '<S113>/Hrgw' incorporates:\r\n   *  EnablePort: '<S126>/Enable'\r\n   */\r\n  if ((rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n       Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) &&\r\n      rtsiIsModeUpdateTimeStep(&Time_Varying_Model_2022a_M->solverInfo)) {\r\n    /* Constant: '<S113>/Constant3' */\r\n    if (Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_c > 0.0) {\r\n      if (!Time_Varying_Model_2022a_DW.Hrgw_MODE) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.rgw_p_CSTATE), 0,\r\n                      2*sizeof(boolean_T));\r\n\r\n        /* InitializeConditions for Integrator: '<S126>/rgw_p' */\r\n        Time_Varying_Model_2022a_X.rgw_p_CSTATE[0] =\r\n          Time_Varying_Model_2022a_P.rgw_p_IC;\r\n        Time_Varying_Model_2022a_X.rgw_p_CSTATE[1] =\r\n          Time_Varying_Model_2022a_P.rgw_p_IC;\r\n        Time_Varying_Model_2022a_DW.Hrgw_MODE = true;\r\n      }\r\n    } else {\r\n      /* Outputs for Enabled SubSystem: '<S114>/Hugw(s)' incorporates:\r\n       *  EnablePort: '<S127>/Enable'\r\n       */\r\n      ang_cos = rtmGetTStart(Time_Varying_Model_2022a_M);\r\n\r\n      /* End of Outputs for SubSystem: '<S114>/Hugw(s)' */\r\n      if ((((Time_Varying_Model_2022a_M->Timing.clockTick1+\r\n             Time_Varying_Model_2022a_M->Timing.clockTickH1* 4294967296.0)) *\r\n           0.01) == ang_cos) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.rgw_p_CSTATE), 1,\r\n                      2*sizeof(boolean_T));\r\n      }\r\n\r\n      if (Time_Varying_Model_2022a_DW.Hrgw_MODE) {\r\n        (void) memset(&(Time_Varying_Model_2022a_XDis.rgw_p_CSTATE), 1,\r\n                      2*sizeof(boolean_T));\r\n\r\n        /* Disable for Product: '<S126>/w' incorporates:\r\n         *  Outport: '<S126>/rgw'\r\n         */\r\n        Time_Varying_Model_2022a_B.w_g[0] = Time_Varying_Model_2022a_P.rgw_Y0;\r\n        Time_Varying_Model_2022a_B.w_g[1] = Time_Varying_Model_2022a_P.rgw_Y0;\r\n        Time_Varying_Model_2022a_DW.Hrgw_MODE = false;\r\n      }\r\n    }\r\n\r\n    /* End of Constant: '<S113>/Constant3' */\r\n  }\r\n\r\n  if (Time_Varying_Model_2022a_DW.Hrgw_MODE) {\r\n    /* Gain: '<S126>/pi//3' */\r\n    Time_Varying_Model_2022a_B.pi3 = Time_Varying_Model_2022a_P.pi3_Gain *\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n\r\n    /* Product: '<S126>/vg//V' */\r\n    ang_cos = Time_Varying_Model_2022a_B.w1[0] /\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n    Time_Varying_Model_2022a_B.vgV[0] = ang_cos;\r\n\r\n    /* Integrator: '<S126>/rgw_p' */\r\n    ang_sin = Time_Varying_Model_2022a_X.rgw_p_CSTATE[0];\r\n    Time_Varying_Model_2022a_B.rgw_p[0] = ang_sin;\r\n\r\n    /* Sum: '<S126>/Sum' */\r\n    ang_cos -= ang_sin;\r\n    Time_Varying_Model_2022a_B.Sum_bn[0] = ang_cos;\r\n\r\n    /* Product: '<S126>/w' */\r\n    Time_Varying_Model_2022a_B.w_g[0] = Time_Varying_Model_2022a_B.pi3 /\r\n      Time_Varying_Model_2022a_B.UnitConversion_n * ang_cos;\r\n\r\n    /* Product: '<S126>/vg//V' */\r\n    ang_cos = Time_Varying_Model_2022a_B.w1[1] /\r\n      Time_Varying_Model_2022a_B.UnitConversion_e;\r\n    Time_Varying_Model_2022a_B.vgV[1] = ang_cos;\r\n\r\n    /* Integrator: '<S126>/rgw_p' */\r\n    ang_sin = Time_Varying_Model_2022a_X.rgw_p_CSTATE[1];\r\n    Time_Varying_Model_2022a_B.rgw_p[1] = ang_sin;\r\n\r\n    /* Sum: '<S126>/Sum' */\r\n    ang_cos -= ang_sin;\r\n    Time_Varying_Model_2022a_B.Sum_bn[1] = ang_cos;\r\n\r\n    /* Product: '<S126>/w' */\r\n    Time_Varying_Model_2022a_B.w_g[1] = Time_Varying_Model_2022a_B.pi3 /\r\n      Time_Varying_Model_2022a_B.UnitConversion_n * ang_cos;\r\n  }\r\n\r\n  /* End of Outputs for SubSystem: '<S113>/Hrgw' */\r\n\r\n  /* If: '<S118>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' incorporates:\r\n   *  Merge: '<S135>/Merge'\r\n   *  Product: '<S138>/Product'\r\n   */\r\n  if (rtsiIsModeUpdateTimeStep(&Time_Varying_Model_2022a_M->solverInfo)) {\r\n    if (Time_Varying_Model_2022a_B.UnitConversion <= 1000.0) {\r\n      rtAction = 0;\r\n    } else if (Time_Varying_Model_2022a_B.UnitConversion >= 2000.0) {\r\n      rtAction = 1;\r\n    } else {\r\n      rtAction = 2;\r\n    }\r\n\r\n    Time_Varying_Model_2022a_DW.ifHeightMaxlowaltitudeelseifH_k = rtAction;\r\n  } else {\r\n    rtAction = Time_Varying_Model_2022a_DW.ifHeightMaxlowaltitudeelseifH_k;\r\n  }\r\n\r\n  switch (rtAction) {\r\n   case 0:\r\n    /* Outputs for IfAction SubSystem: '<S118>/Low altitude  rates' incorporates:\r\n     *  ActionPort: '<S133>/Action Port'\r\n     */\r\n    /* SignalConversion generated from: '<S138>/Vector Concatenate' incorporates:\r\n     *  Concatenate: '<S138>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate_m[2] =\r\n      Time_Varying_Model_2022a_B.w_g[0];\r\n\r\n    /* Trigonometry: '<S139>/Trigonometric Function1' */\r\n    ang_sin = Time_Varying_Model_2022a_B.UnitConversion_gl;\r\n    ang_cos = sin(ang_sin);\r\n    ang_sin = cos(ang_sin);\r\n\r\n    /* Trigonometry: '<S139>/Trigonometric Function1' */\r\n    Time_Varying_Model_2022a_B.TrigonometricFunction1_o1 = ang_cos;\r\n\r\n    /* Trigonometry: '<S139>/Trigonometric Function1' */\r\n    Time_Varying_Model_2022a_B.TrigonometricFunction1_o2 = ang_sin;\r\n\r\n    /* Product: '<S139>/Product2' */\r\n    Time_Varying_Model_2022a_B.Product2_dy[0] =\r\n      Time_Varying_Model_2022a_B.sigma_w[0] *\r\n      Time_Varying_Model_2022a_B.TrigonometricFunction1_o2;\r\n    Time_Varying_Model_2022a_B.Product2_dy[1] = Time_Varying_Model_2022a_B.w_gw\r\n      [0] * Time_Varying_Model_2022a_B.TrigonometricFunction1_o2;\r\n\r\n    /* Product: '<S139>/Product1' */\r\n    Time_Varying_Model_2022a_B.Product1_if[0] =\r\n      Time_Varying_Model_2022a_B.TrigonometricFunction1_o1 *\r\n      Time_Varying_Model_2022a_B.sigma_w[0];\r\n    Time_Varying_Model_2022a_B.Product1_if[1] =\r\n      Time_Varying_Model_2022a_B.TrigonometricFunction1_o1 *\r\n      Time_Varying_Model_2022a_B.w_gw[0];\r\n\r\n    /* Sum: '<S139>/Sum' incorporates:\r\n     *  Concatenate: '<S138>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate_m[0] =\r\n      Time_Varying_Model_2022a_B.Product2_dy[0] -\r\n      Time_Varying_Model_2022a_B.Product1_if[1];\r\n\r\n    /* Sum: '<S139>/Sum1' incorporates:\r\n     *  Concatenate: '<S138>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate_m[1] =\r\n      Time_Varying_Model_2022a_B.Product1_if[0] +\r\n      Time_Varying_Model_2022a_B.Product2_dy[1];\r\n\r\n    /* Product: '<S138>/Product' incorporates:\r\n     *  Concatenate: '<S138>/Vector Concatenate'\r\n     */\r\n    memcpy(&rotmZYX[0], &Time_Varying_Model_2022a_B.DCM[0], 9U * sizeof(real_T));\r\n    ang_sin = Time_Varying_Model_2022a_B.VectorConcatenate_m[0];\r\n    st_idx_1 = Time_Varying_Model_2022a_B.VectorConcatenate_m[1];\r\n    ang_cos = Time_Varying_Model_2022a_B.VectorConcatenate_m[2];\r\n\r\n    /* End of Outputs for SubSystem: '<S118>/Low altitude  rates' */\r\n    for (i = 0; i <= 0; i += 2) {\r\n      /* Outputs for IfAction SubSystem: '<S118>/Low altitude  rates' incorporates:\r\n       *  ActionPort: '<S133>/Action Port'\r\n       */\r\n      tmp_0 = _mm_loadu_pd(&rotmZYX[i]);\r\n      tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(ang_sin));\r\n      tmp_1 = _mm_loadu_pd(&rotmZYX[i + 3]);\r\n      tmp_1 = _mm_mul_pd(tmp_1, _mm_set1_pd(st_idx_1));\r\n\r\n      /* End of Outputs for SubSystem: '<S118>/Low altitude  rates' */\r\n      tmp_0 = _mm_add_pd(tmp_1, tmp_0);\r\n\r\n      /* Outputs for IfAction SubSystem: '<S118>/Low altitude  rates' incorporates:\r\n       *  ActionPort: '<S133>/Action Port'\r\n       */\r\n      tmp_1 = _mm_loadu_pd(&rotmZYX[i + 6]);\r\n      tmp_1 = _mm_mul_pd(tmp_1, _mm_set1_pd(ang_cos));\r\n\r\n      /* End of Outputs for SubSystem: '<S118>/Low altitude  rates' */\r\n      tmp_0 = _mm_add_pd(tmp_1, tmp_0);\r\n\r\n      /* Outputs for IfAction SubSystem: '<S118>/Low altitude  rates' incorporates:\r\n       *  ActionPort: '<S133>/Action Port'\r\n       */\r\n      _mm_storeu_pd(&Time_Varying_Model_2022a_B.Product_dt[i], tmp_0);\r\n      _mm_storeu_pd(&Time_Varying_Model_2022a_B.Merge_n[i], tmp_0);\r\n\r\n      /* End of Outputs for SubSystem: '<S118>/Low altitude  rates' */\r\n    }\r\n\r\n    /* Outputs for IfAction SubSystem: '<S118>/Low altitude  rates' incorporates:\r\n     *  ActionPort: '<S133>/Action Port'\r\n     */\r\n    for (i = 2; i < 3; i++) {\r\n      /* Product: '<S138>/Product' */\r\n      ct_idx_0 = rotmZYX[i] * ang_sin;\r\n      ct_idx_0 += rotmZYX[i + 3] * st_idx_1;\r\n      ct_idx_0 += rotmZYX[i + 6] * ang_cos;\r\n      Time_Varying_Model_2022a_B.Product_dt[i] = ct_idx_0;\r\n\r\n      /* Merge: '<S135>/Merge' incorporates:\r\n       *  Product: '<S138>/Product'\r\n       *  Reshape: '<S138>/Reshape1'\r\n       */\r\n      Time_Varying_Model_2022a_B.Merge_n[i] = ct_idx_0;\r\n    }\r\n\r\n    /* End of Outputs for SubSystem: '<S118>/Low altitude  rates' */\r\n    break;\r\n\r\n   case 1:\r\n    /* Outputs for IfAction SubSystem: '<S118>/Medium//High  altitude rates' incorporates:\r\n     *  ActionPort: '<S134>/Action Port'\r\n     */\r\n    /* Merge: '<S135>/Merge' incorporates:\r\n     *  Gain: '<S134>/Gain'\r\n     */\r\n    Time_Varying_Model_2022a_B.Merge_n[0] = Time_Varying_Model_2022a_P.Gain_Gain\r\n      * Time_Varying_Model_2022a_B.sigma_w[1];\r\n    Time_Varying_Model_2022a_B.Merge_n[1] = Time_Varying_Model_2022a_P.Gain_Gain\r\n      * Time_Varying_Model_2022a_B.w_gw[1];\r\n    Time_Varying_Model_2022a_B.Merge_n[2] = Time_Varying_Model_2022a_P.Gain_Gain\r\n      * Time_Varying_Model_2022a_B.w_g[1];\r\n\r\n    /* End of Outputs for SubSystem: '<S118>/Medium//High  altitude rates' */\r\n    break;\r\n\r\n   default:\r\n    /* Outputs for IfAction SubSystem: '<S118>/Interpolate  rates' incorporates:\r\n     *  ActionPort: '<S132>/Action Port'\r\n     */\r\n    /* Trigonometry: '<S137>/Trigonometric Function' */\r\n    ang_sin = Time_Varying_Model_2022a_B.UnitConversion_gl;\r\n    ang_cos = sin(ang_sin);\r\n    ang_sin = cos(ang_sin);\r\n\r\n    /* Trigonometry: '<S137>/Trigonometric Function' */\r\n    Time_Varying_Model_2022a_B.TrigonometricFunction_o1_g = ang_cos;\r\n\r\n    /* Trigonometry: '<S137>/Trigonometric Function' */\r\n    Time_Varying_Model_2022a_B.TrigonometricFunction_o2_m = ang_sin;\r\n\r\n    /* Product: '<S137>/Product2' */\r\n    Time_Varying_Model_2022a_B.Product2_k[0] =\r\n      Time_Varying_Model_2022a_B.sigma_w[0] *\r\n      Time_Varying_Model_2022a_B.TrigonometricFunction_o2_m;\r\n    Time_Varying_Model_2022a_B.Product2_k[1] = Time_Varying_Model_2022a_B.w_gw[0]\r\n      * Time_Varying_Model_2022a_B.TrigonometricFunction_o2_m;\r\n\r\n    /* Product: '<S137>/Product1' */\r\n    Time_Varying_Model_2022a_B.Product1_dm[0] =\r\n      Time_Varying_Model_2022a_B.TrigonometricFunction_o1_g *\r\n      Time_Varying_Model_2022a_B.sigma_w[0];\r\n    Time_Varying_Model_2022a_B.Product1_dm[1] =\r\n      Time_Varying_Model_2022a_B.TrigonometricFunction_o1_g *\r\n      Time_Varying_Model_2022a_B.w_gw[0];\r\n\r\n    /* Sum: '<S137>/Sum' incorporates:\r\n     *  Concatenate: '<S136>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate_i[0] =\r\n      Time_Varying_Model_2022a_B.Product2_k[0] -\r\n      Time_Varying_Model_2022a_B.Product1_dm[1];\r\n\r\n    /* Sum: '<S137>/Sum1' incorporates:\r\n     *  Concatenate: '<S136>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate_i[1] =\r\n      Time_Varying_Model_2022a_B.Product1_dm[0] +\r\n      Time_Varying_Model_2022a_B.Product2_k[1];\r\n\r\n    /* SignalConversion generated from: '<S136>/Vector Concatenate' incorporates:\r\n     *  Concatenate: '<S136>/Vector Concatenate'\r\n     */\r\n    Time_Varying_Model_2022a_B.VectorConcatenate_i[2] =\r\n      Time_Varying_Model_2022a_B.w_g[0];\r\n\r\n    /* Product: '<S136>/Product' incorporates:\r\n     *  Concatenate: '<S136>/Vector Concatenate'\r\n     */\r\n    memcpy(&rotmZYX[0], &Time_Varying_Model_2022a_B.DCM[0], 9U * sizeof(real_T));\r\n    ang_sin = Time_Varying_Model_2022a_B.VectorConcatenate_i[0];\r\n    st_idx_1 = Time_Varying_Model_2022a_B.VectorConcatenate_i[1];\r\n    ang_cos = Time_Varying_Model_2022a_B.VectorConcatenate_i[2];\r\n\r\n    /* End of Outputs for SubSystem: '<S118>/Interpolate  rates' */\r\n    for (i_0 = 0; i_0 <= 0; i_0 += 2) {\r\n      /* Outputs for IfAction SubSystem: '<S118>/Interpolate  rates' incorporates:\r\n       *  ActionPort: '<S132>/Action Port'\r\n       */\r\n      tmp_0 = _mm_loadu_pd(&rotmZYX[i_0]);\r\n      tmp_0 = _mm_mul_pd(tmp_0, _mm_set1_pd(ang_sin));\r\n      tmp_1 = _mm_loadu_pd(&rotmZYX[i_0 + 3]);\r\n      tmp_1 = _mm_mul_pd(tmp_1, _mm_set1_pd(st_idx_1));\r\n\r\n      /* End of Outputs for SubSystem: '<S118>/Interpolate  rates' */\r\n      tmp_0 = _mm_add_pd(tmp_1, tmp_0);\r\n\r\n      /* Outputs for IfAction SubSystem: '<S118>/Interpolate  rates' incorporates:\r\n       *  ActionPort: '<S132>/Action Port'\r\n       */\r\n      tmp_1 = _mm_loadu_pd(&rotmZYX[i_0 + 6]);\r\n      tmp_1 = _mm_mul_pd(tmp_1, _mm_set1_pd(ang_cos));\r\n\r\n      /* End of Outputs for SubSystem: '<S118>/Interpolate  rates' */\r\n      tmp_0 = _mm_add_pd(tmp_1, tmp_0);\r\n\r\n      /* Outputs for IfAction SubSystem: '<S118>/Interpolate  rates' incorporates:\r\n       *  ActionPort: '<S132>/Action Port'\r\n       */\r\n      _mm_storeu_pd(&Time_Varying_Model_2022a_B.Product_g[i_0], tmp_0);\r\n\r\n      /* End of Outputs for SubSystem: '<S118>/Interpolate  rates' */\r\n    }\r\n\r\n    /* Outputs for IfAction SubSystem: '<S118>/Interpolate  rates' incorporates:\r\n     *  ActionPort: '<S132>/Action Port'\r\n     */\r\n    for (i_0 = 2; i_0 < 3; i_0++) {\r\n      /* Product: '<S136>/Product' */\r\n      ct_idx_0 = rotmZYX[i_0] * ang_sin;\r\n      ct_idx_0 += rotmZYX[i_0 + 3] * st_idx_1;\r\n      ct_idx_0 += rotmZYX[i_0 + 6] * ang_cos;\r\n      Time_Varying_Model_2022a_B.Product_g[i_0] = ct_idx_0;\r\n    }\r\n\r\n    /* Sum: '<S132>/Sum2' incorporates:\r\n     *  Product: '<S136>/Product'\r\n     */\r\n    Time_Varying_Model_2022a_B.Sum2_f[0] = Time_Varying_Model_2022a_B.sigma_w[1]\r\n      - Time_Varying_Model_2022a_B.Product_g[0];\r\n    Time_Varying_Model_2022a_B.Sum2_f[1] = Time_Varying_Model_2022a_B.w_gw[1] -\r\n      Time_Varying_Model_2022a_B.Product_g[1];\r\n    Time_Varying_Model_2022a_B.Sum2_f[2] = Time_Varying_Model_2022a_B.w_g[1] -\r\n      Time_Varying_Model_2022a_B.Product_g[2];\r\n\r\n    /* Sum: '<S132>/Sum1' incorporates:\r\n     *  Constant: '<S132>/max_height_low'\r\n     */\r\n    Time_Varying_Model_2022a_B.Sum1_p =\r\n      Time_Varying_Model_2022a_B.UnitConversion -\r\n      Time_Varying_Model_2022a_P.max_height_low_Value;\r\n\r\n    /* Sum: '<S132>/Sum' incorporates:\r\n     *  Constant: '<S132>/max_height_low'\r\n     *  Constant: '<S132>/min_height_high'\r\n     */\r\n    Time_Varying_Model_2022a_B.Sum_d =\r\n      Time_Varying_Model_2022a_P.min_height_high_Value -\r\n      Time_Varying_Model_2022a_P.max_height_low_Value;\r\n\r\n    /* Product: '<S132>/Product1' */\r\n    ang_cos = Time_Varying_Model_2022a_B.Sum2_f[0] *\r\n      Time_Varying_Model_2022a_B.Sum1_p / Time_Varying_Model_2022a_B.Sum_d;\r\n\r\n    /* End of Outputs for SubSystem: '<S118>/Interpolate  rates' */\r\n    Time_Varying_Model_2022a_B.Product1_he[0] = ang_cos;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S118>/Interpolate  rates' incorporates:\r\n     *  ActionPort: '<S132>/Action Port'\r\n     */\r\n    /* Merge: '<S135>/Merge' incorporates:\r\n     *  Sum: '<S132>/Sum3'\r\n     */\r\n    Time_Varying_Model_2022a_B.Merge_n[0] =\r\n      Time_Varying_Model_2022a_B.Product_g[0] + ang_cos;\r\n\r\n    /* Product: '<S132>/Product1' */\r\n    ang_cos = Time_Varying_Model_2022a_B.Sum2_f[1] *\r\n      Time_Varying_Model_2022a_B.Sum1_p / Time_Varying_Model_2022a_B.Sum_d;\r\n\r\n    /* End of Outputs for SubSystem: '<S118>/Interpolate  rates' */\r\n    Time_Varying_Model_2022a_B.Product1_he[1] = ang_cos;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S118>/Interpolate  rates' incorporates:\r\n     *  ActionPort: '<S132>/Action Port'\r\n     */\r\n    /* Merge: '<S135>/Merge' incorporates:\r\n     *  Sum: '<S132>/Sum3'\r\n     */\r\n    Time_Varying_Model_2022a_B.Merge_n[1] =\r\n      Time_Varying_Model_2022a_B.Product_g[1] + ang_cos;\r\n\r\n    /* Product: '<S132>/Product1' */\r\n    ang_cos = Time_Varying_Model_2022a_B.Sum2_f[2] *\r\n      Time_Varying_Model_2022a_B.Sum1_p / Time_Varying_Model_2022a_B.Sum_d;\r\n\r\n    /* End of Outputs for SubSystem: '<S118>/Interpolate  rates' */\r\n    Time_Varying_Model_2022a_B.Product1_he[2] = ang_cos;\r\n\r\n    /* Outputs for IfAction SubSystem: '<S118>/Interpolate  rates' incorporates:\r\n     *  ActionPort: '<S132>/Action Port'\r\n     */\r\n    /* Merge: '<S135>/Merge' incorporates:\r\n     *  Sum: '<S132>/Sum3'\r\n     */\r\n    Time_Varying_Model_2022a_B.Merge_n[2] =\r\n      Time_Varying_Model_2022a_B.Product_g[2] + ang_cos;\r\n\r\n    /* End of Outputs for SubSystem: '<S118>/Interpolate  rates' */\r\n    break;\r\n  }\r\n\r\n  /* End of If: '<S118>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' */\r\n\r\n  /* Gain: '<S26>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_jr = Time_Varying_Model_2022a_P.Gain_Gain_c *\r\n    Time_Varying_Model_2022a_B.Integrator3;\r\n\r\n  /* Outport: '<Root>/psiOut' */\r\n  Time_Varying_Model_2022a_Y.yawAngle = Time_Varying_Model_2022a_B.Gain_jr;\r\n\r\n  /* Gain: '<S30>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_nq = Time_Varying_Model_2022a_P.Gain_Gain_n *\r\n    Time_Varying_Model_2022a_B.Integrator2;\r\n\r\n  /* Outport: '<Root>/pOut' */\r\n  Time_Varying_Model_2022a_Y.pOut = Time_Varying_Model_2022a_B.Gain_nq;\r\n\r\n  /* Gain: '<S31>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_o = Time_Varying_Model_2022a_P.Gain_Gain_f5 *\r\n    Time_Varying_Model_2022a_B.Integrator;\r\n\r\n  /* Outport: '<Root>/qOut' */\r\n  Time_Varying_Model_2022a_Y.qOut = Time_Varying_Model_2022a_B.Gain_o;\r\n\r\n  /* Gain: '<S32>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_bo = Time_Varying_Model_2022a_P.Gain_Gain_m *\r\n    Time_Varying_Model_2022a_B.Integrator1;\r\n\r\n  /* Outport: '<Root>/rOut' */\r\n  Time_Varying_Model_2022a_Y.rOut = Time_Varying_Model_2022a_B.Gain_bo;\r\n\r\n  /* Gain: '<S33>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_om = Time_Varying_Model_2022a_P.Gain_Gain_l *\r\n    Time_Varying_Model_2022a_B.Integrator5;\r\n\r\n  /* Outport: '<Root>/phiOut' */\r\n  Time_Varying_Model_2022a_Y.rollAngle = Time_Varying_Model_2022a_B.Gain_om;\r\n\r\n  /* Sum: '<S2>/Sum' */\r\n  Time_Varying_Model_2022a_B.Sum_j = Time_Varying_Model_2022a_B.Divide_c -\r\n    Time_Varying_Model_2022a_B.OpenRocketX_CG;\r\n\r\n  /* Product: '<S2>/Product' incorporates:\r\n   *  Constant: '<Root>/Constant6'\r\n   */\r\n  Time_Varying_Model_2022a_B.Product_o = Time_Varying_Model_2022a_B.Gain3 *\r\n    Time_Varying_Model_2022a_P.Constant6_Value *\r\n    Time_Varying_Model_2022a_B.SumofElements1_g *\r\n    Time_Varying_Model_2022a_B.Sum_j;\r\n\r\n  /* Sum: '<S3>/Sum' incorporates:\r\n   *  Constant: '<Root>/Constant22'\r\n   */\r\n  Time_Varying_Model_2022a_B.Sum_h = Time_Varying_Model_2022a_P.Constant22_Value\r\n    - Time_Varying_Model_2022a_B.OpenRocketX_CG;\r\n\r\n  /* Math: '<S3>/Square' */\r\n  Time_Varying_Model_2022a_B.Square_g = Time_Varying_Model_2022a_B.Sum_h *\r\n    Time_Varying_Model_2022a_B.Sum_h;\r\n\r\n  /* Product: '<S3>/Product' */\r\n  Time_Varying_Model_2022a_B.Product_m = Time_Varying_Model_2022a_B.CNa_nose *\r\n    Time_Varying_Model_2022a_B.Square_g;\r\n\r\n  /* Sum: '<S3>/Sum1' incorporates:\r\n   *  Constant: '<Root>/Constant23'\r\n   */\r\n  Time_Varying_Model_2022a_B.Sum1_o =\r\n    Time_Varying_Model_2022a_P.Constant23_Value -\r\n    Time_Varying_Model_2022a_B.OpenRocketX_CG;\r\n\r\n  /* Math: '<S3>/Square1' */\r\n  Time_Varying_Model_2022a_B.Square1 = Time_Varying_Model_2022a_B.Sum1_o *\r\n    Time_Varying_Model_2022a_B.Sum1_o;\r\n\r\n  /* Product: '<S3>/Product1' */\r\n  Time_Varying_Model_2022a_B.Product1_g = Time_Varying_Model_2022a_B.CNa_body *\r\n    Time_Varying_Model_2022a_B.Square1;\r\n\r\n  /* Sum: '<S3>/Sum2' incorporates:\r\n   *  Constant: '<Root>/Constant25'\r\n   */\r\n  Time_Varying_Model_2022a_B.Sum2_j =\r\n    Time_Varying_Model_2022a_P.Constant25_Value -\r\n    Time_Varying_Model_2022a_B.OpenRocketX_CG;\r\n\r\n  /* Math: '<S3>/Square2' */\r\n  Time_Varying_Model_2022a_B.Square2 = Time_Varying_Model_2022a_B.Sum2_j *\r\n    Time_Varying_Model_2022a_B.Sum2_j;\r\n\r\n  /* Product: '<S3>/Product2' */\r\n  Time_Varying_Model_2022a_B.Product2_d = Time_Varying_Model_2022a_B.CNa_can *\r\n    Time_Varying_Model_2022a_B.Square2;\r\n\r\n  /* Sum: '<S3>/Sum3' incorporates:\r\n   *  Constant: '<Root>/Constant24'\r\n   */\r\n  Time_Varying_Model_2022a_B.Sum3_m =\r\n    Time_Varying_Model_2022a_P.Constant24_Value -\r\n    Time_Varying_Model_2022a_B.OpenRocketX_CG;\r\n\r\n  /* Math: '<S3>/Square3' */\r\n  Time_Varying_Model_2022a_B.Square3 = Time_Varying_Model_2022a_B.Sum3_m *\r\n    Time_Varying_Model_2022a_B.Sum3_m;\r\n\r\n  /* Product: '<S3>/Product3' */\r\n  Time_Varying_Model_2022a_B.Product3_m = Time_Varying_Model_2022a_B.CNa_fins *\r\n    Time_Varying_Model_2022a_B.Square3;\r\n\r\n  /* Sum: '<S3>/Sum of Elements' */\r\n  Time_Varying_Model_2022a_B.SumofElements_g =\r\n    ((Time_Varying_Model_2022a_B.Product_m +\r\n      Time_Varying_Model_2022a_B.Product1_g) +\r\n     Time_Varying_Model_2022a_B.Product2_d) +\r\n    Time_Varying_Model_2022a_B.Product3_m;\r\n\r\n  /* Product: '<S3>/Product4' incorporates:\r\n   *  Constant: '<Root>/Constant6'\r\n   *  Constant: '<S3>/Constant'\r\n   */\r\n  Time_Varying_Model_2022a_B.Product4_a =\r\n    Time_Varying_Model_2022a_P.Constant_Value_fq *\r\n    Time_Varying_Model_2022a_B.rho *\r\n    Time_Varying_Model_2022a_B.OpenRocketVelocity *\r\n    Time_Varying_Model_2022a_P.Constant6_Value *\r\n    Time_Varying_Model_2022a_B.SumofElements_g;\r\n\r\n  /* Sum: '<S3>/Sum4' incorporates:\r\n   *  Constant: '<S3>/Constant1'\r\n   */\r\n  Time_Varying_Model_2022a_B.Sum4_m =\r\n    Time_Varying_Model_2022a_P.Constant1_Value_o -\r\n    Time_Varying_Model_2022a_B.OpenRocketX_CG;\r\n\r\n  /* Math: '<S3>/Square4' */\r\n  Time_Varying_Model_2022a_B.Square4 = Time_Varying_Model_2022a_B.Sum4_m *\r\n    Time_Varying_Model_2022a_B.Sum4_m;\r\n\r\n  /* Product: '<S3>/Product5' */\r\n  Time_Varying_Model_2022a_B.Product5_l = Time_Varying_Model_2022a_B.Square4 *\r\n    Time_Varying_Model_2022a_B.OpenRocketmDot;\r\n\r\n  /* Sum: '<S3>/Sum5' */\r\n  Time_Varying_Model_2022a_B.Sum5 = Time_Varying_Model_2022a_B.Product4_a +\r\n    Time_Varying_Model_2022a_B.Product5_l;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[3] == 0) {\r\n    /* Sum: '<S6>/Sum of Elements' incorporates:\r\n     *  Constant: '<Root>/Constant12'\r\n     *  Constant: '<Root>/Constant13'\r\n     */\r\n    Time_Varying_Model_2022a_B.SumofElements_h =\r\n      Time_Varying_Model_2022a_P.Constant12_Value +\r\n      Time_Varying_Model_2022a_P.Constant13_Value;\r\n\r\n    /* Product: '<S6>/Product' incorporates:\r\n     *  Constant: '<Root>/Constant6'\r\n     *  Constant: '<Root>/Constant7'\r\n     *  Constant: '<Root>/Constant8'\r\n     */\r\n    Time_Varying_Model_2022a_B.Product_p5 = Time_Varying_Model_2022a_B.Gain3 *\r\n      Time_Varying_Model_2022a_P.Constant6_Value *\r\n      Time_Varying_Model_2022a_P.Constant7_Value *\r\n      Time_Varying_Model_2022a_B.SumofElements_h *\r\n      Time_Varying_Model_2022a_P.Constant8_Value;\r\n  }\r\n\r\n  /* Product: '<S7>/Product' incorporates:\r\n   *  Constant: '<Root>/Constant10'\r\n   *  Constant: '<Root>/Constant11'\r\n   *  Constant: '<Root>/Constant6'\r\n   *  Constant: '<Root>/Constant7'\r\n   *  Constant: '<Root>/Constant9'\r\n   *  Constant: '<S7>/Constant'\r\n   */\r\n  Time_Varying_Model_2022a_B.Product_ap =\r\n    Time_Varying_Model_2022a_P.Constant_Value_k * Time_Varying_Model_2022a_B.rho\r\n    * Time_Varying_Model_2022a_P.Constant6_Value *\r\n    Time_Varying_Model_2022a_B.OpenRocketVelocity *\r\n    Time_Varying_Model_2022a_P.Constant11_Value *\r\n    Time_Varying_Model_2022a_P.Constant7_Value *\r\n    Time_Varying_Model_2022a_P.Constant9_Value *\r\n    Time_Varying_Model_2022a_P.Constant10_Value;\r\n\r\n  /* Gain: '<S17>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_c = Time_Varying_Model_2022a_P.Gain_Gain_cc *\r\n    Time_Varying_Model_2022a_B.MaxDeflection[0];\r\n\r\n  /* Gain: '<S18>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_m = Time_Varying_Model_2022a_P.Gain_Gain_eq *\r\n    Time_Varying_Model_2022a_B.MaxDeflection[1];\r\n\r\n  /* Gain: '<S29>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_ie = Time_Varying_Model_2022a_P.Gain_Gain_cj *\r\n    Time_Varying_Model_2022a_B.MaxDeflection[2];\r\n\r\n  /* Gain: '<S34>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_ps = Time_Varying_Model_2022a_P.Gain_Gain_ho *\r\n    Time_Varying_Model_2022a_B.MaxDeflection[3];\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n  }\r\n\r\n  /* Gain: '<S35>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_h3 = Time_Varying_Model_2022a_P.Gain_Gain_kh *\r\n    Time_Varying_Model_2022a_B.Integrator5;\r\n\r\n  /* Gain: '<S36>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_mg = Time_Varying_Model_2022a_P.Gain_Gain_d3 *\r\n    Time_Varying_Model_2022a_B.Integrator4;\r\n\r\n  /* Gain: '<S37>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_jm = Time_Varying_Model_2022a_P.Gain_Gain_mv *\r\n    Time_Varying_Model_2022a_B.Integrator3;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n  }\r\n\r\n  /* Gain: '<S38>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_j5 = Time_Varying_Model_2022a_P.Gain_Gain_di *\r\n    Time_Varying_Model_2022a_B.Integrator2;\r\n\r\n  /* Gain: '<S39>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_bv = Time_Varying_Model_2022a_P.Gain_Gain_g *\r\n    Time_Varying_Model_2022a_B.Integrator;\r\n\r\n  /* Gain: '<S40>/Gain' */\r\n  Time_Varying_Model_2022a_B.Gain_d = Time_Varying_Model_2022a_P.Gain_Gain_g4 *\r\n    Time_Varying_Model_2022a_B.Integrator1;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n  }\r\n\r\n  /* MATLAB Function: '<S16>/Pitch' incorporates:\r\n   *  Constant: '<Root>/Constant28'\r\n   *  Constant: '<Root>/Constant30'\r\n   *  Constant: '<Root>/Constant31'\r\n   */\r\n  /* :  Mroll = -((I_R-I_L)/I_L)*p*r; */\r\n  ang_cos = -((Time_Varying_Model_2022a_B.OpenRocketI_R -\r\n               Time_Varying_Model_2022a_B.OpenRocketI_L) /\r\n              Time_Varying_Model_2022a_B.OpenRocketI_L) *\r\n    Time_Varying_Model_2022a_B.Integrator2 *\r\n    Time_Varying_Model_2022a_B.Integrator1;\r\n\r\n  /* :  Mcorr = -(C1/I_L)*alpha; */\r\n  ang_sin = -(Time_Varying_Model_2022a_B.Product_o /\r\n              Time_Varying_Model_2022a_B.OpenRocketI_L) *\r\n    Time_Varying_Model_2022a_B.windAngles[0];\r\n\r\n  /* :  Mcan = ((qBar*S*CLa*Xbar_CP_can)/I_L)*((alpha - x1)*cos(x1) + (alpha + x2)*cos(x2)); */\r\n  st_idx_1 = Time_Varying_Model_2022a_B.Gain3 *\r\n    Time_Varying_Model_2022a_P.Constant28_Value *\r\n    Time_Varying_Model_2022a_P.Constant31_Value *\r\n    Time_Varying_Model_2022a_P.Constant30_Value /\r\n    Time_Varying_Model_2022a_B.OpenRocketI_L *\r\n    ((Time_Varying_Model_2022a_B.windAngles[0] -\r\n      Time_Varying_Model_2022a_B.MaxDeflection[0]) * cos\r\n     (Time_Varying_Model_2022a_B.MaxDeflection[0]) +\r\n     (Time_Varying_Model_2022a_B.windAngles[0] +\r\n      Time_Varying_Model_2022a_B.MaxDeflection[1]) * cos\r\n     (Time_Varying_Model_2022a_B.MaxDeflection[1]));\r\n\r\n  /* :  Mdamp = -(C2/I_L)*q; */\r\n  ct_idx_0 = -(Time_Varying_Model_2022a_B.Sum5 /\r\n               Time_Varying_Model_2022a_B.OpenRocketI_L) *\r\n    Time_Varying_Model_2022a_B.Integrator;\r\n\r\n  /* :  qDot = Mroll + Mcorr + Mcan + Mdamp; */\r\n  Time_Varying_Model_2022a_B.qDot = ((ang_cos + ang_sin) + st_idx_1) + ct_idx_0;\r\n  Time_Varying_Model_2022a_B.Mroll = ang_cos;\r\n  Time_Varying_Model_2022a_B.Mcorr = ang_sin;\r\n  Time_Varying_Model_2022a_B.Mcan = st_idx_1;\r\n  Time_Varying_Model_2022a_B.Mdamp = ct_idx_0;\r\n\r\n  /* Sum: '<S16>/Sum of Elements' */\r\n  Time_Varying_Model_2022a_B.SumofElements_f =\r\n    ((Time_Varying_Model_2022a_B.Mroll + Time_Varying_Model_2022a_B.Mcorr) +\r\n     Time_Varying_Model_2022a_B.Mcan) + Time_Varying_Model_2022a_B.Mdamp;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n  }\r\n\r\n  /* MATLAB Function: '<S16>/Yaw' incorporates:\r\n   *  Constant: '<Root>/Constant28'\r\n   *  Constant: '<Root>/Constant30'\r\n   *  Constant: '<Root>/Constant31'\r\n   */\r\n  /* :  Nroll = -((I_L-I_R)/I_L)*p*q; */\r\n  ang_cos = -((Time_Varying_Model_2022a_B.OpenRocketI_L -\r\n               Time_Varying_Model_2022a_B.OpenRocketI_R) /\r\n              Time_Varying_Model_2022a_B.OpenRocketI_L) *\r\n    Time_Varying_Model_2022a_B.Integrator2 *\r\n    Time_Varying_Model_2022a_B.Integrator;\r\n\r\n  /* :  Ncorr = -(C1/I_L)*beta; */\r\n  ang_sin = -(Time_Varying_Model_2022a_B.Product_o /\r\n              Time_Varying_Model_2022a_B.OpenRocketI_L) *\r\n    Time_Varying_Model_2022a_B.windAngles[1];\r\n\r\n  /* :  Ndamp = -(C2/I_L)*r; */\r\n  st_idx_1 = -(Time_Varying_Model_2022a_B.Sum5 /\r\n               Time_Varying_Model_2022a_B.OpenRocketI_L) *\r\n    Time_Varying_Model_2022a_B.Integrator1;\r\n\r\n  /* :  Ncan = ((qBar*S*CLa*Xbar_CP_can)/I_L)*((beta - y1)*cos(y1) + (beta + y2)*cos(y2)); */\r\n  ct_idx_0 = Time_Varying_Model_2022a_B.Gain3 *\r\n    Time_Varying_Model_2022a_P.Constant28_Value *\r\n    Time_Varying_Model_2022a_P.Constant31_Value *\r\n    Time_Varying_Model_2022a_P.Constant30_Value /\r\n    Time_Varying_Model_2022a_B.OpenRocketI_L *\r\n    ((Time_Varying_Model_2022a_B.windAngles[1] -\r\n      Time_Varying_Model_2022a_B.MaxDeflection[2]) * cos\r\n     (Time_Varying_Model_2022a_B.MaxDeflection[2]) +\r\n     (Time_Varying_Model_2022a_B.windAngles[1] +\r\n      Time_Varying_Model_2022a_B.MaxDeflection[3]) * cos\r\n     (Time_Varying_Model_2022a_B.MaxDeflection[3]));\r\n\r\n  /* :  rDot = Nroll + Ncorr + Ndamp + Ncan; */\r\n  Time_Varying_Model_2022a_B.rDot = ((ang_cos + ang_sin) + st_idx_1) + ct_idx_0;\r\n  Time_Varying_Model_2022a_B.Nroll = ang_cos;\r\n  Time_Varying_Model_2022a_B.Ncorr = ang_sin;\r\n  Time_Varying_Model_2022a_B.Ndamp = st_idx_1;\r\n  Time_Varying_Model_2022a_B.Ncan = ct_idx_0;\r\n\r\n  /* Sum: '<S16>/Sum of Elements1' */\r\n  Time_Varying_Model_2022a_B.SumofElements1_d =\r\n    ((Time_Varying_Model_2022a_B.Nroll + Time_Varying_Model_2022a_B.Ncorr) +\r\n     Time_Varying_Model_2022a_B.Ndamp) + Time_Varying_Model_2022a_B.Ncan;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n  }\r\n\r\n  /* MATLAB Function: '<S16>/Roll' incorporates:\r\n   *  Constant: '<Root>/Constant27'\r\n   *  Constant: '<Root>/Constant28'\r\n   *  Constant: '<Root>/Constant31'\r\n   */\r\n  /* :  pDot = - (Cdp/I_R)*p + ((qBar*S*CLa*Z_CP_can)/I_R)*((alpha - x1)*cos(x1) - (alpha + x2)*cos(x2) + (beta - y1)*cos(y1) - (beta + y2)*cos(y2)); */\r\n  Time_Varying_Model_2022a_B.pDot = ((((Time_Varying_Model_2022a_B.windAngles[0]\r\n    - Time_Varying_Model_2022a_B.MaxDeflection[0]) * cos\r\n    (Time_Varying_Model_2022a_B.MaxDeflection[0]) -\r\n    (Time_Varying_Model_2022a_B.windAngles[0] +\r\n     Time_Varying_Model_2022a_B.MaxDeflection[1]) * cos\r\n    (Time_Varying_Model_2022a_B.MaxDeflection[1])) +\r\n    (Time_Varying_Model_2022a_B.windAngles[1] -\r\n     Time_Varying_Model_2022a_B.MaxDeflection[2]) * cos\r\n    (Time_Varying_Model_2022a_B.MaxDeflection[2])) -\r\n    (Time_Varying_Model_2022a_B.windAngles[1] +\r\n     Time_Varying_Model_2022a_B.MaxDeflection[3]) * cos\r\n    (Time_Varying_Model_2022a_B.MaxDeflection[3])) *\r\n    (Time_Varying_Model_2022a_B.Gain3 *\r\n     Time_Varying_Model_2022a_P.Constant28_Value *\r\n     Time_Varying_Model_2022a_P.Constant31_Value *\r\n     Time_Varying_Model_2022a_P.Constant27_Value /\r\n     Time_Varying_Model_2022a_B.OpenRocketI_R) +\r\n    -(Time_Varying_Model_2022a_B.Product_ap /\r\n      Time_Varying_Model_2022a_B.OpenRocketI_R) *\r\n    Time_Varying_Model_2022a_B.Integrator2;\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n      Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[1] == 0) {\r\n  }\r\n\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M)) {\r\n    /* Matfile logging */\r\n    rt_UpdateTXYLogVars(Time_Varying_Model_2022a_M->rtwLogInfo,\r\n                        (Time_Varying_Model_2022a_M->Timing.t));\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M)) {\r\n    /* Update for RateLimiter: '<Root>/Motor Speed' */\r\n    Time_Varying_Model_2022a_DW.PrevY[0] =\r\n      Time_Varying_Model_2022a_B.MotorSpeed[0];\r\n    Time_Varying_Model_2022a_DW.PrevY[1] =\r\n      Time_Varying_Model_2022a_B.MotorSpeed[1];\r\n    Time_Varying_Model_2022a_DW.PrevY[2] =\r\n      Time_Varying_Model_2022a_B.MotorSpeed[2];\r\n    Time_Varying_Model_2022a_DW.PrevY[3] =\r\n      Time_Varying_Model_2022a_B.MotorSpeed[3];\r\n    Time_Varying_Model_2022a_DW.LastMajorTime =\r\n      Time_Varying_Model_2022a_M->Timing.t[0];\r\n    if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n        Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[2] == 0) {\r\n      /* Update for RandomNumber: '<S123>/White Noise' */\r\n      Time_Varying_Model_2022a_DW.NextOutput[0] = rt_nrand_Upu32_Yd_f_pw_snf\r\n        (&Time_Varying_Model_2022a_DW.RandSeed[0]) *\r\n        Time_Varying_Model_2022a_P.WhiteNoise_StdDev +\r\n        Time_Varying_Model_2022a_P.WhiteNoise_Mean;\r\n      Time_Varying_Model_2022a_DW.NextOutput[1] = rt_nrand_Upu32_Yd_f_pw_snf\r\n        (&Time_Varying_Model_2022a_DW.RandSeed[1]) *\r\n        Time_Varying_Model_2022a_P.WhiteNoise_StdDev +\r\n        Time_Varying_Model_2022a_P.WhiteNoise_Mean;\r\n      Time_Varying_Model_2022a_DW.NextOutput[2] = rt_nrand_Upu32_Yd_f_pw_snf\r\n        (&Time_Varying_Model_2022a_DW.RandSeed[2]) *\r\n        Time_Varying_Model_2022a_P.WhiteNoise_StdDev +\r\n        Time_Varying_Model_2022a_P.WhiteNoise_Mean;\r\n      Time_Varying_Model_2022a_DW.NextOutput[3] = rt_nrand_Upu32_Yd_f_pw_snf\r\n        (&Time_Varying_Model_2022a_DW.RandSeed[3]) *\r\n        Time_Varying_Model_2022a_P.WhiteNoise_StdDev +\r\n        Time_Varying_Model_2022a_P.WhiteNoise_Mean;\r\n    }\r\n\r\n    if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M) &&\r\n        Time_Varying_Model_2022a_M->Timing.TaskCounters.TID[3] == 0) {\r\n      /* Update for Delay: '<S52>/MemoryX' */\r\n      Time_Varying_Model_2022a_DW.icLoad = false;\r\n      Time_Varying_Model_2022a_DW.MemoryX_DSTATE =\r\n        Time_Varying_Model_2022a_B.Add_p;\r\n    }\r\n  }                                    /* end MajorTimeStep */\r\n\r\n  if (rtmIsMajorTimeStep(Time_Varying_Model_2022a_M)) {\r\n    /* signal main to stop simulation */\r\n    {                                  /* Sample time: [0.0s, 0.0s] */\r\n      if ((rtmGetTFinal(Time_Varying_Model_2022a_M)!=-1) &&\r\n          !((rtmGetTFinal(Time_Varying_Model_2022a_M)-\r\n             (((Time_Varying_Model_2022a_M->Timing.clockTick1+\r\n                Time_Varying_Model_2022a_M->Timing.clockTickH1* 4294967296.0)) *\r\n              0.01)) > (((Time_Varying_Model_2022a_M->Timing.clockTick1+\r\n                          Time_Varying_Model_2022a_M->Timing.clockTickH1*\r\n                          4294967296.0)) * 0.01) * (DBL_EPSILON))) {\r\n        rtmSetErrorStatus(Time_Varying_Model_2022a_M, \"Simulation finished\");\r\n      }\r\n    }\r\n\r\n    rt_ertODEUpdateContinuousStates(&Time_Varying_Model_2022a_M->solverInfo);\r\n\r\n    /* Update absolute time for base rate */\r\n    /* The \"clockTick0\" counts the number of times the code of this task has\r\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\r\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\r\n     * overflow during the application lifespan selected.\r\n     * Timer of this task consists of two 32 bit unsigned integers.\r\n     * The two integers represent the low bits Timing.clockTick0 and the high bits\r\n     * Timing.clockTickH0. When the low bit overflows to 0, the high bits increment.\r\n     */\r\n    if (!(++Time_Varying_Model_2022a_M->Timing.clockTick0)) {\r\n      ++Time_Varying_Model_2022a_M->Timing.clockTickH0;\r\n    }\r\n\r\n    Time_Varying_Model_2022a_M->Timing.t[0] = rtsiGetSolverStopTime\r\n      (&Time_Varying_Model_2022a_M->solverInfo);\r\n\r\n    {\r\n      /* Update absolute timer for sample time: [0.01s, 0.0s] */\r\n      /* The \"clockTick1\" counts the number of times the code of this task has\r\n       * been executed. The resolution of this integer timer is 0.01, which is the step size\r\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\r\n       * application lifespan selected.\r\n       * Timer of this task consists of two 32 bit unsigned integers.\r\n       * The two integers represent the low bits Timing.clockTick1 and the high bits\r\n       * Timing.clockTickH1. When the low bit overflows to 0, the high bits increment.\r\n       */\r\n      Time_Varying_Model_2022a_M->Timing.clockTick1++;\r\n      if (!Time_Varying_Model_2022a_M->Timing.clockTick1) {\r\n        Time_Varying_Model_2022a_M->Timing.clockTickH1++;\r\n      }\r\n    }\r\n\r\n    rate_scheduler();\r\n  }                                    /* end MajorTimeStep */\r\n}\r\n\r\n/* Derivatives for root system: '<Root>' */\r\nvoid Time_Varying_Model_2022a_derivatives(void)\r\n{\r\n  XDot_Time_Varying_Model_2022a_T *_rtXdot;\r\n  _rtXdot = ((XDot_Time_Varying_Model_2022a_T *)\r\n             Time_Varying_Model_2022a_M->derivs);\r\n\r\n  /* Derivatives for Integrator: '<S16>/Integrator4' */\r\n  _rtXdot->Integrator4_CSTATE = Time_Varying_Model_2022a_B.Integrator;\r\n\r\n  /* Derivatives for Integrator: '<S16>/Integrator5' */\r\n  _rtXdot->Integrator5_CSTATE = Time_Varying_Model_2022a_B.Integrator2;\r\n\r\n  /* Derivatives for Integrator: '<S16>/Integrator3' */\r\n  _rtXdot->Integrator3_CSTATE = Time_Varying_Model_2022a_B.Integrator1;\r\n\r\n  /* Derivatives for Integrator: '<S16>/Integrator2' */\r\n  _rtXdot->Integrator2_CSTATE = Time_Varying_Model_2022a_B.pDot;\r\n\r\n  /* Derivatives for Integrator: '<S16>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE = Time_Varying_Model_2022a_B.qDot;\r\n\r\n  /* Derivatives for Integrator: '<S16>/Integrator1' */\r\n  _rtXdot->Integrator1_CSTATE = Time_Varying_Model_2022a_B.rDot;\r\n\r\n  /* Derivatives for Enabled SubSystem: '<S114>/Hugw(s)' */\r\n  if (Time_Varying_Model_2022a_DW.Hugws_MODE) {\r\n    /* Derivatives for Integrator: '<S127>/ug_p' */\r\n    _rtXdot->ug_p_CSTATE[0] = Time_Varying_Model_2022a_B.w_b[0];\r\n    _rtXdot->ug_p_CSTATE[1] = Time_Varying_Model_2022a_B.w_b[1];\r\n  } else {\r\n    {\r\n      real_T *dx;\r\n      int_T i;\r\n      dx = &(((XDot_Time_Varying_Model_2022a_T *)\r\n              Time_Varying_Model_2022a_M->derivs)->ug_p_CSTATE[0]);\r\n      for (i=0; i < 2; i++) {\r\n        dx[i] = 0.0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* End of Derivatives for SubSystem: '<S114>/Hugw(s)' */\r\n\r\n  /* Derivatives for Enabled SubSystem: '<S114>/Hvgw(s)' */\r\n  if (Time_Varying_Model_2022a_DW.Hvgws_MODE) {\r\n    /* Derivatives for Integrator: '<S128>/vg_p1' */\r\n    _rtXdot->vg_p1_CSTATE[0] = Time_Varying_Model_2022a_B.w_l[0];\r\n\r\n    /* Derivatives for Integrator: '<S128>/vgw_p2' */\r\n    _rtXdot->vgw_p2_CSTATE[0] = Time_Varying_Model_2022a_B.w_i[0];\r\n\r\n    /* Derivatives for Integrator: '<S128>/vg_p1' */\r\n    _rtXdot->vg_p1_CSTATE[1] = Time_Varying_Model_2022a_B.w_l[1];\r\n\r\n    /* Derivatives for Integrator: '<S128>/vgw_p2' */\r\n    _rtXdot->vgw_p2_CSTATE[1] = Time_Varying_Model_2022a_B.w_i[1];\r\n  } else {\r\n    {\r\n      real_T *dx;\r\n      int_T i;\r\n      dx = &(((XDot_Time_Varying_Model_2022a_T *)\r\n              Time_Varying_Model_2022a_M->derivs)->vg_p1_CSTATE[0]);\r\n      for (i=0; i < 4; i++) {\r\n        dx[i] = 0.0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* End of Derivatives for SubSystem: '<S114>/Hvgw(s)' */\r\n\r\n  /* Derivatives for Enabled SubSystem: '<S114>/Hwgw(s)' */\r\n  if (Time_Varying_Model_2022a_DW.Hwgws_MODE) {\r\n    /* Derivatives for Integrator: '<S129>/wg_p1' */\r\n    _rtXdot->wg_p1_CSTATE[0] = Time_Varying_Model_2022a_B.w[0];\r\n\r\n    /* Derivatives for Integrator: '<S129>/wg_p2' */\r\n    _rtXdot->wg_p2_CSTATE[0] = Time_Varying_Model_2022a_B.w_o[0];\r\n\r\n    /* Derivatives for Integrator: '<S129>/wg_p1' */\r\n    _rtXdot->wg_p1_CSTATE[1] = Time_Varying_Model_2022a_B.w[1];\r\n\r\n    /* Derivatives for Integrator: '<S129>/wg_p2' */\r\n    _rtXdot->wg_p2_CSTATE[1] = Time_Varying_Model_2022a_B.w_o[1];\r\n  } else {\r\n    {\r\n      real_T *dx;\r\n      int_T i;\r\n      dx = &(((XDot_Time_Varying_Model_2022a_T *)\r\n              Time_Varying_Model_2022a_M->derivs)->wg_p1_CSTATE[0]);\r\n      for (i=0; i < 4; i++) {\r\n        dx[i] = 0.0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* End of Derivatives for SubSystem: '<S114>/Hwgw(s)' */\r\n\r\n  /* Derivatives for Integrator: '<S41>/Integrator' */\r\n  _rtXdot->Integrator_CSTATE_m[0] = Time_Varying_Model_2022a_B.Merge_n[0];\r\n  _rtXdot->Integrator_CSTATE_m[1] = Time_Varying_Model_2022a_B.Merge_n[1];\r\n  _rtXdot->Integrator_CSTATE_m[2] = Time_Varying_Model_2022a_B.Merge_n[2];\r\n\r\n  /* Derivatives for Enabled SubSystem: '<S113>/Hpgw' */\r\n  if (Time_Varying_Model_2022a_DW.Hpgw_MODE) {\r\n    /* Derivatives for Integrator: '<S124>/pgw_p' */\r\n    _rtXdot->pgw_p_CSTATE[0] = Time_Varying_Model_2022a_B.w_m[0];\r\n    _rtXdot->pgw_p_CSTATE[1] = Time_Varying_Model_2022a_B.w_m[1];\r\n  } else {\r\n    {\r\n      real_T *dx;\r\n      int_T i;\r\n      dx = &(((XDot_Time_Varying_Model_2022a_T *)\r\n              Time_Varying_Model_2022a_M->derivs)->pgw_p_CSTATE[0]);\r\n      for (i=0; i < 2; i++) {\r\n        dx[i] = 0.0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* End of Derivatives for SubSystem: '<S113>/Hpgw' */\r\n\r\n  /* Derivatives for Enabled SubSystem: '<S113>/Hqgw' */\r\n  if (Time_Varying_Model_2022a_DW.Hqgw_MODE) {\r\n    /* Derivatives for Integrator: '<S125>/qgw_p' */\r\n    _rtXdot->qgw_p_CSTATE[0] = Time_Varying_Model_2022a_B.w_gw[0];\r\n    _rtXdot->qgw_p_CSTATE[1] = Time_Varying_Model_2022a_B.w_gw[1];\r\n  } else {\r\n    {\r\n      real_T *dx;\r\n      int_T i;\r\n      dx = &(((XDot_Time_Varying_Model_2022a_T *)\r\n              Time_Varying_Model_2022a_M->derivs)->qgw_p_CSTATE[0]);\r\n      for (i=0; i < 2; i++) {\r\n        dx[i] = 0.0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* End of Derivatives for SubSystem: '<S113>/Hqgw' */\r\n\r\n  /* Derivatives for Enabled SubSystem: '<S113>/Hrgw' */\r\n  if (Time_Varying_Model_2022a_DW.Hrgw_MODE) {\r\n    /* Derivatives for Integrator: '<S126>/rgw_p' */\r\n    _rtXdot->rgw_p_CSTATE[0] = Time_Varying_Model_2022a_B.w_g[0];\r\n    _rtXdot->rgw_p_CSTATE[1] = Time_Varying_Model_2022a_B.w_g[1];\r\n  } else {\r\n    {\r\n      real_T *dx;\r\n      int_T i;\r\n      dx = &(((XDot_Time_Varying_Model_2022a_T *)\r\n              Time_Varying_Model_2022a_M->derivs)->rgw_p_CSTATE[0]);\r\n      for (i=0; i < 2; i++) {\r\n        dx[i] = 0.0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /* End of Derivatives for SubSystem: '<S113>/Hrgw' */\r\n}\r\n\r\n/* Model initialize function */\r\nvoid Time_Varying_Model_2022a_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n\r\n  /* initialize real-time model */\r\n  (void) memset((void *)Time_Varying_Model_2022a_M, 0,\r\n                sizeof(RT_MODEL_Time_Varying_Model_2_T));\r\n\r\n  {\r\n    /* Setup solver object */\r\n    rtsiSetSimTimeStepPtr(&Time_Varying_Model_2022a_M->solverInfo,\r\n                          &Time_Varying_Model_2022a_M->Timing.simTimeStep);\r\n    rtsiSetTPtr(&Time_Varying_Model_2022a_M->solverInfo, &rtmGetTPtr\r\n                (Time_Varying_Model_2022a_M));\r\n    rtsiSetStepSizePtr(&Time_Varying_Model_2022a_M->solverInfo,\r\n                       &Time_Varying_Model_2022a_M->Timing.stepSize0);\r\n    rtsiSetdXPtr(&Time_Varying_Model_2022a_M->solverInfo,\r\n                 &Time_Varying_Model_2022a_M->derivs);\r\n    rtsiSetContStatesPtr(&Time_Varying_Model_2022a_M->solverInfo, (real_T **)\r\n                         &Time_Varying_Model_2022a_M->contStates);\r\n    rtsiSetNumContStatesPtr(&Time_Varying_Model_2022a_M->solverInfo,\r\n      &Time_Varying_Model_2022a_M->Sizes.numContStates);\r\n    rtsiSetNumPeriodicContStatesPtr(&Time_Varying_Model_2022a_M->solverInfo,\r\n      &Time_Varying_Model_2022a_M->Sizes.numPeriodicContStates);\r\n    rtsiSetPeriodicContStateIndicesPtr(&Time_Varying_Model_2022a_M->solverInfo,\r\n      &Time_Varying_Model_2022a_M->periodicContStateIndices);\r\n    rtsiSetPeriodicContStateRangesPtr(&Time_Varying_Model_2022a_M->solverInfo,\r\n      &Time_Varying_Model_2022a_M->periodicContStateRanges);\r\n    rtsiSetContStateDisabledPtr(&Time_Varying_Model_2022a_M->solverInfo,\r\n      (boolean_T**) &Time_Varying_Model_2022a_M->contStateDisabled);\r\n    rtsiSetErrorStatusPtr(&Time_Varying_Model_2022a_M->solverInfo,\r\n                          (&rtmGetErrorStatus(Time_Varying_Model_2022a_M)));\r\n    rtsiSetRTModelPtr(&Time_Varying_Model_2022a_M->solverInfo,\r\n                      Time_Varying_Model_2022a_M);\r\n  }\r\n\r\n  rtsiSetSimTimeStep(&Time_Varying_Model_2022a_M->solverInfo, MAJOR_TIME_STEP);\r\n  Time_Varying_Model_2022a_M->intgData.y = Time_Varying_Model_2022a_M->odeY;\r\n  Time_Varying_Model_2022a_M->intgData.f[0] = Time_Varying_Model_2022a_M->odeF[0];\r\n  Time_Varying_Model_2022a_M->intgData.f[1] = Time_Varying_Model_2022a_M->odeF[1];\r\n  Time_Varying_Model_2022a_M->intgData.f[2] = Time_Varying_Model_2022a_M->odeF[2];\r\n  Time_Varying_Model_2022a_M->contStates = ((X_Time_Varying_Model_2022a_T *)\r\n    &Time_Varying_Model_2022a_X);\r\n  Time_Varying_Model_2022a_M->contStateDisabled =\r\n    ((XDis_Time_Varying_Model_2022a_T *) &Time_Varying_Model_2022a_XDis);\r\n  Time_Varying_Model_2022a_M->Timing.tStart = (0.0);\r\n  rtsiSetSolverData(&Time_Varying_Model_2022a_M->solverInfo, (void *)\r\n                    &Time_Varying_Model_2022a_M->intgData);\r\n  rtsiSetIsMinorTimeStepWithModeChange(&Time_Varying_Model_2022a_M->solverInfo,\r\n    false);\r\n  rtsiSetSolverName(&Time_Varying_Model_2022a_M->solverInfo,\"ode3\");\r\n  rtmSetTPtr(Time_Varying_Model_2022a_M,\r\n             &Time_Varying_Model_2022a_M->Timing.tArray[0]);\r\n  rtmSetTFinal(Time_Varying_Model_2022a_M, 12.0);\r\n  Time_Varying_Model_2022a_M->Timing.stepSize0 = 0.01;\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    static RTWLogInfo rt_DataLoggingInfo;\r\n    rt_DataLoggingInfo.loggingInterval = (NULL);\r\n    Time_Varying_Model_2022a_M->rtwLogInfo = &rt_DataLoggingInfo;\r\n  }\r\n\r\n  /* Setup for data logging */\r\n  {\r\n    rtliSetLogXSignalInfo(Time_Varying_Model_2022a_M->rtwLogInfo, (NULL));\r\n    rtliSetLogXSignalPtrs(Time_Varying_Model_2022a_M->rtwLogInfo, (NULL));\r\n    rtliSetLogT(Time_Varying_Model_2022a_M->rtwLogInfo, \"tout\");\r\n    rtliSetLogX(Time_Varying_Model_2022a_M->rtwLogInfo, \"\");\r\n    rtliSetLogXFinal(Time_Varying_Model_2022a_M->rtwLogInfo, \"\");\r\n    rtliSetLogVarNameModifier(Time_Varying_Model_2022a_M->rtwLogInfo, \"rt_\");\r\n    rtliSetLogFormat(Time_Varying_Model_2022a_M->rtwLogInfo, 4);\r\n    rtliSetLogMaxRows(Time_Varying_Model_2022a_M->rtwLogInfo, 0);\r\n    rtliSetLogDecimation(Time_Varying_Model_2022a_M->rtwLogInfo, 1);\r\n    rtliSetLogY(Time_Varying_Model_2022a_M->rtwLogInfo, \"\");\r\n    rtliSetLogYSignalInfo(Time_Varying_Model_2022a_M->rtwLogInfo, (NULL));\r\n    rtliSetLogYSignalPtrs(Time_Varying_Model_2022a_M->rtwLogInfo, (NULL));\r\n  }\r\n\r\n  /* block I/O */\r\n  (void) memset(((void *) &Time_Varying_Model_2022a_B), 0,\r\n                sizeof(B_Time_Varying_Model_2022a_T));\r\n\r\n  /* states (continuous) */\r\n  {\r\n    (void) memset((void *)&Time_Varying_Model_2022a_X, 0,\r\n                  sizeof(X_Time_Varying_Model_2022a_T));\r\n  }\r\n\r\n  /* disabled states */\r\n  {\r\n    (void) memset((void *)&Time_Varying_Model_2022a_XDis, 0,\r\n                  sizeof(XDis_Time_Varying_Model_2022a_T));\r\n  }\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&Time_Varying_Model_2022a_DW, 0,\r\n                sizeof(DW_Time_Varying_Model_2022a_T));\r\n\r\n  /* external outputs */\r\n  (void)memset(&Time_Varying_Model_2022a_Y, 0, sizeof\r\n               (ExtY_Time_Varying_Model_2022a_T));\r\n\r\n  /* Matfile logging */\r\n  rt_StartDataLoggingWithStartTime(Time_Varying_Model_2022a_M->rtwLogInfo, 0.0,\r\n    rtmGetTFinal(Time_Varying_Model_2022a_M),\r\n    Time_Varying_Model_2022a_M->Timing.stepSize0, (&rtmGetErrorStatus\r\n    (Time_Varying_Model_2022a_M)));\r\n\r\n  /* Start for If: '<S119>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' */\r\n  Time_Varying_Model_2022a_DW.ifHeightMaxlowaltitudeelseifHei = -1;\r\n\r\n  /* Start for If: '<S118>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' */\r\n  Time_Varying_Model_2022a_DW.ifHeightMaxlowaltitudeelseifH_k = -1;\r\n\r\n  {\r\n    real_T u0;\r\n    int32_T r;\r\n    int32_T t;\r\n    uint32_T tseed;\r\n\r\n    /* InitializeConditions for Integrator: '<S16>/Integrator4' */\r\n    Time_Varying_Model_2022a_X.Integrator4_CSTATE =\r\n      Time_Varying_Model_2022a_P.Integrator4_IC;\r\n\r\n    /* InitializeConditions for Integrator: '<S16>/Integrator5' */\r\n    Time_Varying_Model_2022a_X.Integrator5_CSTATE =\r\n      Time_Varying_Model_2022a_P.Integrator5_IC;\r\n\r\n    /* InitializeConditions for Integrator: '<S16>/Integrator3' */\r\n    Time_Varying_Model_2022a_X.Integrator3_CSTATE =\r\n      Time_Varying_Model_2022a_P.Integrator3_IC;\r\n\r\n    /* InitializeConditions for Integrator: '<S16>/Integrator2' */\r\n    Time_Varying_Model_2022a_X.Integrator2_CSTATE =\r\n      Time_Varying_Model_2022a_P.Integrator2_IC;\r\n\r\n    /* InitializeConditions for Integrator: '<S16>/Integrator' */\r\n    Time_Varying_Model_2022a_X.Integrator_CSTATE =\r\n      Time_Varying_Model_2022a_P.Integrator_IC;\r\n\r\n    /* InitializeConditions for Integrator: '<S16>/Integrator1' */\r\n    Time_Varying_Model_2022a_X.Integrator1_CSTATE =\r\n      Time_Varying_Model_2022a_P.Integrator1_IC;\r\n\r\n    /* InitializeConditions for RateLimiter: '<Root>/Motor Speed' */\r\n    Time_Varying_Model_2022a_DW.LastMajorTime = (rtInf);\r\n\r\n    /* InitializeConditions for RandomNumber: '<S123>/White Noise' */\r\n    u0 = Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_a[0];\r\n    u0 = floor(u0);\r\n    if (rtIsNaN(u0) || rtIsInf(u0)) {\r\n      u0 = 0.0;\r\n    } else {\r\n      u0 = fmod(u0, 4.294967296E+9);\r\n    }\r\n\r\n    if (u0 < 0.0) {\r\n      tseed = (uint32_T)-(int32_T)(uint32_T)-u0;\r\n    } else {\r\n      tseed = (uint32_T)u0;\r\n    }\r\n\r\n    r = (int32_T)(tseed >> 16U);\r\n    t = (int32_T)(tseed & 32768U);\r\n    tseed = ((((tseed - ((uint32_T)r << 16U)) + (uint32_T)t) << 16U) + (uint32_T)\r\n             t) + (uint32_T)r;\r\n    if (tseed < 1U) {\r\n      tseed = 1144108930U;\r\n    } else if (tseed > 2147483646U) {\r\n      tseed = 2147483646U;\r\n    }\r\n\r\n    u0 = rt_nrand_Upu32_Yd_f_pw_snf(&tseed) *\r\n      Time_Varying_Model_2022a_P.WhiteNoise_StdDev +\r\n      Time_Varying_Model_2022a_P.WhiteNoise_Mean;\r\n    Time_Varying_Model_2022a_DW.NextOutput[0] = u0;\r\n    Time_Varying_Model_2022a_DW.RandSeed[0] = tseed;\r\n    u0 = Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_a[1];\r\n    u0 = floor(u0);\r\n    if (rtIsNaN(u0) || rtIsInf(u0)) {\r\n      u0 = 0.0;\r\n    } else {\r\n      u0 = fmod(u0, 4.294967296E+9);\r\n    }\r\n\r\n    if (u0 < 0.0) {\r\n      tseed = (uint32_T)-(int32_T)(uint32_T)-u0;\r\n    } else {\r\n      tseed = (uint32_T)u0;\r\n    }\r\n\r\n    r = (int32_T)(tseed >> 16U);\r\n    t = (int32_T)(tseed & 32768U);\r\n    tseed = ((((tseed - ((uint32_T)r << 16U)) + (uint32_T)t) << 16U) + (uint32_T)\r\n             t) + (uint32_T)r;\r\n    if (tseed < 1U) {\r\n      tseed = 1144108930U;\r\n    } else if (tseed > 2147483646U) {\r\n      tseed = 2147483646U;\r\n    }\r\n\r\n    u0 = rt_nrand_Upu32_Yd_f_pw_snf(&tseed) *\r\n      Time_Varying_Model_2022a_P.WhiteNoise_StdDev +\r\n      Time_Varying_Model_2022a_P.WhiteNoise_Mean;\r\n    Time_Varying_Model_2022a_DW.NextOutput[1] = u0;\r\n    Time_Varying_Model_2022a_DW.RandSeed[1] = tseed;\r\n    u0 = Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_a[2];\r\n    u0 = floor(u0);\r\n    if (rtIsNaN(u0) || rtIsInf(u0)) {\r\n      u0 = 0.0;\r\n    } else {\r\n      u0 = fmod(u0, 4.294967296E+9);\r\n    }\r\n\r\n    if (u0 < 0.0) {\r\n      tseed = (uint32_T)-(int32_T)(uint32_T)-u0;\r\n    } else {\r\n      tseed = (uint32_T)u0;\r\n    }\r\n\r\n    r = (int32_T)(tseed >> 16U);\r\n    t = (int32_T)(tseed & 32768U);\r\n    tseed = ((((tseed - ((uint32_T)r << 16U)) + (uint32_T)t) << 16U) + (uint32_T)\r\n             t) + (uint32_T)r;\r\n    if (tseed < 1U) {\r\n      tseed = 1144108930U;\r\n    } else if (tseed > 2147483646U) {\r\n      tseed = 2147483646U;\r\n    }\r\n\r\n    u0 = rt_nrand_Upu32_Yd_f_pw_snf(&tseed) *\r\n      Time_Varying_Model_2022a_P.WhiteNoise_StdDev +\r\n      Time_Varying_Model_2022a_P.WhiteNoise_Mean;\r\n    Time_Varying_Model_2022a_DW.NextOutput[2] = u0;\r\n    Time_Varying_Model_2022a_DW.RandSeed[2] = tseed;\r\n    u0 = Time_Varying_Model_2022a_P.DrydenWindTurbulenceModelCont_a[3];\r\n    u0 = floor(u0);\r\n    if (rtIsNaN(u0) || rtIsInf(u0)) {\r\n      u0 = 0.0;\r\n    } else {\r\n      u0 = fmod(u0, 4.294967296E+9);\r\n    }\r\n\r\n    if (u0 < 0.0) {\r\n      tseed = (uint32_T)-(int32_T)(uint32_T)-u0;\r\n    } else {\r\n      tseed = (uint32_T)u0;\r\n    }\r\n\r\n    r = (int32_T)(tseed >> 16U);\r\n    t = (int32_T)(tseed & 32768U);\r\n    tseed = ((((tseed - ((uint32_T)r << 16U)) + (uint32_T)t) << 16U) + (uint32_T)\r\n             t) + (uint32_T)r;\r\n    if (tseed < 1U) {\r\n      tseed = 1144108930U;\r\n    } else if (tseed > 2147483646U) {\r\n      tseed = 2147483646U;\r\n    }\r\n\r\n    u0 = rt_nrand_Upu32_Yd_f_pw_snf(&tseed) *\r\n      Time_Varying_Model_2022a_P.WhiteNoise_StdDev +\r\n      Time_Varying_Model_2022a_P.WhiteNoise_Mean;\r\n    Time_Varying_Model_2022a_DW.NextOutput[3] = u0;\r\n    Time_Varying_Model_2022a_DW.RandSeed[3] = tseed;\r\n\r\n    /* End of InitializeConditions for RandomNumber: '<S123>/White Noise' */\r\n\r\n    /* InitializeConditions for Integrator: '<S41>/Integrator' */\r\n    Time_Varying_Model_2022a_X.Integrator_CSTATE_m[0] =\r\n      Time_Varying_Model_2022a_P.Integrator_IC_d;\r\n    Time_Varying_Model_2022a_X.Integrator_CSTATE_m[1] =\r\n      Time_Varying_Model_2022a_P.Integrator_IC_d;\r\n    Time_Varying_Model_2022a_X.Integrator_CSTATE_m[2] =\r\n      Time_Varying_Model_2022a_P.Integrator_IC_d;\r\n\r\n    /* InitializeConditions for Delay: '<S52>/MemoryX' */\r\n    Time_Varying_Model_2022a_DW.icLoad = true;\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S80>/Enabled Subsystem' */\r\n    /* SystemInitialize for Product: '<S106>/Product2' incorporates:\r\n     *  Outport: '<S106>/deltax'\r\n     */\r\n    Time_Varying_Model_2022a_B.Product2_cw =\r\n      Time_Varying_Model_2022a_P.deltax_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S80>/Enabled Subsystem' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S73>/MeasurementUpdate' */\r\n    /* SystemInitialize for Product: '<S104>/Product3' incorporates:\r\n     *  Outport: '<S104>/L*(y[k]-yhat[k|k-1])'\r\n     */\r\n    Time_Varying_Model_2022a_B.Product3_lw =\r\n      Time_Varying_Model_2022a_P.Lykyhatkk1_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S73>/MeasurementUpdate' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S114>/Hugw(s)' */\r\n    /* InitializeConditions for Integrator: '<S127>/ug_p' */\r\n    Time_Varying_Model_2022a_X.ug_p_CSTATE[0] =\r\n      Time_Varying_Model_2022a_P.ug_p_IC;\r\n\r\n    /* SystemInitialize for Product: '<S127>/w1' incorporates:\r\n     *  Outport: '<S127>/ugw'\r\n     */\r\n    Time_Varying_Model_2022a_B.w1_a[0] = Time_Varying_Model_2022a_P.ugw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S114>/Hugw(s)' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S114>/Hvgw(s)' */\r\n    /* InitializeConditions for Integrator: '<S128>/vg_p1' */\r\n    Time_Varying_Model_2022a_X.vg_p1_CSTATE[0] =\r\n      Time_Varying_Model_2022a_P.vg_p1_IC;\r\n\r\n    /* InitializeConditions for Integrator: '<S128>/vgw_p2' */\r\n    Time_Varying_Model_2022a_X.vgw_p2_CSTATE[0] =\r\n      Time_Varying_Model_2022a_P.vgw_p2_IC;\r\n\r\n    /* SystemInitialize for Product: '<S128>/w 1' incorporates:\r\n     *  Outport: '<S128>/vgw'\r\n     */\r\n    Time_Varying_Model_2022a_B.w1[0] = Time_Varying_Model_2022a_P.vgw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S114>/Hvgw(s)' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S114>/Hwgw(s)' */\r\n    /* InitializeConditions for Integrator: '<S129>/wg_p1' */\r\n    Time_Varying_Model_2022a_X.wg_p1_CSTATE[0] =\r\n      Time_Varying_Model_2022a_P.wg_p1_IC;\r\n\r\n    /* InitializeConditions for Integrator: '<S129>/wg_p2' */\r\n    Time_Varying_Model_2022a_X.wg_p2_CSTATE[0] =\r\n      Time_Varying_Model_2022a_P.wg_p2_IC;\r\n\r\n    /* SystemInitialize for Product: '<S129>/Lwg//V 1' incorporates:\r\n     *  Outport: '<S129>/wgw'\r\n     */\r\n    Time_Varying_Model_2022a_B.LwgV1[0] = Time_Varying_Model_2022a_P.wgw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S114>/Hwgw(s)' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S113>/Hpgw' */\r\n    /* InitializeConditions for Integrator: '<S124>/pgw_p' */\r\n    Time_Varying_Model_2022a_X.pgw_p_CSTATE[0] =\r\n      Time_Varying_Model_2022a_P.pgw_p_IC;\r\n\r\n    /* SystemInitialize for Product: '<S124>/sigma_w' incorporates:\r\n     *  Outport: '<S124>/pgw'\r\n     */\r\n    Time_Varying_Model_2022a_B.sigma_w[0] = Time_Varying_Model_2022a_P.pgw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S113>/Hpgw' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S113>/Hqgw' */\r\n    /* InitializeConditions for Integrator: '<S125>/qgw_p' */\r\n    Time_Varying_Model_2022a_X.qgw_p_CSTATE[0] =\r\n      Time_Varying_Model_2022a_P.qgw_p_IC;\r\n\r\n    /* SystemInitialize for Product: '<S125>/w' incorporates:\r\n     *  Outport: '<S125>/qgw'\r\n     */\r\n    Time_Varying_Model_2022a_B.w_gw[0] = Time_Varying_Model_2022a_P.qgw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S113>/Hqgw' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S113>/Hrgw' */\r\n    /* InitializeConditions for Integrator: '<S126>/rgw_p' */\r\n    Time_Varying_Model_2022a_X.rgw_p_CSTATE[0] =\r\n      Time_Varying_Model_2022a_P.rgw_p_IC;\r\n\r\n    /* SystemInitialize for Product: '<S126>/w' incorporates:\r\n     *  Outport: '<S126>/rgw'\r\n     */\r\n    Time_Varying_Model_2022a_B.w_g[0] = Time_Varying_Model_2022a_P.rgw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S113>/Hrgw' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S114>/Hugw(s)' */\r\n    /* InitializeConditions for Integrator: '<S127>/ug_p' */\r\n    Time_Varying_Model_2022a_X.ug_p_CSTATE[1] =\r\n      Time_Varying_Model_2022a_P.ug_p_IC;\r\n\r\n    /* SystemInitialize for Product: '<S127>/w1' incorporates:\r\n     *  Outport: '<S127>/ugw'\r\n     */\r\n    Time_Varying_Model_2022a_B.w1_a[1] = Time_Varying_Model_2022a_P.ugw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S114>/Hugw(s)' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S114>/Hvgw(s)' */\r\n    /* InitializeConditions for Integrator: '<S128>/vg_p1' */\r\n    Time_Varying_Model_2022a_X.vg_p1_CSTATE[1] =\r\n      Time_Varying_Model_2022a_P.vg_p1_IC;\r\n\r\n    /* InitializeConditions for Integrator: '<S128>/vgw_p2' */\r\n    Time_Varying_Model_2022a_X.vgw_p2_CSTATE[1] =\r\n      Time_Varying_Model_2022a_P.vgw_p2_IC;\r\n\r\n    /* SystemInitialize for Product: '<S128>/w 1' incorporates:\r\n     *  Outport: '<S128>/vgw'\r\n     */\r\n    Time_Varying_Model_2022a_B.w1[1] = Time_Varying_Model_2022a_P.vgw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S114>/Hvgw(s)' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S114>/Hwgw(s)' */\r\n    /* InitializeConditions for Integrator: '<S129>/wg_p1' */\r\n    Time_Varying_Model_2022a_X.wg_p1_CSTATE[1] =\r\n      Time_Varying_Model_2022a_P.wg_p1_IC;\r\n\r\n    /* InitializeConditions for Integrator: '<S129>/wg_p2' */\r\n    Time_Varying_Model_2022a_X.wg_p2_CSTATE[1] =\r\n      Time_Varying_Model_2022a_P.wg_p2_IC;\r\n\r\n    /* SystemInitialize for Product: '<S129>/Lwg//V 1' incorporates:\r\n     *  Outport: '<S129>/wgw'\r\n     */\r\n    Time_Varying_Model_2022a_B.LwgV1[1] = Time_Varying_Model_2022a_P.wgw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S114>/Hwgw(s)' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S113>/Hpgw' */\r\n    /* InitializeConditions for Integrator: '<S124>/pgw_p' */\r\n    Time_Varying_Model_2022a_X.pgw_p_CSTATE[1] =\r\n      Time_Varying_Model_2022a_P.pgw_p_IC;\r\n\r\n    /* SystemInitialize for Product: '<S124>/sigma_w' incorporates:\r\n     *  Outport: '<S124>/pgw'\r\n     */\r\n    Time_Varying_Model_2022a_B.sigma_w[1] = Time_Varying_Model_2022a_P.pgw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S113>/Hpgw' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S113>/Hqgw' */\r\n    /* InitializeConditions for Integrator: '<S125>/qgw_p' */\r\n    Time_Varying_Model_2022a_X.qgw_p_CSTATE[1] =\r\n      Time_Varying_Model_2022a_P.qgw_p_IC;\r\n\r\n    /* SystemInitialize for Product: '<S125>/w' incorporates:\r\n     *  Outport: '<S125>/qgw'\r\n     */\r\n    Time_Varying_Model_2022a_B.w_gw[1] = Time_Varying_Model_2022a_P.qgw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S113>/Hqgw' */\r\n\r\n    /* SystemInitialize for Enabled SubSystem: '<S113>/Hrgw' */\r\n    /* InitializeConditions for Integrator: '<S126>/rgw_p' */\r\n    Time_Varying_Model_2022a_X.rgw_p_CSTATE[1] =\r\n      Time_Varying_Model_2022a_P.rgw_p_IC;\r\n\r\n    /* SystemInitialize for Product: '<S126>/w' incorporates:\r\n     *  Outport: '<S126>/rgw'\r\n     */\r\n    Time_Varying_Model_2022a_B.w_g[1] = Time_Varying_Model_2022a_P.rgw_Y0;\r\n\r\n    /* End of SystemInitialize for SubSystem: '<S113>/Hrgw' */\r\n  }\r\n}\r\n\r\n/* Model terminate function */\r\nvoid Time_Varying_Model_2022a_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n"},{"name":"Time_Varying_Model_2022a.h","type":"header","group":"model","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Time_Varying_Model_2022a.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Time_Varying_Model_2022a_h_\r\n#define RTW_HEADER_Time_Varying_Model_2022a_h_\r\n#ifndef Time_Varying_Model_2022a_COMMON_INCLUDES_\r\n#define Time_Varying_Model_2022a_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#include \"rt_logging.h\"\r\n#endif                           /* Time_Varying_Model_2022a_COMMON_INCLUDES_ */\r\n\r\n#include \"Time_Varying_Model_2022a_types.h\"\r\n#include \"rt_nonfinite.h\"\r\n#include <string.h>\r\n#include \"rtGetInf.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <float.h>\r\n#include <stddef.h>\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetContStateDisabled\r\n#define rtmGetContStateDisabled(rtm)   ((rtm)->contStateDisabled)\r\n#endif\r\n\r\n#ifndef rtmSetContStateDisabled\r\n#define rtmSetContStateDisabled(rtm, val) ((rtm)->contStateDisabled = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContStates\r\n#define rtmGetContStates(rtm)          ((rtm)->contStates)\r\n#endif\r\n\r\n#ifndef rtmSetContStates\r\n#define rtmSetContStates(rtm, val)     ((rtm)->contStates = (val))\r\n#endif\r\n\r\n#ifndef rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmGetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm) ((rtm)->CTOutputIncnstWithState)\r\n#endif\r\n\r\n#ifndef rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag\r\n#define rtmSetContTimeOutputInconsistentWithStateAtMajorStepFlag(rtm, val) ((rtm)->CTOutputIncnstWithState = (val))\r\n#endif\r\n\r\n#ifndef rtmGetDerivCacheNeedsReset\r\n#define rtmGetDerivCacheNeedsReset(rtm) ((rtm)->derivCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetDerivCacheNeedsReset\r\n#define rtmSetDerivCacheNeedsReset(rtm, val) ((rtm)->derivCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetFinalTime\r\n#define rtmGetFinalTime(rtm)           ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetIntgData\r\n#define rtmGetIntgData(rtm)            ((rtm)->intgData)\r\n#endif\r\n\r\n#ifndef rtmSetIntgData\r\n#define rtmSetIntgData(rtm, val)       ((rtm)->intgData = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeF\r\n#define rtmGetOdeF(rtm)                ((rtm)->odeF)\r\n#endif\r\n\r\n#ifndef rtmSetOdeF\r\n#define rtmSetOdeF(rtm, val)           ((rtm)->odeF = (val))\r\n#endif\r\n\r\n#ifndef rtmGetOdeY\r\n#define rtmGetOdeY(rtm)                ((rtm)->odeY)\r\n#endif\r\n\r\n#ifndef rtmSetOdeY\r\n#define rtmSetOdeY(rtm, val)           ((rtm)->odeY = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateIndices\r\n#define rtmGetPeriodicContStateIndices(rtm) ((rtm)->periodicContStateIndices)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateIndices\r\n#define rtmSetPeriodicContStateIndices(rtm, val) ((rtm)->periodicContStateIndices = (val))\r\n#endif\r\n\r\n#ifndef rtmGetPeriodicContStateRanges\r\n#define rtmGetPeriodicContStateRanges(rtm) ((rtm)->periodicContStateRanges)\r\n#endif\r\n\r\n#ifndef rtmSetPeriodicContStateRanges\r\n#define rtmSetPeriodicContStateRanges(rtm, val) ((rtm)->periodicContStateRanges = (val))\r\n#endif\r\n\r\n#ifndef rtmGetRTWLogInfo\r\n#define rtmGetRTWLogInfo(rtm)          ((rtm)->rtwLogInfo)\r\n#endif\r\n\r\n#ifndef rtmGetZCCacheNeedsReset\r\n#define rtmGetZCCacheNeedsReset(rtm)   ((rtm)->zCCacheNeedsReset)\r\n#endif\r\n\r\n#ifndef rtmSetZCCacheNeedsReset\r\n#define rtmSetZCCacheNeedsReset(rtm, val) ((rtm)->zCCacheNeedsReset = (val))\r\n#endif\r\n\r\n#ifndef rtmGetdX\r\n#define rtmGetdX(rtm)                  ((rtm)->derivs)\r\n#endif\r\n\r\n#ifndef rtmSetdX\r\n#define rtmSetdX(rtm, val)             ((rtm)->derivs = (val))\r\n#endif\r\n\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\r\n#endif\r\n\r\n#ifndef rtmSetStopRequested\r\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\r\n#endif\r\n\r\n#ifndef rtmGetStopRequestedPtr\r\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\r\n#endif\r\n\r\n#ifndef rtmGetT\r\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\r\n#endif\r\n\r\n#ifndef rtmGetTFinal\r\n#define rtmGetTFinal(rtm)              ((rtm)->Timing.tFinal)\r\n#endif\r\n\r\n#ifndef rtmGetTPtr\r\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\r\n#endif\r\n\r\n#ifndef rtmGetTStart\r\n#define rtmGetTStart(rtm)              ((rtm)->Timing.tStart)\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T Integrator4;                  /* '<S16>/Integrator4' */\r\n  real_T Gain;                         /* '<S21>/Gain' */\r\n  real_T Clock;                        /* '<Root>/Clock' */\r\n  real_T OpenRocketVelocity;           /* '<Root>/OpenRocket Velocity' */\r\n  real_T Switch;                       /* '<S15>/Switch' */\r\n  real_T K[24];                        /* '<S9>/Selector' */\r\n  real_T Integrator5;                  /* '<S16>/Integrator5' */\r\n  real_T Integrator3;                  /* '<S16>/Integrator3' */\r\n  real_T Integrator2;                  /* '<S16>/Integrator2' */\r\n  real_T Integrator;                   /* '<S16>/Integrator' */\r\n  real_T Integrator1;                  /* '<S16>/Integrator1' */\r\n  real_T Sum1[6];                      /* '<Root>/Sum1' */\r\n  real_T MatrixMultiply[4];            /* '<Root>/Matrix Multiply' */\r\n  real_T Product[4];                   /* '<Root>/Product' */\r\n  real_T MotorSpeed[4];                /* '<Root>/Motor Speed' */\r\n  real_T MaxDeflection[4];             /* '<Root>/Max Deflection' */\r\n  real_T Gain_j;                       /* '<S22>/Gain' */\r\n  real_T Gain_l;                       /* '<S23>/Gain' */\r\n  real_T Gain_g;                       /* '<S24>/Gain' */\r\n  real_T Gain_f;                       /* '<S25>/Gain' */\r\n  real_T OpenRocketalt;                /* '<Root>/OpenRocket alt' */\r\n  real_T UnitConversion;               /* '<S115>/Unit Conversion' */\r\n  real_T UnitConversion_e;             /* '<S121>/Unit Conversion' */\r\n  real_T LimitFunction10ftto1000ft; /* '<S148>/Limit Function 10ft to 1000ft' */\r\n  real_T LowAltitudeScaleLength;       /* '<S148>/Low Altitude Scale Length' */\r\n  real_T UnitConversion_f;             /* '<S150>/Unit Conversion' */\r\n  real_T LimitHeighth1000ft;           /* '<S131>/Limit Height h<1000ft' */\r\n  real_T LowAltitudeIntensity;         /* '<S131>/Low Altitude Intensity' */\r\n  real_T UnitConversion_g;             /* '<S122>/Unit Conversion' */\r\n  real_T sigma_wg;                     /* '<S131>/sigma_wg ' */\r\n  real_T sigma_ugsigma_vg;             /* '<S131>/sigma_ug, sigma_vg' */\r\n  real_T PreLookUpIndexSearchaltitude_o2;\r\n                              /* '<S130>/PreLook-Up Index Search  (altitude)' */\r\n  real_T PreLookUpIndexSearchprobofexcee;\r\n                        /* '<S130>/PreLook-Up Index Search  (prob of exceed)' */\r\n  real_T MediumHighAltitudeIntensity;\r\n                                  /* '<S130>/Medium//High Altitude Intensity' */\r\n  real_T Sqrt[4];                      /* '<S123>/Sqrt' */\r\n  real_T Sqrt1;                        /* '<S123>/Sqrt1' */\r\n  real_T Divide[4];                    /* '<S123>/Divide' */\r\n  real_T WhiteNoise[4];                /* '<S123>/White Noise' */\r\n  real_T Product_p[4];                 /* '<S123>/Product' */\r\n  real_T Lv[2];                        /* '<S120>/Lv' */\r\n  real_T Lw[2];                        /* '<S120>/Lw' */\r\n  real_T UnitConversion_gl;            /* '<S112>/Unit Conversion' */\r\n  real_T Merge[3];                     /* '<S143>/Merge' */\r\n  real_T UnitConversion_j[3];          /* '<S110>/Unit Conversion' */\r\n  real_T Sum;                          /* '<Root>/Sum' */\r\n  real_T Integrator_o[3];              /* '<S41>/Integrator' */\r\n  real_T airspeedvectoringlobalframe[3];/* '<S1>/Add' */\r\n  real_T Gain_n;                       /* '<S1>/Gain' */\r\n  real_T u2[3];                        /* '<S45>/1//2' */\r\n  real_T sincos_o1[3];                 /* '<S45>/sincos' */\r\n  real_T sincos_o2[3];                 /* '<S45>/sincos' */\r\n  real_T q2;                           /* '<S45>/q2' */\r\n  real_T q0;                           /* '<S45>/q0' */\r\n  real_T Product_e;                    /* '<S51>/Product' */\r\n  real_T q1;                           /* '<S45>/q1' */\r\n  real_T Product1;                     /* '<S51>/Product1' */\r\n  real_T Product2;                     /* '<S51>/Product2' */\r\n  real_T q3;                           /* '<S45>/q3' */\r\n  real_T Product3;                     /* '<S51>/Product3' */\r\n  real_T Sum_l;                        /* '<S51>/Sum' */\r\n  real_T sqrt_e;                       /* '<S50>/sqrt' */\r\n  real_T Product2_m;                   /* '<S46>/Product2' */\r\n  real_T Product6;                     /* '<S47>/Product6' */\r\n  real_T Product3_a;                   /* '<S46>/Product3' */\r\n  real_T Product7;                     /* '<S47>/Product7' */\r\n  real_T Sum3;                         /* '<S47>/Sum3' */\r\n  real_T Gain2;                        /* '<S47>/Gain2' */\r\n  real_T Product8;                     /* '<S47>/Product8' */\r\n  real_T Product1_i;                   /* '<S46>/Product1' */\r\n  real_T Product_a;                    /* '<S47>/Product' */\r\n  real_T Product_f;                    /* '<S46>/Product' */\r\n  real_T Product1_d;                   /* '<S47>/Product1' */\r\n  real_T Sum1_k;                       /* '<S47>/Sum1' */\r\n  real_T Gain_nk;                      /* '<S47>/Gain' */\r\n  real_T Product4;                     /* '<S47>/Product4' */\r\n  real_T Product2_c;                   /* '<S47>/Product2' */\r\n  real_T Product3_h;                   /* '<S47>/Product3' */\r\n  real_T Sum2;                         /* '<S47>/Sum2' */\r\n  real_T Gain1;                        /* '<S47>/Gain1' */\r\n  real_T Product5;                     /* '<S47>/Product5' */\r\n  real_T Sum_a;                        /* '<S47>/Sum' */\r\n  real_T Product_ee;                   /* '<S48>/Product' */\r\n  real_T Product1_b;                   /* '<S48>/Product1' */\r\n  real_T Sum1_f;                       /* '<S48>/Sum1' */\r\n  real_T Gain_p;                       /* '<S48>/Gain' */\r\n  real_T Product4_j;                   /* '<S48>/Product4' */\r\n  real_T Product6_f;                   /* '<S48>/Product6' */\r\n  real_T Product7_h;                   /* '<S48>/Product7' */\r\n  real_T Sum3_a;                       /* '<S48>/Sum3' */\r\n  real_T Gain2_p;                      /* '<S48>/Gain2' */\r\n  real_T Product8_g;                   /* '<S48>/Product8' */\r\n  real_T Product2_b;                   /* '<S48>/Product2' */\r\n  real_T Product3_l;                   /* '<S48>/Product3' */\r\n  real_T Sum2_k;                       /* '<S48>/Sum2' */\r\n  real_T Gain1_l;                      /* '<S48>/Gain1' */\r\n  real_T Product5_a;                   /* '<S48>/Product5' */\r\n  real_T Sum_n;                        /* '<S48>/Sum' */\r\n  real_T Product_d;                    /* '<S49>/Product' */\r\n  real_T Product1_k;                   /* '<S49>/Product1' */\r\n  real_T Sum1_m;                       /* '<S49>/Sum1' */\r\n  real_T Gain_i;                       /* '<S49>/Gain' */\r\n  real_T Product4_n;                   /* '<S49>/Product4' */\r\n  real_T Product2_a;                   /* '<S49>/Product2' */\r\n  real_T Product3_n;                   /* '<S49>/Product3' */\r\n  real_T Sum2_n;                       /* '<S49>/Sum2' */\r\n  real_T Gain1_k;                      /* '<S49>/Gain1' */\r\n  real_T Product5_b;                   /* '<S49>/Product5' */\r\n  real_T Product6_a;                   /* '<S49>/Product6' */\r\n  real_T Product7_l;                   /* '<S49>/Product7' */\r\n  real_T Sum3_p;                       /* '<S49>/Sum3' */\r\n  real_T Gain2_b;                      /* '<S49>/Gain2' */\r\n  real_T Product8_b;                   /* '<S49>/Product8' */\r\n  real_T Sum_ai;                       /* '<S49>/Sum' */\r\n  real_T Gain_gn;                      /* '<S27>/Gain' */\r\n  real_T Gain_lo;                      /* '<S28>/Gain' */\r\n  real_T Gain_ly;                      /* '<S19>/Gain' */\r\n  real_T Gain_b;                       /* '<S20>/Gain' */\r\n  real_T Product_k;                    /* '<S5>/Product' */\r\n  real_T Product1_a;                   /* '<S5>/Product1' */\r\n  real_T OpenRocketMachNo;             /* '<Root>/OpenRocket Mach No' */\r\n  real_T Gain2_j;                      /* '<Root>/Gain2' */\r\n  real_T Product2_j;                   /* '<S5>/Product2' */\r\n  real_T SumofElements;                /* '<S5>/Sum of Elements' */\r\n  real_T SumofElements1;               /* '<S5>/Sum of Elements1' */\r\n  real_T Divide_c;                     /* '<S5>/Divide' */\r\n  real_T Sum4;                         /* '<S8>/Sum4' */\r\n  real_T Sum3_d;                       /* '<S8>/Sum3' */\r\n  real_T Square;                       /* '<S8>/Square' */\r\n  real_T Product_ax;                   /* '<S8>/Product' */\r\n  real_T Sum_b;                        /* '<S8>/Sum' */\r\n  real_T RateTransition1;              /* '<S8>/Rate Transition1' */\r\n  real_T MemoryX;                      /* '<S52>/MemoryX' */\r\n  real_T Add;                          /* '<S80>/Add' */\r\n  real_T Gain3;                        /* '<S8>/Gain3' */\r\n  real_T Akxhatkk1;                    /* '<S73>/A[k]*xhat[k|k-1]' */\r\n  real_T RateTransition;               /* '<S8>/Rate Transition' */\r\n  real_T Bkuk;                         /* '<S73>/B[k]*u[k]' */\r\n  real_T Add_p;                        /* '<S73>/Add' */\r\n  real_T Gain_h;                       /* '<Root>/Gain' */\r\n  real_T OpenRocketI_L;                /* '<Root>/OpenRocket I_L' */\r\n  real_T OpenRocketI_R;                /* '<Root>/OpenRocket I_R' */\r\n  real_T OpenRocketX_CG;               /* '<Root>/OpenRocket X_CG' */\r\n  real_T OpenRocketmDot;               /* '<Root>/OpenRocket mDot' */\r\n  real_T SumofElements1_g;             /* '<Root>/Sum of Elements1' */\r\n  real_T UnitConversion_n;             /* '<S116>/Unit Conversion' */\r\n  real_T Merge_n[3];                   /* '<S135>/Merge' */\r\n  real_T Gain_jr;                      /* '<S26>/Gain' */\r\n  real_T Gain_nq;                      /* '<S30>/Gain' */\r\n  real_T Gain_o;                       /* '<S31>/Gain' */\r\n  real_T Gain_bo;                      /* '<S32>/Gain' */\r\n  real_T Gain_om;                      /* '<S33>/Gain' */\r\n  real_T Sum_j;                        /* '<S2>/Sum' */\r\n  real_T Product_o;                    /* '<S2>/Product' */\r\n  real_T Sum_h;                        /* '<S3>/Sum' */\r\n  real_T Square_g;                     /* '<S3>/Square' */\r\n  real_T Product_m;                    /* '<S3>/Product' */\r\n  real_T Sum1_o;                       /* '<S3>/Sum1' */\r\n  real_T Square1;                      /* '<S3>/Square1' */\r\n  real_T Product1_g;                   /* '<S3>/Product1' */\r\n  real_T Sum2_j;                       /* '<S3>/Sum2' */\r\n  real_T Square2;                      /* '<S3>/Square2' */\r\n  real_T Product2_d;                   /* '<S3>/Product2' */\r\n  real_T Sum3_m;                       /* '<S3>/Sum3' */\r\n  real_T Square3;                      /* '<S3>/Square3' */\r\n  real_T Product3_m;                   /* '<S3>/Product3' */\r\n  real_T SumofElements_g;              /* '<S3>/Sum of Elements' */\r\n  real_T Product4_a;                   /* '<S3>/Product4' */\r\n  real_T Sum4_m;                       /* '<S3>/Sum4' */\r\n  real_T Square4;                      /* '<S3>/Square4' */\r\n  real_T Product5_l;                   /* '<S3>/Product5' */\r\n  real_T Sum5;                         /* '<S3>/Sum5' */\r\n  real_T SumofElements_h;              /* '<S6>/Sum of Elements' */\r\n  real_T Product_p5;                   /* '<S6>/Product' */\r\n  real_T Product_ap;                   /* '<S7>/Product' */\r\n  real_T Gain_c;                       /* '<S17>/Gain' */\r\n  real_T Gain_m;                       /* '<S18>/Gain' */\r\n  real_T Gain_ie;                      /* '<S29>/Gain' */\r\n  real_T Gain_ps;                      /* '<S34>/Gain' */\r\n  real_T Gain_h3;                      /* '<S35>/Gain' */\r\n  real_T Gain_mg;                      /* '<S36>/Gain' */\r\n  real_T Gain_jm;                      /* '<S37>/Gain' */\r\n  real_T Gain_j5;                      /* '<S38>/Gain' */\r\n  real_T Gain_bv;                      /* '<S39>/Gain' */\r\n  real_T Gain_d;                       /* '<S40>/Gain' */\r\n  real_T SumofElements_f;              /* '<S16>/Sum of Elements' */\r\n  real_T SumofElements1_d;             /* '<S16>/Sum of Elements1' */\r\n  real_T DCM[9];                       /* '<S41>/RPY to DCM' */\r\n  real_T TrigonometricFunction_o1;     /* '<S145>/Trigonometric Function' */\r\n  real_T TrigonometricFunction_o2;     /* '<S145>/Trigonometric Function' */\r\n  real_T Product2_jq[2];               /* '<S145>/Product2' */\r\n  real_T Product1_o[2];                /* '<S145>/Product1' */\r\n  real_T VectorConcatenate[3];         /* '<S144>/Vector Concatenate' */\r\n  real_T Product_oc[3];                /* '<S144>/Product' */\r\n  real_T Sum2_np[3];                   /* '<S140>/Sum2' */\r\n  real_T Sum1_kf;                      /* '<S140>/Sum1' */\r\n  real_T Sum_jj;                       /* '<S140>/Sum' */\r\n  real_T Product1_h[3];                /* '<S140>/Product1' */\r\n  real_T TrigonometricFunction_o1_h;   /* '<S147>/Trigonometric Function' */\r\n  real_T TrigonometricFunction_o2_j;   /* '<S147>/Trigonometric Function' */\r\n  real_T Product2_l[2];                /* '<S147>/Product2' */\r\n  real_T Product1_m[2];                /* '<S147>/Product1' */\r\n  real_T VectorConcatenate_b[3];       /* '<S146>/Vector Concatenate' */\r\n  real_T Product_i[3];                 /* '<S146>/Product' */\r\n  real_T TrigonometricFunction_o1_g;   /* '<S137>/Trigonometric Function' */\r\n  real_T TrigonometricFunction_o2_m;   /* '<S137>/Trigonometric Function' */\r\n  real_T Product2_k[2];                /* '<S137>/Product2' */\r\n  real_T Product1_dm[2];               /* '<S137>/Product1' */\r\n  real_T VectorConcatenate_i[3];       /* '<S136>/Vector Concatenate' */\r\n  real_T Product_g[3];                 /* '<S136>/Product' */\r\n  real_T Sum2_f[3];                    /* '<S132>/Sum2' */\r\n  real_T Sum1_p;                       /* '<S132>/Sum1' */\r\n  real_T Sum_d;                        /* '<S132>/Sum' */\r\n  real_T Product1_he[3];               /* '<S132>/Product1' */\r\n  real_T TrigonometricFunction1_o1;    /* '<S139>/Trigonometric Function1' */\r\n  real_T TrigonometricFunction1_o2;    /* '<S139>/Trigonometric Function1' */\r\n  real_T Product2_dy[2];               /* '<S139>/Product2' */\r\n  real_T Product1_if[2];               /* '<S139>/Product1' */\r\n  real_T VectorConcatenate_m[3];       /* '<S138>/Vector Concatenate' */\r\n  real_T Product_dt[3];                /* '<S138>/Product' */\r\n  real_T LwgV[2];                      /* '<S129>/Lwg//V' */\r\n  real_T upi[2];                       /* '<S129>/1//pi' */\r\n  real_T sqrt1[2];                     /* '<S129>/sqrt1' */\r\n  real_T LugV1[2];                     /* '<S129>/Lug//V1' */\r\n  real_T wg_p1[2];                     /* '<S129>/wg_p1' */\r\n  real_T Sum_ht[2];                    /* '<S129>/Sum' */\r\n  real_T w[2];                         /* '<S129>/w' */\r\n  real_T sqrt_d;                       /* '<S129>/sqrt' */\r\n  real_T LwgV_p[2];                    /* '<S129>/Lwg//V ' */\r\n  real_T wg_p2[2];                     /* '<S129>/wg_p2' */\r\n  real_T LwgV1[2];                     /* '<S129>/Lwg//V 1' */\r\n  real_T Sum1_b[2];                    /* '<S129>/Sum1' */\r\n  real_T w_o[2];                       /* '<S129>/w ' */\r\n  real_T LvgV[2];                      /* '<S128>/Lvg//V' */\r\n  real_T upi_h[2];                     /* '<S128>/(1//pi)' */\r\n  real_T sqrt_ew[2];                   /* '<S128>/sqrt' */\r\n  real_T LugV1_c[2];                   /* '<S128>/Lug//V1' */\r\n  real_T vg_p1[2];                     /* '<S128>/vg_p1' */\r\n  real_T Sum_c[2];                     /* '<S128>/Sum' */\r\n  real_T w_l[2];                       /* '<S128>/w' */\r\n  real_T LvgV_n[2];                    /* '<S128>/Lvg//V ' */\r\n  real_T vgw_p2[2];                    /* '<S128>/vgw_p2' */\r\n  real_T sqrt3[2];                     /* '<S128>/sqrt(3)' */\r\n  real_T Sum1_l[2];                    /* '<S128>/Sum1' */\r\n  real_T w_i[2];                       /* '<S128>/w ' */\r\n  real_T w1[2];                        /* '<S128>/w 1' */\r\n  real_T LugV[2];                      /* '<S127>/Lug//V' */\r\n  real_T upi_l[2];                     /* '<S127>/(2//pi)' */\r\n  real_T sqrt_a[2];                    /* '<S127>/sqrt' */\r\n  real_T LugV1_m[2];                   /* '<S127>/Lug//V1' */\r\n  real_T ug_p[2];                      /* '<S127>/ug_p' */\r\n  real_T Sum_i[2];                     /* '<S127>/Sum' */\r\n  real_T w_b[2];                       /* '<S127>/w' */\r\n  real_T w1_a[2];                      /* '<S127>/w1' */\r\n  real_T vgV[2];                       /* '<S126>/vg//V' */\r\n  real_T rgw_p[2];                     /* '<S126>/rgw_p' */\r\n  real_T Sum_bn[2];                    /* '<S126>/Sum' */\r\n  real_T pi3;                          /* '<S126>/pi//3' */\r\n  real_T w_g[2];                       /* '<S126>/w' */\r\n  real_T wgV[2];                       /* '<S125>/wg//V' */\r\n  real_T qgw_p[2];                     /* '<S125>/qgw_p' */\r\n  real_T Sum_m[2];                     /* '<S125>/Sum' */\r\n  real_T pi4;                          /* '<S125>/pi//4' */\r\n  real_T w_gw[2];                      /* '<S125>/w' */\r\n  real_T L13[2];                       /* '<S124>/L^1//3' */\r\n  real_T w4;                           /* '<S124>/w4' */\r\n  real_T u16;                          /* '<S124>/u^1//6' */\r\n  real_T sqrt08V;                      /* '<S124>/sqrt(0.8//V)' */\r\n  real_T w1_k[2];                      /* '<S124>/w1' */\r\n  real_T w2[2];                        /* '<S124>/w2' */\r\n  real_T LugV1_mq[2];                  /* '<S124>/Lug//V1' */\r\n  real_T pgw_p[2];                     /* '<S124>/pgw_p' */\r\n  real_T Sum_b1[2];                    /* '<S124>/Sum' */\r\n  real_T sigma_w[2];                   /* '<S124>/sigma_w' */\r\n  real_T w3;                           /* '<S124>/w3' */\r\n  real_T w_m[2];                       /* '<S124>/w' */\r\n  real_T rDot;                         /* '<S16>/Yaw' */\r\n  real_T Nroll;                        /* '<S16>/Yaw' */\r\n  real_T Ncorr;                        /* '<S16>/Yaw' */\r\n  real_T Ndamp;                        /* '<S16>/Yaw' */\r\n  real_T Ncan;                         /* '<S16>/Yaw' */\r\n  real_T pDot;                         /* '<S16>/Roll' */\r\n  real_T qDot;                         /* '<S16>/Pitch' */\r\n  real_T Mroll;                        /* '<S16>/Pitch' */\r\n  real_T Mcorr;                        /* '<S16>/Pitch' */\r\n  real_T Mcan;                         /* '<S16>/Pitch' */\r\n  real_T Mdamp;                        /* '<S16>/Pitch' */\r\n  real_T rho;                          /* '<Root>/MATLAB Function4' */\r\n  real_T CNa_can;                      /* '<Root>/MATLAB Function3' */\r\n  real_T CNa_body;                     /* '<Root>/MATLAB Function2' */\r\n  real_T CNa_fins;                     /* '<Root>/MATLAB Function1' */\r\n  real_T CNa_nose;                     /* '<Root>/MATLAB Function' */\r\n  real_T Product_n;                    /* '<S106>/Product' */\r\n  real_T Add1;                         /* '<S106>/Add1' */\r\n  real_T Product2_cw;                  /* '<S106>/Product2' */\r\n  real_T Ckxhatkk1;                    /* '<S104>/C[k]*xhat[k|k-1]' */\r\n  real_T Dkuk;                         /* '<S104>/D[k]*u[k]' */\r\n  real_T yhatkk1;                      /* '<S104>/Add1' */\r\n  real_T Sum_e;                        /* '<S104>/Sum' */\r\n  real_T Product3_lw;                  /* '<S104>/Product3' */\r\n  real_T P;                            /* '<S102>/SqrtUsedFcn' */\r\n  real_T TmpSignalConversionAtSFunctionI[3];/* '<S1>/MATLAB Function5' */\r\n  real_T TmpSignalConversionAtSFunctio_d[3];/* '<S1>/MATLAB Function5' */\r\n  real_T windAngles[3];                /* '<S1>/MATLAB Function5' */\r\n  real_T windVector[3];                /* '<S1>/MATLAB Function4' */\r\n  uint32_T PreLookUpIndexSearchaltitude_o1;\r\n                              /* '<S130>/PreLook-Up Index Search  (altitude)' */\r\n  uint32_T PreLookUpIndexSearchprobofexc_m;\r\n                        /* '<S130>/PreLook-Up Index Search  (prob of exceed)' */\r\n  int8_T uDLookupTable;                /* '<S9>/1-D Lookup Table' */\r\n} B_Time_Varying_Model_2022a_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T MemoryX_DSTATE;               /* '<S52>/MemoryX' */\r\n  real_T PrevY[4];                     /* '<Root>/Motor Speed' */\r\n  real_T LastMajorTime;                /* '<Root>/Motor Speed' */\r\n  real_T NextOutput[4];                /* '<S123>/White Noise' */\r\n  real_T RateTransition1_Buffer;       /* '<S8>/Rate Transition1' */\r\n  real_T RateTransition_Buffer;        /* '<S8>/Rate Transition' */\r\n  uint32_T PreLookUpIndexSearchaltitude_DW;\r\n                              /* '<S130>/PreLook-Up Index Search  (altitude)' */\r\n  uint32_T PreLookUpIndexSearchprobofexcee;\r\n                        /* '<S130>/PreLook-Up Index Search  (prob of exceed)' */\r\n  uint32_T RandSeed[4];                /* '<S123>/White Noise' */\r\n  int8_T ifHeightMaxlowaltitudeelseifHei;\r\n  /* '<S119>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' */\r\n  int8_T ifHeightMaxlowaltitudeelseifH_k;\r\n  /* '<S118>/if Height < Max low altitude  elseif Height > Min isotropic altitude ' */\r\n  boolean_T PrevLimited[4];            /* '<Root>/Motor Speed' */\r\n  boolean_T icLoad;                    /* '<S52>/MemoryX' */\r\n  boolean_T Hwgws_MODE;                /* '<S114>/Hwgw(s)' */\r\n  boolean_T Hvgws_MODE;                /* '<S114>/Hvgw(s)' */\r\n  boolean_T Hugws_MODE;                /* '<S114>/Hugw(s)' */\r\n  boolean_T Hrgw_MODE;                 /* '<S113>/Hrgw' */\r\n  boolean_T Hqgw_MODE;                 /* '<S113>/Hqgw' */\r\n  boolean_T Hpgw_MODE;                 /* '<S113>/Hpgw' */\r\n  boolean_T EnabledSubsystem_MODE;     /* '<S80>/Enabled Subsystem' */\r\n  boolean_T MeasurementUpdate_MODE;    /* '<S73>/MeasurementUpdate' */\r\n} DW_Time_Varying_Model_2022a_T;\r\n\r\n/* Continuous states (default storage) */\r\ntypedef struct {\r\n  real_T Integrator4_CSTATE;           /* '<S16>/Integrator4' */\r\n  real_T Integrator5_CSTATE;           /* '<S16>/Integrator5' */\r\n  real_T Integrator3_CSTATE;           /* '<S16>/Integrator3' */\r\n  real_T Integrator2_CSTATE;           /* '<S16>/Integrator2' */\r\n  real_T Integrator_CSTATE;            /* '<S16>/Integrator' */\r\n  real_T Integrator1_CSTATE;           /* '<S16>/Integrator1' */\r\n  real_T Integrator_CSTATE_m[3];       /* '<S41>/Integrator' */\r\n  real_T wg_p1_CSTATE[2];              /* '<S129>/wg_p1' */\r\n  real_T wg_p2_CSTATE[2];              /* '<S129>/wg_p2' */\r\n  real_T vg_p1_CSTATE[2];              /* '<S128>/vg_p1' */\r\n  real_T vgw_p2_CSTATE[2];             /* '<S128>/vgw_p2' */\r\n  real_T ug_p_CSTATE[2];               /* '<S127>/ug_p' */\r\n  real_T rgw_p_CSTATE[2];              /* '<S126>/rgw_p' */\r\n  real_T qgw_p_CSTATE[2];              /* '<S125>/qgw_p' */\r\n  real_T pgw_p_CSTATE[2];              /* '<S124>/pgw_p' */\r\n} X_Time_Varying_Model_2022a_T;\r\n\r\n/* State derivatives (default storage) */\r\ntypedef struct {\r\n  real_T Integrator4_CSTATE;           /* '<S16>/Integrator4' */\r\n  real_T Integrator5_CSTATE;           /* '<S16>/Integrator5' */\r\n  real_T Integrator3_CSTATE;           /* '<S16>/Integrator3' */\r\n  real_T Integrator2_CSTATE;           /* '<S16>/Integrator2' */\r\n  real_T Integrator_CSTATE;            /* '<S16>/Integrator' */\r\n  real_T Integrator1_CSTATE;           /* '<S16>/Integrator1' */\r\n  real_T Integrator_CSTATE_m[3];       /* '<S41>/Integrator' */\r\n  real_T wg_p1_CSTATE[2];              /* '<S129>/wg_p1' */\r\n  real_T wg_p2_CSTATE[2];              /* '<S129>/wg_p2' */\r\n  real_T vg_p1_CSTATE[2];              /* '<S128>/vg_p1' */\r\n  real_T vgw_p2_CSTATE[2];             /* '<S128>/vgw_p2' */\r\n  real_T ug_p_CSTATE[2];               /* '<S127>/ug_p' */\r\n  real_T rgw_p_CSTATE[2];              /* '<S126>/rgw_p' */\r\n  real_T qgw_p_CSTATE[2];              /* '<S125>/qgw_p' */\r\n  real_T pgw_p_CSTATE[2];              /* '<S124>/pgw_p' */\r\n} XDot_Time_Varying_Model_2022a_T;\r\n\r\n/* State disabled  */\r\ntypedef struct {\r\n  boolean_T Integrator4_CSTATE;        /* '<S16>/Integrator4' */\r\n  boolean_T Integrator5_CSTATE;        /* '<S16>/Integrator5' */\r\n  boolean_T Integrator3_CSTATE;        /* '<S16>/Integrator3' */\r\n  boolean_T Integrator2_CSTATE;        /* '<S16>/Integrator2' */\r\n  boolean_T Integrator_CSTATE;         /* '<S16>/Integrator' */\r\n  boolean_T Integrator1_CSTATE;        /* '<S16>/Integrator1' */\r\n  boolean_T Integrator_CSTATE_m[3];    /* '<S41>/Integrator' */\r\n  boolean_T wg_p1_CSTATE[2];           /* '<S129>/wg_p1' */\r\n  boolean_T wg_p2_CSTATE[2];           /* '<S129>/wg_p2' */\r\n  boolean_T vg_p1_CSTATE[2];           /* '<S128>/vg_p1' */\r\n  boolean_T vgw_p2_CSTATE[2];          /* '<S128>/vgw_p2' */\r\n  boolean_T ug_p_CSTATE[2];            /* '<S127>/ug_p' */\r\n  boolean_T rgw_p_CSTATE[2];           /* '<S126>/rgw_p' */\r\n  boolean_T qgw_p_CSTATE[2];           /* '<S125>/qgw_p' */\r\n  boolean_T pgw_p_CSTATE[2];           /* '<S124>/pgw_p' */\r\n} XDis_Time_Varying_Model_2022a_T;\r\n\r\n#ifndef ODE3_INTG\r\n#define ODE3_INTG\r\n\r\n/* ODE3 Integration Data */\r\ntypedef struct {\r\n  real_T *y;                           /* output */\r\n  real_T *f[3];                        /* derivatives */\r\n} ODE3_IntgData;\r\n\r\n#endif\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T pitchAngle;                   /* '<Root>/thetaOut' */\r\n  real_T x1;                           /* '<Root>/x1Out' */\r\n  real_T x2;                           /* '<Root>/x2Out' */\r\n  real_T y1;                           /* '<Root>/y1Out' */\r\n  real_T y2;                           /* '<Root>/y2Out' */\r\n  real_T v;                            /* '<Root>/vOut' */\r\n  real_T yawAngle;                     /* '<Root>/psiOut' */\r\n  real_T airspeed_x;                   /* '<Root>/airspeed_x' */\r\n  real_T airspeed_y;                   /* '<Root>/airspeed_y' */\r\n  real_T airspeed_z;                   /* '<Root>/airspeed_z' */\r\n  real_T alpha;                        /* '<Root>/alphaOut' */\r\n  real_T beta;                         /* '<Root>/betaOut' */\r\n  real_T pOut;                         /* '<Root>/pOut' */\r\n  real_T qOut;                         /* '<Root>/qOut' */\r\n  real_T rOut;                         /* '<Root>/rOut' */\r\n  real_T rollAngle;                    /* '<Root>/phiOut' */\r\n} ExtY_Time_Varying_Model_2022a_T;\r\n\r\n/* Parameters (default storage) */\r\nstruct P_Time_Varying_Model_2022a_T_ {\r\n  real_T DrydenWindTurbulenceModelContin;\r\n                              /* Mask Parameter: DrydenWindTurbulenceModelContin\r\n                               * Referenced by: '<S149>/Medium//High Altitude'\r\n                               */\r\n  real_T DrydenWindTurbulenceModelCont_a[4];\r\n                              /* Mask Parameter: DrydenWindTurbulenceModelCont_a\r\n                               * Referenced by: '<S123>/White Noise'\r\n                               */\r\n  real_T DrydenWindTurbulenceModelCont_c;\r\n                              /* Mask Parameter: DrydenWindTurbulenceModelCont_c\r\n                               * Referenced by:\r\n                               *   '<S113>/Constant1'\r\n                               *   '<S113>/Constant2'\r\n                               *   '<S113>/Constant3'\r\n                               *   '<S114>/Constant'\r\n                               */\r\n  real_T WhiteNoise_Ts;                /* Mask Parameter: WhiteNoise_Ts\r\n                                        * Referenced by: '<S123>/Constant1'\r\n                                        */\r\n  real_T DrydenWindTurbulenceModelCon_au;\r\n                              /* Mask Parameter: DrydenWindTurbulenceModelCon_au\r\n                               * Referenced by: '<S130>/Probability of  Exceedance'\r\n                               */\r\n  real_T DrydenWindTurbulenceModelCont_i;\r\n                              /* Mask Parameter: DrydenWindTurbulenceModelCont_i\r\n                               * Referenced by: '<S110>/Windspeed at 20ft (6m)'\r\n                               */\r\n  real_T DrydenWindTurbulenceModelCont_m;\r\n                              /* Mask Parameter: DrydenWindTurbulenceModelCont_m\r\n                               * Referenced by: '<S110>/Wind direction'\r\n                               */\r\n  real_T DrydenWindTurbulenceModelCont_j;\r\n                              /* Mask Parameter: DrydenWindTurbulenceModelCont_j\r\n                               * Referenced by: '<S110>/Wingspan'\r\n                               */\r\n  real_T WhiteNoise_pwr[4];            /* Mask Parameter: WhiteNoise_pwr\r\n                                        * Referenced by: '<S123>/Constant'\r\n                                        */\r\n  real_T Lykyhatkk1_Y0;                /* Expression: 0\r\n                                        * Referenced by: '<S104>/L*(y[k]-yhat[k|k-1])'\r\n                                        */\r\n  real_T deltax_Y0;                    /* Expression: 0\r\n                                        * Referenced by: '<S106>/deltax'\r\n                                        */\r\n  real_T pgw_Y0;                       /* Expression: 0\r\n                                        * Referenced by: '<S124>/pgw'\r\n                                        */\r\n  real_T Constant1_Value;              /* Expression: 1/3\r\n                                        * Referenced by: '<S124>/Constant1'\r\n                                        */\r\n  real_T Constant2_Value;              /* Expression: 1/6\r\n                                        * Referenced by: '<S124>/Constant2'\r\n                                        */\r\n  real_T Constant3_Value;              /* Expression: pi/4\r\n                                        * Referenced by: '<S124>/Constant3'\r\n                                        */\r\n  real_T pgw_p_IC;                     /* Expression: 0\r\n                                        * Referenced by: '<S124>/pgw_p'\r\n                                        */\r\n  real_T qgw_Y0;                       /* Expression: 0\r\n                                        * Referenced by: '<S125>/qgw'\r\n                                        */\r\n  real_T qgw_p_IC;                     /* Expression: 0\r\n                                        * Referenced by: '<S125>/qgw_p'\r\n                                        */\r\n  real_T pi4_Gain;                     /* Expression: pi/4\r\n                                        * Referenced by: '<S125>/pi//4'\r\n                                        */\r\n  real_T rgw_Y0;                       /* Expression: 0\r\n                                        * Referenced by: '<S126>/rgw'\r\n                                        */\r\n  real_T rgw_p_IC;                     /* Expression: 0\r\n                                        * Referenced by: '<S126>/rgw_p'\r\n                                        */\r\n  real_T pi3_Gain;                     /* Expression: pi/3\r\n                                        * Referenced by: '<S126>/pi//3'\r\n                                        */\r\n  real_T ugw_Y0;                       /* Expression: 0\r\n                                        * Referenced by: '<S127>/ugw'\r\n                                        */\r\n  real_T upi_Gain;                     /* Expression: 2/pi\r\n                                        * Referenced by: '<S127>/(2//pi)'\r\n                                        */\r\n  real_T ug_p_IC;                      /* Expression: 0\r\n                                        * Referenced by: '<S127>/ug_p'\r\n                                        */\r\n  real_T vgw_Y0;                       /* Expression: 0\r\n                                        * Referenced by: '<S128>/vgw'\r\n                                        */\r\n  real_T upi_Gain_m;                   /* Expression: 1/pi\r\n                                        * Referenced by: '<S128>/(1//pi)'\r\n                                        */\r\n  real_T vg_p1_IC;                     /* Expression: 0\r\n                                        * Referenced by: '<S128>/vg_p1'\r\n                                        */\r\n  real_T vgw_p2_IC;                    /* Expression: 0\r\n                                        * Referenced by: '<S128>/vgw_p2'\r\n                                        */\r\n  real_T sqrt3_Gain;                   /* Expression: sqrt(3)\r\n                                        * Referenced by: '<S128>/sqrt(3)'\r\n                                        */\r\n  real_T wgw_Y0;                       /* Expression: 0\r\n                                        * Referenced by: '<S129>/wgw'\r\n                                        */\r\n  real_T upi_Gain_l;                   /* Expression: 1/pi\r\n                                        * Referenced by: '<S129>/1//pi'\r\n                                        */\r\n  real_T Constant_Value;               /* Expression: 3\r\n                                        * Referenced by: '<S129>/Constant'\r\n                                        */\r\n  real_T wg_p1_IC;                     /* Expression: 0\r\n                                        * Referenced by: '<S129>/wg_p1'\r\n                                        */\r\n  real_T wg_p2_IC;                     /* Expression: 0\r\n                                        * Referenced by: '<S129>/wg_p2'\r\n                                        */\r\n  real_T Gain_Gain;                    /* Expression: 1\r\n                                        * Referenced by: '<S134>/Gain'\r\n                                        */\r\n  real_T max_height_low_Value;         /* Expression: max_height_low\r\n                                        * Referenced by: '<S132>/max_height_low'\r\n                                        */\r\n  real_T min_height_high_Value;        /* Expression: min_height_high\r\n                                        * Referenced by: '<S132>/min_height_high'\r\n                                        */\r\n  real_T Gain_Gain_o;                  /* Expression: 1\r\n                                        * Referenced by: '<S142>/Gain'\r\n                                        */\r\n  real_T max_height_low_Value_l;       /* Expression: max_height_low\r\n                                        * Referenced by: '<S140>/max_height_low'\r\n                                        */\r\n  real_T min_height_high_Value_h;      /* Expression: min_height_high\r\n                                        * Referenced by: '<S140>/min_height_high'\r\n                                        */\r\n  real_T Integrator4_IC;               /* Expression: 0\r\n                                        * Referenced by: '<S16>/Integrator4'\r\n                                        */\r\n  real_T Gain_Gain_h;                  /* Expression: 180/pi\r\n                                        * Referenced by: '<S21>/Gain'\r\n                                        */\r\n  real_T Constant_Value_j;             /* Expression: 1\r\n                                        * Referenced by: '<S15>/Constant'\r\n                                        */\r\n  real_T OpenRocketVelocity_tableData[223];/* Expression: OR.v\r\n                                            * Referenced by: '<Root>/OpenRocket Velocity'\r\n                                            */\r\n  real_T OpenRocketVelocity_bp01Data[223];/* Expression: OR.t\r\n                                           * Referenced by: '<Root>/OpenRocket Velocity'\r\n                                           */\r\n  real_T Constant1_Value_p;            /* Expression: 0\r\n                                        * Referenced by: '<S15>/Constant1'\r\n                                        */\r\n  real_T Switch_Threshold;             /* Expression: controller.minControlSpeed\r\n                                        * Referenced by: '<S15>/Switch'\r\n                                        */\r\n  real_T Constant_Value_l[1200];       /* Expression: controller.K\r\n                                        * Referenced by: '<S9>/Constant'\r\n                                        */\r\n  real_T uDLookupTable_bp01Data[50];   /* Expression: controller.velocities\r\n                                        * Referenced by: '<S9>/1-D Lookup Table'\r\n                                        */\r\n  real_T phi_Value;                    /* Expression: 0\r\n                                        * Referenced by: '<Root>/phi'\r\n                                        */\r\n  real_T theta_Value;                  /* Expression: 0\r\n                                        * Referenced by: '<Root>/theta'\r\n                                        */\r\n  real_T psi_Value;                    /* Expression: 0\r\n                                        * Referenced by: '<Root>/psi'\r\n                                        */\r\n  real_T p_Value;                      /* Expression: 0\r\n                                        * Referenced by: '<Root>/p'\r\n                                        */\r\n  real_T q_Value;                      /* Expression: 0\r\n                                        * Referenced by: '<Root>/q'\r\n                                        */\r\n  real_T r_Value;                      /* Expression: 0\r\n                                        * Referenced by: '<Root>/r'\r\n                                        */\r\n  real_T Integrator5_IC;               /* Expression: 0\r\n                                        * Referenced by: '<S16>/Integrator5'\r\n                                        */\r\n  real_T Integrator3_IC;               /* Expression: 0\r\n                                        * Referenced by: '<S16>/Integrator3'\r\n                                        */\r\n  real_T Integrator2_IC;               /* Expression: 0\r\n                                        * Referenced by: '<S16>/Integrator2'\r\n                                        */\r\n  real_T Integrator_IC;                /* Expression: 0\r\n                                        * Referenced by: '<S16>/Integrator'\r\n                                        */\r\n  real_T Integrator1_IC;               /* Expression: 0\r\n                                        * Referenced by: '<S16>/Integrator1'\r\n                                        */\r\n  real_T MotorSpeed_RisingLim;         /* Expression: 3.27\r\n                                        * Referenced by: '<Root>/Motor Speed'\r\n                                        */\r\n  real_T MotorSpeed_FallingLim;        /* Expression: -3.27\r\n                                        * Referenced by: '<Root>/Motor Speed'\r\n                                        */\r\n  real_T MaxDeflection_UpperSat;       /* Expression: 0.23\r\n                                        * Referenced by: '<Root>/Max Deflection'\r\n                                        */\r\n  real_T MaxDeflection_LowerSat;       /* Expression: -0.23\r\n                                        * Referenced by: '<Root>/Max Deflection'\r\n                                        */\r\n  real_T Gain_Gain_i;                  /* Expression: 180/pi\r\n                                        * Referenced by: '<S22>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_oo;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S23>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_p;                  /* Expression: 180/pi\r\n                                        * Referenced by: '<S24>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_f;                  /* Expression: 180/pi\r\n                                        * Referenced by: '<S25>/Gain'\r\n                                        */\r\n  real_T OpenRocketalt_tableData[223]; /* Expression: OR.h\r\n                                        * Referenced by: '<Root>/OpenRocket alt'\r\n                                        */\r\n  real_T OpenRocketalt_bp01Data[223];  /* Expression: OR.t\r\n                                        * Referenced by: '<Root>/OpenRocket alt'\r\n                                        */\r\n  real_T LimitFunction10ftto1000ft_Upper;/* Expression: max_height_low\r\n                                          * Referenced by: '<S148>/Limit Function 10ft to 1000ft'\r\n                                          */\r\n  real_T LimitFunction10ftto1000ft_Lower;/* Expression: 10\r\n                                          * Referenced by: '<S148>/Limit Function 10ft to 1000ft'\r\n                                          */\r\n  real_T LimitHeighth1000ft_UpperSat;  /* Expression: max_height_low\r\n                                        * Referenced by: '<S131>/Limit Height h<1000ft'\r\n                                        */\r\n  real_T LimitHeighth1000ft_LowerSat;  /* Expression: 0\r\n                                        * Referenced by: '<S131>/Limit Height h<1000ft'\r\n                                        */\r\n  real_T sigma_wg_Gain;                /* Expression: 0.1\r\n                                        * Referenced by: '<S131>/sigma_wg '\r\n                                        */\r\n  real_T PreLookUpIndexSearchaltitude_Br[12];/* Expression: h_vec\r\n                                              * Referenced by: '<S130>/PreLook-Up Index Search  (altitude)'\r\n                                              */\r\n  real_T PreLookUpIndexSearchprobofexcee[7];/* Expression: [1:7]\r\n                                             * Referenced by: '<S130>/PreLook-Up Index Search  (prob of exceed)'\r\n                                             */\r\n  real_T MediumHighAltitudeIntensity_Tab[84];/* Expression: sigma_vec'\r\n                                              * Referenced by: '<S130>/Medium//High Altitude Intensity'\r\n                                              */\r\n  real_T WhiteNoise_Mean;              /* Expression: 0\r\n                                        * Referenced by: '<S123>/White Noise'\r\n                                        */\r\n  real_T WhiteNoise_StdDev;            /* Computed Parameter: WhiteNoise_StdDev\r\n                                        * Referenced by: '<S123>/White Noise'\r\n                                        */\r\n  real_T Lv_Gain;                      /* Expression: 1\r\n                                        * Referenced by: '<S120>/Lv'\r\n                                        */\r\n  real_T Lw_Gain;                      /* Expression: 1\r\n                                        * Referenced by: '<S120>/Lw'\r\n                                        */\r\n  real_T Windspeed_Value;              /* Expression: 5.00\r\n                                        * Referenced by: '<Root>/Windspeed'\r\n                                        */\r\n  real_T Integrator_IC_d;              /* Expression: 0\r\n                                        * Referenced by: '<S41>/Integrator'\r\n                                        */\r\n  real_T Constant1_Value_a;            /* Expression: 0\r\n                                        * Referenced by: '<S1>/Constant1'\r\n                                        */\r\n  real_T Gain_Gain_e;                  /* Expression: -1\r\n                                        * Referenced by: '<S1>/Gain'\r\n                                        */\r\n  real_T u2_Gain;                      /* Expression: 0.5\r\n                                        * Referenced by: '<S45>/1//2'\r\n                                        */\r\n  real_T Constant_Value_lw;            /* Expression: 0.5\r\n                                        * Referenced by: '<S47>/Constant'\r\n                                        */\r\n  real_T Gain2_Gain;                   /* Expression: 2\r\n                                        * Referenced by: '<S47>/Gain2'\r\n                                        */\r\n  real_T Gain_Gain_k;                  /* Expression: 2\r\n                                        * Referenced by: '<S47>/Gain'\r\n                                        */\r\n  real_T Gain1_Gain;                   /* Expression: 2\r\n                                        * Referenced by: '<S47>/Gain1'\r\n                                        */\r\n  real_T Gain_Gain_ev;                 /* Expression: 2\r\n                                        * Referenced by: '<S48>/Gain'\r\n                                        */\r\n  real_T Constant_Value_o;             /* Expression: 0.5\r\n                                        * Referenced by: '<S48>/Constant'\r\n                                        */\r\n  real_T Gain2_Gain_o;                 /* Expression: 2\r\n                                        * Referenced by: '<S48>/Gain2'\r\n                                        */\r\n  real_T Gain1_Gain_d;                 /* Expression: 2\r\n                                        * Referenced by: '<S48>/Gain1'\r\n                                        */\r\n  real_T Gain_Gain_ob;                 /* Expression: 2\r\n                                        * Referenced by: '<S49>/Gain'\r\n                                        */\r\n  real_T Gain1_Gain_k;                 /* Expression: 2\r\n                                        * Referenced by: '<S49>/Gain1'\r\n                                        */\r\n  real_T Constant_Value_f;             /* Expression: 0.5\r\n                                        * Referenced by: '<S49>/Constant'\r\n                                        */\r\n  real_T Gain2_Gain_a;                 /* Expression: 2\r\n                                        * Referenced by: '<S49>/Gain2'\r\n                                        */\r\n  real_T Constant_Value_ji;            /* Expression: 1\r\n                                        * Referenced by: '<S1>/Constant'\r\n                                        */\r\n  real_T Constant16_Value;             /* Expression: 0\r\n                                        * Referenced by: '<S1>/Constant16'\r\n                                        */\r\n  real_T Gain_Gain_fn;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S27>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_kf;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S28>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_ou;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S19>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_d;                  /* Expression: 180/pi\r\n                                        * Referenced by: '<S20>/Gain'\r\n                                        */\r\n  real_T Constant6_Value;              /* Expression: aptos.A_ref\r\n                                        * Referenced by: '<Root>/Constant6'\r\n                                        */\r\n  real_T Constant32_Value;             /* Expression: 0\r\n                                        * Referenced by: '<Root>/Constant32'\r\n                                        */\r\n  real_T Constant33_Value;             /* Expression: aptos.A_plan_nose\r\n                                        * Referenced by: '<Root>/Constant33'\r\n                                        */\r\n  real_T Constant34_Value;             /* Expression: aptos.K_const\r\n                                        * Referenced by: '<Root>/Constant34'\r\n                                        */\r\n  real_T Constant22_Value;             /* Expression: aptos.CP_nose\r\n                                        * Referenced by: '<Root>/Constant22'\r\n                                        */\r\n  real_T Constant35_Value;             /* Expression: aptos.A_plan_body\r\n                                        * Referenced by: '<Root>/Constant35'\r\n                                        */\r\n  real_T Constant36_Value;             /* Expression: aptos.K_const\r\n                                        * Referenced by: '<Root>/Constant36'\r\n                                        */\r\n  real_T Constant23_Value;             /* Expression: aptos.CP_body\r\n                                        * Referenced by: '<Root>/Constant23'\r\n                                        */\r\n  real_T Constant39_Value;             /* Expression: aptos.ss_fin\r\n                                        * Referenced by: '<Root>/Constant39'\r\n                                        */\r\n  real_T OpenRocketMachNo_tableData[223];/* Expression: OR.M\r\n                                          * Referenced by: '<Root>/OpenRocket Mach No'\r\n                                          */\r\n  real_T OpenRocketMachNo_bp01Data[223];/* Expression: OR.t\r\n                                         * Referenced by: '<Root>/OpenRocket Mach No'\r\n                                         */\r\n  real_T Constant40_Value;             /* Expression: aptos.S_fin\r\n                                        * Referenced by: '<Root>/Constant40'\r\n                                        */\r\n  real_T Constant41_Value;             /* Expression: aptos.G_c_fin\r\n                                        * Referenced by: '<Root>/Constant41'\r\n                                        */\r\n  real_T Constant11_Value;             /* Expression: aptos.d_body\r\n                                        * Referenced by: '<Root>/Constant11'\r\n                                        */\r\n  real_T Gain2_Gain_a5;                /* Expression: 0.5\r\n                                        * Referenced by: '<Root>/Gain2'\r\n                                        */\r\n  real_T Constant24_Value;             /* Expression: aptos.CP_fins\r\n                                        * Referenced by: '<Root>/Constant24'\r\n                                        */\r\n  real_T KalmanGainM_Value;            /* Expression: pInitialization.M\r\n                                        * Referenced by: '<S53>/KalmanGainM'\r\n                                        */\r\n  real_T C_Value;                      /* Expression: pInitialization.C\r\n                                        * Referenced by: '<S52>/C'\r\n                                        */\r\n  real_T X0_Value;                     /* Expression: pInitialization.X0\r\n                                        * Referenced by: '<S52>/X0'\r\n                                        */\r\n  real_T Gain3_Gain;                   /* Expression: 0.5\r\n                                        * Referenced by: '<S8>/Gain3'\r\n                                        */\r\n  real_T A_Value;                      /* Expression: pInitialization.A\r\n                                        * Referenced by: '<S52>/A'\r\n                                        */\r\n  real_T B_Value;                      /* Expression: pInitialization.B\r\n                                        * Referenced by: '<S52>/B'\r\n                                        */\r\n  real_T CovarianceZ_Value;            /* Expression: pInitialization.Z\r\n                                        * Referenced by: '<S53>/CovarianceZ'\r\n                                        */\r\n  real_T KalmanGainL_Value;            /* Expression: pInitialization.L\r\n                                        * Referenced by: '<S53>/KalmanGainL'\r\n                                        */\r\n  real_T D_Value;                      /* Expression: pInitialization.D\r\n                                        * Referenced by: '<S52>/D'\r\n                                        */\r\n  real_T Constant25_Value;             /* Expression: aptos.X_CP_can\r\n                                        * Referenced by: '<Root>/Constant25'\r\n                                        */\r\n  real_T Constant28_Value;             /* Expression: aptos.S_can\r\n                                        * Referenced by: '<Root>/Constant28'\r\n                                        */\r\n  real_T Constant37_Value;             /* Expression: aptos.ss_can\r\n                                        * Referenced by: '<Root>/Constant37'\r\n                                        */\r\n  real_T Constant38_Value;             /* Expression: aptos.G_c_can\r\n                                        * Referenced by: '<Root>/Constant38'\r\n                                        */\r\n  real_T Gain_Gain_du;                 /* Expression: 0.5\r\n                                        * Referenced by: '<Root>/Gain'\r\n                                        */\r\n  real_T OpenRocketI_L_tableData[223]; /* Expression: OR.I_L\r\n                                        * Referenced by: '<Root>/OpenRocket I_L'\r\n                                        */\r\n  real_T OpenRocketI_L_bp01Data[223];  /* Expression: OR.t\r\n                                        * Referenced by: '<Root>/OpenRocket I_L'\r\n                                        */\r\n  real_T OpenRocketI_R_tableData[223]; /* Expression: OR.I_R\r\n                                        * Referenced by: '<Root>/OpenRocket I_R'\r\n                                        */\r\n  real_T OpenRocketI_R_bp01Data[223];  /* Expression: OR.t\r\n                                        * Referenced by: '<Root>/OpenRocket I_R'\r\n                                        */\r\n  real_T OpenRocketX_CG_tableData[223];/* Expression: OR.X_CG\r\n                                        * Referenced by: '<Root>/OpenRocket X_CG'\r\n                                        */\r\n  real_T OpenRocketX_CG_bp01Data[223]; /* Expression: OR.t\r\n                                        * Referenced by: '<Root>/OpenRocket X_CG'\r\n                                        */\r\n  real_T OpenRocketmDot_tableData[223];/* Expression: OR.mDot\r\n                                        * Referenced by: '<Root>/OpenRocket mDot'\r\n                                        */\r\n  real_T OpenRocketmDot_bp01Data[223]; /* Expression: OR.t\r\n                                        * Referenced by: '<Root>/OpenRocket mDot'\r\n                                        */\r\n  real_T Gain_Gain_c;                  /* Expression: 180/pi\r\n                                        * Referenced by: '<S26>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_n;                  /* Expression: 180/pi\r\n                                        * Referenced by: '<S30>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_f5;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S31>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_m;                  /* Expression: 180/pi\r\n                                        * Referenced by: '<S32>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_l;                  /* Expression: 180/pi\r\n                                        * Referenced by: '<S33>/Gain'\r\n                                        */\r\n  real_T Constant_Value_fq;            /* Expression: 0.5\r\n                                        * Referenced by: '<S3>/Constant'\r\n                                        */\r\n  real_T Constant1_Value_o;            /* Expression: aptos.X_T\r\n                                        * Referenced by: '<S3>/Constant1'\r\n                                        */\r\n  real_T Constant7_Value;              /* Expression: aptos.N\r\n                                        * Referenced by: '<Root>/Constant7'\r\n                                        */\r\n  real_T Constant12_Value;             /* Expression: aptos.yMAC\r\n                                        * Referenced by: '<Root>/Constant12'\r\n                                        */\r\n  real_T Constant13_Value;             /* Expression: aptos.rt\r\n                                        * Referenced by: '<Root>/Constant13'\r\n                                        */\r\n  real_T Constant8_Value;              /* Expression: aptos.CNa_1\r\n                                        * Referenced by: '<Root>/Constant8'\r\n                                        */\r\n  real_T Constant_Value_k;             /* Expression: 0.5\r\n                                        * Referenced by: '<S7>/Constant'\r\n                                        */\r\n  real_T Constant9_Value;              /* Expression: aptos.CNa0\r\n                                        * Referenced by: '<Root>/Constant9'\r\n                                        */\r\n  real_T Constant10_Value;             /* Expression: aptos.sumTerm\r\n                                        * Referenced by: '<Root>/Constant10'\r\n                                        */\r\n  real_T Gain_Gain_cc;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S17>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_eq;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S18>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_cj;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S29>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_ho;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S34>/Gain'\r\n                                        */\r\n  real_T Constant26_Value;             /* Expression: aptos.Y_CP_can\r\n                                        * Referenced by: '<Root>/Constant26'\r\n                                        */\r\n  real_T Constant27_Value;             /* Expression: aptos.Z_CP_can\r\n                                        * Referenced by: '<Root>/Constant27'\r\n                                        */\r\n  real_T Constant30_Value;             /* Expression: aptos.Xbar_CP_can\r\n                                        * Referenced by: '<Root>/Constant30'\r\n                                        */\r\n  real_T Constant31_Value;             /* Expression: aptos.CLa\r\n                                        * Referenced by: '<Root>/Constant31'\r\n                                        */\r\n  real_T Gain_Gain_kh;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S35>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_d3;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S36>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_mv;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S37>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_di;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S38>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_g;                  /* Expression: 180/pi\r\n                                        * Referenced by: '<S39>/Gain'\r\n                                        */\r\n  real_T Gain_Gain_g4;                 /* Expression: 180/pi\r\n                                        * Referenced by: '<S40>/Gain'\r\n                                        */\r\n  real_T Rearfincant_Value;            /* Expression: 0\r\n                                        * Referenced by: '<S16>/Rear fin cant'\r\n                                        */\r\n  uint32_T MediumHighAltitudeIntensity_max[2];\r\n                          /* Computed Parameter: MediumHighAltitudeIntensity_max\r\n                           * Referenced by: '<S130>/Medium//High Altitude Intensity'\r\n                           */\r\n  boolean_T Enable_Value;              /* Expression: true()\r\n                                        * Referenced by: '<S52>/Enable'\r\n                                        */\r\n  boolean_T isSqrtUsed_Value;          /* Expression: pInitialization.isSqrtUsed\r\n                                        * Referenced by: '<S102>/isSqrtUsed'\r\n                                        */\r\n  int8_T uDLookupTable_tableData[50];\r\n                                  /* Computed Parameter: uDLookupTable_tableData\r\n                                   * Referenced by: '<S9>/1-D Lookup Table'\r\n                                   */\r\n};\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_Time_Varying_Model_20_T {\r\n  const char_T *errorStatus;\r\n  RTWLogInfo *rtwLogInfo;\r\n  RTWSolverInfo solverInfo;\r\n  X_Time_Varying_Model_2022a_T *contStates;\r\n  int_T *periodicContStateIndices;\r\n  real_T *periodicContStateRanges;\r\n  real_T *derivs;\r\n  XDis_Time_Varying_Model_2022a_T *contStateDisabled;\r\n  boolean_T zCCacheNeedsReset;\r\n  boolean_T derivCacheNeedsReset;\r\n  boolean_T CTOutputIncnstWithState;\r\n  real_T odeY[25];\r\n  real_T odeF[3][25];\r\n  ODE3_IntgData intgData;\r\n\r\n  /*\r\n   * Sizes:\r\n   * The following substructure contains sizes information\r\n   * for many of the model attributes such as inputs, outputs,\r\n   * dwork, sample times, etc.\r\n   */\r\n  struct {\r\n    int_T numContStates;\r\n    int_T numPeriodicContStates;\r\n    int_T numSampTimes;\r\n  } Sizes;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n    uint32_T clockTickH0;\r\n    time_T stepSize0;\r\n    uint32_T clockTick1;\r\n    uint32_T clockTickH1;\r\n    struct {\r\n      uint16_T TID[4];\r\n    } TaskCounters;\r\n\r\n    time_T tStart;\r\n    time_T tFinal;\r\n    SimTimeStep simTimeStep;\r\n    boolean_T stopRequestedFlag;\r\n    time_T *t;\r\n    time_T tArray[4];\r\n  } Timing;\r\n};\r\n\r\n/* Block parameters (default storage) */\r\nextern P_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_P;\r\n\r\n/* Block signals (default storage) */\r\nextern B_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_B;\r\n\r\n/* Continuous states (default storage) */\r\nextern X_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_X;\r\n\r\n/* Disabled states (default storage) */\r\nextern XDis_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_XDis;\r\n\r\n/* Block states (default storage) */\r\nextern DW_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_DW;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_Y;\r\n\r\n/* Model entry point functions */\r\nextern void Time_Varying_Model_2022a_initialize(void);\r\nextern void Time_Varying_Model_2022a_step(void);\r\nextern void Time_Varying_Model_2022a_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_Time_Varying_Model_2_T *const Time_Varying_Model_2022a_M;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S1>/Display' : Unused code path elimination\r\n * Block '<S1>/Display1' : Unused code path elimination\r\n * Block '<S1>/Display2' : Unused code path elimination\r\n * Block '<S1>/Display3' : Unused code path elimination\r\n * Block '<S1>/Display4' : Unused code path elimination\r\n * Block '<S4>/Divide' : Unused code path elimination\r\n * Block '<S4>/Product' : Unused code path elimination\r\n * Block '<S4>/Product1' : Unused code path elimination\r\n * Block '<S4>/Product2' : Unused code path elimination\r\n * Block '<S4>/Product3' : Unused code path elimination\r\n * Block '<S4>/Sum of Elements' : Unused code path elimination\r\n * Block '<S4>/Sum of Elements1' : Unused code path elimination\r\n * Block '<S96>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S97>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S98>/Conversion' : Unused code path elimination\r\n * Block '<S98>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S99>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S56>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S57>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S58>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S59>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S61>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S62>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S63>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S64>/Conversion' : Unused code path elimination\r\n * Block '<S64>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S65>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S66>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S67>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S69>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S70>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S52>/G' : Unused code path elimination\r\n * Block '<S52>/H' : Unused code path elimination\r\n * Block '<S52>/N' : Unused code path elimination\r\n * Block '<S52>/P0' : Unused code path elimination\r\n * Block '<S52>/Q' : Unused code path elimination\r\n * Block '<S52>/R' : Unused code path elimination\r\n * Block '<S94>/CheckSignalProperties' : Unused code path elimination\r\n * Block '<S95>/CheckSignalProperties' : Unused code path elimination\r\n * Block '<Root>/Display' : Unused code path elimination\r\n * Block '<Root>/Display1' : Unused code path elimination\r\n * Block '<Root>/Display2' : Unused code path elimination\r\n * Block '<Root>/Display3' : Unused code path elimination\r\n * Block '<Root>/Sum of Elements' : Unused code path elimination\r\n * Block '<Root>/Windspeed1' : Unused code path elimination\r\n * Block '<Root>/Windspeed2' : Unused code path elimination\r\n * Block '<S96>/Conversion' : Eliminate redundant data type conversion\r\n * Block '<S97>/Conversion' : Eliminate redundant data type conversion\r\n * Block '<S99>/Conversion' : Eliminate redundant data type conversion\r\n * Block '<S69>/Conversion' : Eliminate redundant data type conversion\r\n * Block '<S73>/Reshape' : Reshape block reduction\r\n * Block '<S52>/ReshapeX0' : Reshape block reduction\r\n * Block '<S52>/Reshapeu' : Reshape block reduction\r\n * Block '<S52>/Reshapexhat' : Reshape block reduction\r\n * Block '<S52>/Reshapey' : Reshape block reduction\r\n * Block '<S110>/Cast' : Eliminate redundant data type conversion\r\n * Block '<S110>/Cast To Double' : Eliminate redundant data type conversion\r\n * Block '<S110>/Cast To Double1' : Eliminate redundant data type conversion\r\n * Block '<S110>/Cast To Double2' : Eliminate redundant data type conversion\r\n * Block '<S110>/Cast To Double3' : Eliminate redundant data type conversion\r\n * Block '<S110>/Cast To Double4' : Eliminate redundant data type conversion\r\n * Block '<S136>/Reshape' : Reshape block reduction\r\n * Block '<S136>/Reshape1' : Reshape block reduction\r\n * Block '<S138>/Reshape' : Reshape block reduction\r\n * Block '<S144>/Reshape' : Reshape block reduction\r\n * Block '<S144>/Reshape1' : Reshape block reduction\r\n * Block '<S146>/Reshape' : Reshape block reduction\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Use the MATLAB hilite_system command to trace the generated code back\r\n * to the model.  For example,\r\n *\r\n * hilite_system('<S3>')    - opens system 3\r\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'Time_Varying_Model_2022a'\r\n * '<S1>'   : 'Time_Varying_Model_2022a/Calculate Angle of Attack and Sideslip'\r\n * '<S2>'   : 'Time_Varying_Model_2022a/Calculate C1'\r\n * '<S3>'   : 'Time_Varying_Model_2022a/Calculate C2'\r\n * '<S4>'   : 'Time_Varying_Model_2022a/Calculate CP with canards'\r\n * '<S5>'   : 'Time_Varying_Model_2022a/Calculate CP without canards'\r\n * '<S6>'   : 'Time_Varying_Model_2022a/Calculate Ccd'\r\n * '<S7>'   : 'Time_Varying_Model_2022a/Calculate Cdp'\r\n * '<S8>'   : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure'\r\n * '<S9>'   : 'Time_Varying_Model_2022a/Gain Scheduling'\r\n * '<S10>'  : 'Time_Varying_Model_2022a/MATLAB Function'\r\n * '<S11>'  : 'Time_Varying_Model_2022a/MATLAB Function1'\r\n * '<S12>'  : 'Time_Varying_Model_2022a/MATLAB Function2'\r\n * '<S13>'  : 'Time_Varying_Model_2022a/MATLAB Function3'\r\n * '<S14>'  : 'Time_Varying_Model_2022a/MATLAB Function4'\r\n * '<S15>'  : 'Time_Varying_Model_2022a/Minimum controllability switch'\r\n * '<S16>'  : 'Time_Varying_Model_2022a/Nonlinear Dynamics'\r\n * '<S17>'  : 'Time_Varying_Model_2022a/Radians to Degrees'\r\n * '<S18>'  : 'Time_Varying_Model_2022a/Radians to Degrees1'\r\n * '<S19>'  : 'Time_Varying_Model_2022a/Radians to Degrees10'\r\n * '<S20>'  : 'Time_Varying_Model_2022a/Radians to Degrees11'\r\n * '<S21>'  : 'Time_Varying_Model_2022a/Radians to Degrees12'\r\n * '<S22>'  : 'Time_Varying_Model_2022a/Radians to Degrees13'\r\n * '<S23>'  : 'Time_Varying_Model_2022a/Radians to Degrees14'\r\n * '<S24>'  : 'Time_Varying_Model_2022a/Radians to Degrees15'\r\n * '<S25>'  : 'Time_Varying_Model_2022a/Radians to Degrees16'\r\n * '<S26>'  : 'Time_Varying_Model_2022a/Radians to Degrees17'\r\n * '<S27>'  : 'Time_Varying_Model_2022a/Radians to Degrees18'\r\n * '<S28>'  : 'Time_Varying_Model_2022a/Radians to Degrees19'\r\n * '<S29>'  : 'Time_Varying_Model_2022a/Radians to Degrees2'\r\n * '<S30>'  : 'Time_Varying_Model_2022a/Radians to Degrees20'\r\n * '<S31>'  : 'Time_Varying_Model_2022a/Radians to Degrees21'\r\n * '<S32>'  : 'Time_Varying_Model_2022a/Radians to Degrees22'\r\n * '<S33>'  : 'Time_Varying_Model_2022a/Radians to Degrees23'\r\n * '<S34>'  : 'Time_Varying_Model_2022a/Radians to Degrees3'\r\n * '<S35>'  : 'Time_Varying_Model_2022a/Radians to Degrees4'\r\n * '<S36>'  : 'Time_Varying_Model_2022a/Radians to Degrees5'\r\n * '<S37>'  : 'Time_Varying_Model_2022a/Radians to Degrees6'\r\n * '<S38>'  : 'Time_Varying_Model_2022a/Radians to Degrees7'\r\n * '<S39>'  : 'Time_Varying_Model_2022a/Radians to Degrees8'\r\n * '<S40>'  : 'Time_Varying_Model_2022a/Radians to Degrees9'\r\n * '<S41>'  : 'Time_Varying_Model_2022a/Windspeed//Wind Angle'\r\n * '<S42>'  : 'Time_Varying_Model_2022a/Calculate Angle of Attack and Sideslip/MATLAB Function4'\r\n * '<S43>'  : 'Time_Varying_Model_2022a/Calculate Angle of Attack and Sideslip/MATLAB Function5'\r\n * '<S44>'  : 'Time_Varying_Model_2022a/Calculate Angle of Attack and Sideslip/Quaternion Rotation'\r\n * '<S45>'  : 'Time_Varying_Model_2022a/Calculate Angle of Attack and Sideslip/Rotation Angles to Quaternions'\r\n * '<S46>'  : 'Time_Varying_Model_2022a/Calculate Angle of Attack and Sideslip/Quaternion Rotation/Quaternion Normalize'\r\n * '<S47>'  : 'Time_Varying_Model_2022a/Calculate Angle of Attack and Sideslip/Quaternion Rotation/V1'\r\n * '<S48>'  : 'Time_Varying_Model_2022a/Calculate Angle of Attack and Sideslip/Quaternion Rotation/V2'\r\n * '<S49>'  : 'Time_Varying_Model_2022a/Calculate Angle of Attack and Sideslip/Quaternion Rotation/V3'\r\n * '<S50>'  : 'Time_Varying_Model_2022a/Calculate Angle of Attack and Sideslip/Quaternion Rotation/Quaternion Normalize/Quaternion Modulus'\r\n * '<S51>'  : 'Time_Varying_Model_2022a/Calculate Angle of Attack and Sideslip/Quaternion Rotation/Quaternion Normalize/Quaternion Modulus/Quaternion Norm'\r\n * '<S52>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter'\r\n * '<S53>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/CalculatePL'\r\n * '<S54>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/CalculateYhat'\r\n * '<S55>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/CovarianceOutputConfigurator'\r\n * '<S56>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionA'\r\n * '<S57>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionB'\r\n * '<S58>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionC'\r\n * '<S59>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionD'\r\n * '<S60>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionEnable'\r\n * '<S61>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionG'\r\n * '<S62>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionH'\r\n * '<S63>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionN'\r\n * '<S64>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionP'\r\n * '<S65>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionP0'\r\n * '<S66>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionQ'\r\n * '<S67>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionR'\r\n * '<S68>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionReset'\r\n * '<S69>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionX'\r\n * '<S70>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionX0'\r\n * '<S71>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/DataTypeConversionu'\r\n * '<S72>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/MemoryP'\r\n * '<S73>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/Observer'\r\n * '<S74>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/ReducedQRN'\r\n * '<S75>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/Reset'\r\n * '<S76>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/Reshapeyhat'\r\n * '<S77>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/ScalarExpansionP0'\r\n * '<S78>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/ScalarExpansionQ'\r\n * '<S79>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/ScalarExpansionR'\r\n * '<S80>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/UseCurrentEstimator'\r\n * '<S81>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkA'\r\n * '<S82>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkB'\r\n * '<S83>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkC'\r\n * '<S84>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkD'\r\n * '<S85>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkEnable'\r\n * '<S86>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkG'\r\n * '<S87>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkH'\r\n * '<S88>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkN'\r\n * '<S89>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkP0'\r\n * '<S90>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkQ'\r\n * '<S91>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkR'\r\n * '<S92>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkReset'\r\n * '<S93>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checkX0'\r\n * '<S94>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checku'\r\n * '<S95>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/checky'\r\n * '<S96>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/CalculatePL/DataTypeConversionL'\r\n * '<S97>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/CalculatePL/DataTypeConversionM'\r\n * '<S98>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/CalculatePL/DataTypeConversionP'\r\n * '<S99>'  : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/CalculatePL/DataTypeConversionZ'\r\n * '<S100>' : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/CalculatePL/Ground'\r\n * '<S101>' : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/CalculateYhat/Ground'\r\n * '<S102>' : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/CovarianceOutputConfigurator/decideOutput'\r\n * '<S103>' : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/CovarianceOutputConfigurator/decideOutput/SqrtUsedFcn'\r\n * '<S104>' : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/Observer/MeasurementUpdate'\r\n * '<S105>' : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/ReducedQRN/Ground'\r\n * '<S106>' : 'Time_Varying_Model_2022a/Calculate Dynamic Pressure/Kalman Filter/UseCurrentEstimator/Enabled Subsystem'\r\n * '<S107>' : 'Time_Varying_Model_2022a/Nonlinear Dynamics/Pitch'\r\n * '<S108>' : 'Time_Varying_Model_2022a/Nonlinear Dynamics/Roll'\r\n * '<S109>' : 'Time_Varying_Model_2022a/Nonlinear Dynamics/Yaw'\r\n * '<S110>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))'\r\n * '<S111>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/RPY to DCM'\r\n * '<S112>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Angle Conversion'\r\n * '<S113>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Filters on angular rates'\r\n * '<S114>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Filters on velocities'\r\n * '<S115>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Length Conversion'\r\n * '<S116>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Length Conversion1'\r\n * '<S117>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/RMS turbulence  intensities'\r\n * '<S118>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select angular rates'\r\n * '<S119>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select velocities'\r\n * '<S120>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Turbulence scale lengths'\r\n * '<S121>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Velocity Conversion'\r\n * '<S122>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Velocity Conversion2'\r\n * '<S123>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/White Noise'\r\n * '<S124>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Filters on angular rates/Hpgw'\r\n * '<S125>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Filters on angular rates/Hqgw'\r\n * '<S126>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Filters on angular rates/Hrgw'\r\n * '<S127>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Filters on velocities/Hugw(s)'\r\n * '<S128>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Filters on velocities/Hvgw(s)'\r\n * '<S129>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Filters on velocities/Hwgw(s)'\r\n * '<S130>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/RMS turbulence  intensities/High Altitude Intensity'\r\n * '<S131>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/RMS turbulence  intensities/Low Altitude Intensity'\r\n * '<S132>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select angular rates/Interpolate  rates'\r\n * '<S133>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select angular rates/Low altitude  rates'\r\n * '<S134>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select angular rates/Medium//High  altitude rates'\r\n * '<S135>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select angular rates/Merge Subsystems'\r\n * '<S136>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select angular rates/Interpolate  rates/wind to body transformation'\r\n * '<S137>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select angular rates/Interpolate  rates/wind to body transformation/convert to earth coords'\r\n * '<S138>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select angular rates/Low altitude  rates/wind to body transformation'\r\n * '<S139>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select angular rates/Low altitude  rates/wind to body transformation/convert to earth coords'\r\n * '<S140>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select velocities/Interpolate  velocities'\r\n * '<S141>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select velocities/Low altitude  velocities'\r\n * '<S142>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select velocities/Medium//High  altitude velocities'\r\n * '<S143>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select velocities/Merge Subsystems'\r\n * '<S144>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select velocities/Interpolate  velocities/wind to body transformation'\r\n * '<S145>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select velocities/Interpolate  velocities/wind to body transformation/convert to earth coords'\r\n * '<S146>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select velocities/Low altitude  velocities/wind to body transformation'\r\n * '<S147>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Select velocities/Low altitude  velocities/wind to body transformation/convert to earth coords'\r\n * '<S148>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Turbulence scale lengths/Low altitude scale length'\r\n * '<S149>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Turbulence scale lengths/Medium//High altitude scale length'\r\n * '<S150>' : 'Time_Varying_Model_2022a/Windspeed//Wind Angle/Dryden Wind Turbulence Model  (Continuous (+q +r))/Turbulence scale lengths/Medium//High altitude scale length/Length Conversion'\r\n */\r\n#endif                              /* RTW_HEADER_Time_Varying_Model_2022a_h_ */\r\n"},{"name":"Time_Varying_Model_2022a_private.h","type":"header","group":"model","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Time_Varying_Model_2022a_private.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Time_Varying_Model_2022a_private_h_\r\n#define RTW_HEADER_Time_Varying_Model_2022a_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"builtin_typeid_types.h\"\r\n#include \"multiword_types.h\"\r\n#include \"Time_Varying_Model_2022a_types.h\"\r\n#include \"Time_Varying_Model_2022a.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n\r\n/* Private macros used by the generated code to access rtModel */\r\n#ifndef rtmIsMajorTimeStep\r\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmIsMinorTimeStep\r\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\r\n#endif\r\n\r\n#ifndef rtmSetTFinal\r\n#define rtmSetTFinal(rtm, val)         ((rtm)->Timing.tFinal = (val))\r\n#endif\r\n\r\n#ifndef rtmSetTPtr\r\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\r\n#endif\r\n\r\nextern real_T rt_urand_Upu32_Yd_f_pw_snf(uint32_T *u);\r\nextern real_T rt_nrand_Upu32_Yd_f_pw_snf(uint32_T *u);\r\nextern real_T rt_powd_snf(real_T u0, real_T u1);\r\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\r\nextern real_T look1_binlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n  uint32_T maxIndex);\r\nextern uint32_T plook_bincpa(real_T u, const real_T bp[], uint32_T maxIndex,\r\n  real_T *fraction, uint32_T *prevIndex);\r\nextern real_T intrp2d_la_pw(const uint32_T bpIndex[], const real_T frac[], const\r\n  real_T table[], const uint32_T stride, const uint32_T maxIndex[]);\r\nextern uint32_T plook_u32d_binckan(real_T u, const real_T bp[], uint32_T\r\n  maxIndex);\r\nextern uint32_T binsearch_u32d_prevIdx(real_T u, const real_T bp[], uint32_T\r\n  startIndex, uint32_T maxIndex);\r\nextern uint32_T binsearch_u32d(real_T u, const real_T bp[], uint32_T startIndex,\r\n  uint32_T maxIndex);\r\n\r\n/* private model entry point functions */\r\nextern void Time_Varying_Model_2022a_derivatives(void);\r\n\r\n#endif                      /* RTW_HEADER_Time_Varying_Model_2022a_private_h_ */\r\n"},{"name":"Time_Varying_Model_2022a_types.h","type":"header","group":"model","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * Time_Varying_Model_2022a_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_Time_Varying_Model_2022a_types_h_\r\n#define RTW_HEADER_Time_Varying_Model_2022a_types_h_\r\n\r\n/* Parameters (default storage) */\r\ntypedef struct P_Time_Varying_Model_2022a_T_ P_Time_Varying_Model_2022a_T;\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_Time_Varying_Model_20_T RT_MODEL_Time_Varying_Model_2_T;\r\n\r\n#endif                        /* RTW_HEADER_Time_Varying_Model_2022a_types_h_ */\r\n"},{"name":"Time_Varying_Model_2022a_data.c","type":"source","group":"data","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Data files","code":"/*\r\n * Time_Varying_Model_2022a_data.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"Time_Varying_Model_2022a.h\"\r\n\r\n/* Block parameters (default storage) */\r\nP_Time_Varying_Model_2022a_T Time_Varying_Model_2022a_P = {\r\n  /* Mask Parameter: DrydenWindTurbulenceModelContin\r\n   * Referenced by: '<S149>/Medium//High Altitude'\r\n   */\r\n  533.4,\r\n\r\n  /* Mask Parameter: DrydenWindTurbulenceModelCont_a\r\n   * Referenced by: '<S123>/White Noise'\r\n   */\r\n  { 23341.0, 23342.0, 23343.0, 23344.0 },\r\n\r\n  /* Mask Parameter: DrydenWindTurbulenceModelCont_c\r\n   * Referenced by:\r\n   *   '<S113>/Constant1'\r\n   *   '<S113>/Constant2'\r\n   *   '<S113>/Constant3'\r\n   *   '<S114>/Constant'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: WhiteNoise_Ts\r\n   * Referenced by: '<S123>/Constant1'\r\n   */\r\n  0.5,\r\n\r\n  /* Mask Parameter: DrydenWindTurbulenceModelCon_au\r\n   * Referenced by: '<S130>/Probability of  Exceedance'\r\n   */\r\n  3.0,\r\n\r\n  /* Mask Parameter: DrydenWindTurbulenceModelCont_i\r\n   * Referenced by: '<S110>/Windspeed at 20ft (6m)'\r\n   */\r\n  15.0,\r\n\r\n  /* Mask Parameter: DrydenWindTurbulenceModelCont_m\r\n   * Referenced by: '<S110>/Wind direction'\r\n   */\r\n  0.0,\r\n\r\n  /* Mask Parameter: DrydenWindTurbulenceModelCont_j\r\n   * Referenced by: '<S110>/Wingspan'\r\n   */\r\n  0.103,\r\n\r\n  /* Mask Parameter: WhiteNoise_pwr\r\n   * Referenced by: '<S123>/Constant'\r\n   */\r\n  { 3.1415926535897931, 3.1415926535897931, 3.1415926535897931,\r\n    3.1415926535897931 },\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S104>/L*(y[k]-yhat[k|k-1])'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S106>/deltax'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S124>/pgw'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1/3\r\n   * Referenced by: '<S124>/Constant1'\r\n   */\r\n  0.33333333333333331,\r\n\r\n  /* Expression: 1/6\r\n   * Referenced by: '<S124>/Constant2'\r\n   */\r\n  0.16666666666666666,\r\n\r\n  /* Expression: pi/4\r\n   * Referenced by: '<S124>/Constant3'\r\n   */\r\n  0.78539816339744828,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S124>/pgw_p'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S125>/qgw'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S125>/qgw_p'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: pi/4\r\n   * Referenced by: '<S125>/pi//4'\r\n   */\r\n  0.78539816339744828,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S126>/rgw'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S126>/rgw_p'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: pi/3\r\n   * Referenced by: '<S126>/pi//3'\r\n   */\r\n  1.0471975511965976,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S127>/ugw'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 2/pi\r\n   * Referenced by: '<S127>/(2//pi)'\r\n   */\r\n  0.63661977236758138,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S127>/ug_p'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S128>/vgw'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1/pi\r\n   * Referenced by: '<S128>/(1//pi)'\r\n   */\r\n  0.31830988618379069,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S128>/vg_p1'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S128>/vgw_p2'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: sqrt(3)\r\n   * Referenced by: '<S128>/sqrt(3)'\r\n   */\r\n  1.7320508075688772,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S129>/wgw'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1/pi\r\n   * Referenced by: '<S129>/1//pi'\r\n   */\r\n  0.31830988618379069,\r\n\r\n  /* Expression: 3\r\n   * Referenced by: '<S129>/Constant'\r\n   */\r\n  3.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S129>/wg_p1'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S129>/wg_p2'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S134>/Gain'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: max_height_low\r\n   * Referenced by: '<S132>/max_height_low'\r\n   */\r\n  1000.0,\r\n\r\n  /* Expression: min_height_high\r\n   * Referenced by: '<S132>/min_height_high'\r\n   */\r\n  2000.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S142>/Gain'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: max_height_low\r\n   * Referenced by: '<S140>/max_height_low'\r\n   */\r\n  1000.0,\r\n\r\n  /* Expression: min_height_high\r\n   * Referenced by: '<S140>/min_height_high'\r\n   */\r\n  2000.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S16>/Integrator4'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S21>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S15>/Constant'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: OR.v\r\n   * Referenced by: '<Root>/OpenRocket Velocity'\r\n   */\r\n  { 34.732, 36.024, 37.937, 40.75, 44.775, 48.594, 52.231, 55.702, 59.038,\r\n    62.234, 65.284, 68.268, 71.186, 73.995, 76.71, 79.292, 81.5, 83.676, 85.972,\r\n    88.173, 90.236, 91.995, 93.461, 94.692, 95.763, 96.676, 97.345, 97.821,\r\n    98.15, 98.35, 98.451, 98.502, 98.423, 98.201, 97.889, 97.455, 97.103, 96.528,\r\n    95.913, 95.302, 94.694, 94.089, 93.484, 92.881, 92.276, 91.669, 91.062,\r\n    90.454, 89.846, 89.24, 88.636, 88.037, 87.44, 86.845, 86.253, 85.665, 85.08,\r\n    84.497, 83.916, 83.336, 82.756, 82.176, 81.594, 81.013, 80.433, 79.854,\r\n    79.276, 78.698, 78.121, 77.546, 76.973, 76.402, 75.834, 75.267, 74.702,\r\n    74.139, 73.578, 73.018, 72.458, 71.9, 71.342, 70.784, 70.227, 69.671, 69.116,\r\n    68.561, 68.008, 67.455, 66.903, 66.351, 65.801, 65.251, 64.703, 64.157,\r\n    63.614, 63.072, 62.531, 61.991, 61.451, 60.913, 60.377, 59.84, 59.304,\r\n    58.767, 58.23, 57.693, 57.157, 56.623, 56.089, 55.555, 55.022, 54.489,\r\n    53.958, 53.427, 52.899, 52.372, 51.846, 51.322, 50.801, 50.28, 49.758,\r\n    49.237, 48.716, 48.197, 47.678, 47.159, 46.64, 46.121, 45.601, 45.083,\r\n    44.566, 44.05, 43.535, 43.022, 42.508, 41.995, 41.481, 40.968, 40.457,\r\n    39.947, 39.437, 38.929, 38.422, 37.916, 37.409, 36.902, 36.395, 35.888,\r\n    35.381, 34.873, 34.365, 33.856, 33.348, 32.841, 32.336, 31.83, 31.324,\r\n    30.818, 30.313, 29.809, 29.306, 28.803, 28.3, 27.797, 27.295, 26.795, 26.296,\r\n    25.798, 25.299, 24.8, 24.302, 23.803, 23.305, 22.809, 22.314, 21.818, 21.323,\r\n    20.83, 20.337, 19.846, 19.356, 18.866, 18.376, 17.885, 17.394, 16.903,\r\n    16.413, 15.924, 15.436, 14.947, 14.458, 13.971, 13.484, 12.997, 12.511,\r\n    12.026, 11.542, 11.059, 10.575, 10.092, 9.609, 9.126, 8.643, 8.162, 7.682,\r\n    7.203, 6.724, 6.246, 5.769, 5.293, 4.817, 4.341, 3.866, 3.393, 2.92, 2.448,\r\n    1.978, 1.508, 1.04, 0.573, 0.109, -0.364, -0.84 },\r\n\r\n  /* Expression: OR.t\r\n   * Referenced by: '<Root>/OpenRocket Velocity'\r\n   */\r\n  { 0.0, 0.015000000000000013, 0.038000000000000034, 0.071000000000000008, 0.121,\r\n    0.17100000000000004, 0.22099999999999997, 0.271, 0.32100000000000006, 0.371,\r\n    0.42100000000000004, 0.471, 0.521, 0.57100000000000006, 0.621, 0.67, 0.715,\r\n    0.761, 0.811, 0.8610000000000001, 0.91099999999999992, 0.961,\r\n    1.0110000000000001, 1.061, 1.1110000000000002, 1.161, 1.2109999999999999,\r\n    1.2610000000000001, 1.311, 1.3610000000000002, 1.411, 1.4609999999999999,\r\n    1.5110000000000001, 1.561, 1.6110000000000002, 1.661, 1.6920000000000002,\r\n    1.738, 1.7880000000000003, 1.838, 1.8880000000000003, 1.9380000000000002,\r\n    1.988, 2.0380000000000003, 2.088, 2.1380000000000003, 2.188, 2.238,\r\n    2.2880000000000003, 2.338, 2.3880000000000003, 2.438, 2.488,\r\n    2.5380000000000003, 2.588, 2.6380000000000003, 2.688, 2.738,\r\n    2.7880000000000003, 2.838, 2.8880000000000003, 2.938, 2.988,\r\n    3.0380000000000003, 3.088, 3.1380000000000003, 3.188, 3.238,\r\n    3.2880000000000003, 3.338, 3.3880000000000003, 3.438, 3.488,\r\n    3.5380000000000003, 3.588, 3.6380000000000003, 3.688, 3.738, 3.788,\r\n    3.8380000000000005, 3.8880000000000003, 3.938, 3.988, 4.0379999999999994,\r\n    4.088, 4.138, 4.188, 4.2379999999999995, 4.2879999999999994, 4.338, 4.388,\r\n    4.438, 4.4879999999999995, 4.5379999999999994, 4.588, 4.638, 4.688,\r\n    4.7379999999999995, 4.7879999999999994, 4.838, 4.888, 4.938,\r\n    4.9879999999999995, 5.0379999999999994, 5.088, 5.138, 5.188,\r\n    5.2379999999999995, 5.2879999999999994, 5.338, 5.388, 5.438,\r\n    5.4879999999999995, 5.5379999999999994, 5.588, 5.638, 5.688,\r\n    5.7379999999999995, 5.7879999999999994, 5.838, 5.888, 5.938,\r\n    5.9879999999999995, 6.0379999999999994, 6.088, 6.138, 6.188,\r\n    6.2379999999999995, 6.2879999999999994, 6.338, 6.388, 6.438,\r\n    6.4879999999999995, 6.5379999999999994, 6.588, 6.638, 6.688,\r\n    6.7379999999999995, 6.7879999999999994, 6.838, 6.888, 6.938,\r\n    6.9879999999999995, 7.0379999999999994, 7.088, 7.138, 7.188,\r\n    7.2379999999999995, 7.2879999999999994, 7.338, 7.388, 7.438,\r\n    7.4879999999999995, 7.5379999999999994, 7.588, 7.638, 7.688, 7.738,\r\n    7.7879999999999994, 7.838, 7.887999999999999, 7.938, 7.988, 8.038,\r\n    8.088000000000001, 8.138, 8.188, 8.2380000000000013, 8.288,\r\n    8.338000000000001, 8.388, 8.438, 8.4880000000000013, 8.538,\r\n    8.588000000000001, 8.638, 8.688, 8.7380000000000013, 8.788,\r\n    8.838000000000001, 8.888, 8.938, 8.9880000000000013, 9.038,\r\n    9.088000000000001, 9.138, 9.188, 9.2380000000000013, 9.288,\r\n    9.338000000000001, 9.388, 9.438, 9.4880000000000013, 9.538,\r\n    9.588000000000001, 9.638, 9.688, 9.7380000000000013, 9.788,\r\n    9.838000000000001, 9.888, 9.938, 9.9880000000000013, 10.038,\r\n    10.088000000000001, 10.138, 10.188, 10.238000000000001, 10.288,\r\n    10.338000000000001, 10.388, 10.438, 10.488000000000001, 10.538,\r\n    10.588000000000001, 10.638, 10.688, 10.738000000000001, 10.788,\r\n    10.838000000000001, 10.888, 10.938, 10.988000000000001 },\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S15>/Constant1'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: controller.minControlSpeed\r\n   * Referenced by: '<S15>/Switch'\r\n   */\r\n  30.0,\r\n\r\n  /* Expression: controller.K\r\n   * Referenced by: '<S9>/Constant'\r\n   */\r\n  { -7.0710678118686646E-6, -7.0710678118686536E-6, -7.0710678118681378E-6,\r\n    -7.0710678118680522E-6, 0.63245553203367544, -0.63245553203367577,\r\n    -3.0952392017814293E-15, 2.90512255600379E-15, 2.8183403581212468E-15,\r\n    -3.1203053964913802E-15, 0.632455532033677, -0.63245553203367411,\r\n    -0.44717763350090411, -0.44717763350090312, -0.44717763350090184,\r\n    -0.44717763350090478, 0.56758460987191062, -0.567584609871911,\r\n    -1.6267720036031135E-15, 2.0156098355006333E-15, 2.4856786462821262E-15,\r\n    -2.05666418469186E-15, 0.567584609871913, -0.56758460987191062,\r\n    -7.0710678118678761E-6, -7.0710678118678574E-6, -7.0710678118678464E-6,\r\n    -7.0710678118678718E-6, 0.632455532033677, -0.63245553203367755,\r\n    -8.5568127993786419E-17, 2.5904047559146713E-16, 3.0493957530826318E-16,\r\n    2.45038483827858E-16, 0.63245553203367566, -0.63245553203367555,\r\n    -0.44717968482185666, -0.44717968482185527, -0.44717968482185505,\r\n    -0.44717968482185655, 0.54276708759054071, -0.54276708759054115,\r\n    -4.5255301608234485E-16, 6.8443271279104635E-16, 1.1415842147137474E-16,\r\n    2.6543251844483157E-16, 0.54276708759054038, -0.54276708759054038,\r\n    -7.0710678118729117E-6, -7.0710678118728752E-6, -7.0710678118729168E-6,\r\n    -7.0710678118728922E-6, 0.632455532033677, -0.63245553203367688,\r\n    1.1983746054559219E-15, -1.2789652838257163E-15, -4.7534009569919236E-15,\r\n    4.9797533835153487E-15, 0.63245553203367655, -0.63245553203367677,\r\n    -0.44718151211490736, -0.44718151211490548, -0.4471815121149072,\r\n    -0.44718151211490642, 0.52101205012281282, -0.5210120501228126,\r\n    -1.2089963296884607E-15, 1.059492216249134E-15, -2.274497811646971E-15,\r\n    2.654367962400468E-15, 0.52101205012280993, -0.52101205012281,\r\n    -7.0710678118464156E-6, -7.071067811846425E-6, -7.0710678118464148E-6,\r\n    -7.0710678118464165E-6, 0.63245553203367733, -0.63245553203367733,\r\n    -7.492089645975908E-16, 9.9172683037974544E-16, 1.7665763925954205E-15,\r\n    -2.2137085922588319E-15, 0.63245553203367488, -0.63245553203367466,\r\n    -0.44718315003477804, -0.44718315003477882, -0.44718315003477788,\r\n    -0.44718315003477782, 0.5018327565237819, -0.5018327565237819,\r\n    2.2777960154880877E-16, -3.2744981617735572E-17, 1.1036718679553091E-15,\r\n    -1.3698388209504484E-15, 0.50183275652378, -0.5018327565237799,\r\n    -7.0710678118321465E-6, -7.0710678118320974E-6, -7.0710678118321177E-6,\r\n    -7.071067811832127E-6, 0.63245553203367511, -0.63245553203367533,\r\n    1.0099125360507884E-15, -1.5148688040761825E-15, -5.3224484880790285E-16,\r\n    6.0820764055143163E-16, 0.63245553203367655, -0.63245553203367655,\r\n    -0.44718462643808304, -0.44718462643808027, -0.44718462643808138,\r\n    -0.44718462643808216, 0.48483826613983538, -0.48483826613983538,\r\n    -1.9754146967532475E-16, -1.3552543771222221E-16, -8.73296596634225E-17,\r\n    8.0390765759515276E-17, 0.48483826613983677, -0.48483826613983677,\r\n    -7.07106781186732E-6, -7.0710678118673458E-6, -7.0710678118695235E-6,\r\n    -7.0710678118704519E-6, 0.63245553203367566, -0.63245553203367477,\r\n    8.2354317544782863E-16, -1.1462552516123564E-15, 2.1447969668723357E-16,\r\n    3.6295702468607283E-15, 0.63245553203367666, -0.63245553203368055,\r\n    -0.4471859639723037, -0.44718596397230531, -0.44718596397230487,\r\n    -0.44718596397230836, 0.46971103244589446, -0.46971103244589385,\r\n    1.3588369151682979E-16, -4.2820684216532057E-16, 1.7662243467679588E-16,\r\n    1.6569754477461029E-15, 0.46971103244589452, -0.46971103244589646,\r\n    -7.0710678118548546E-6, -7.0710678118548707E-6, -7.0710678118515131E-6,\r\n    -7.07106781185032E-6, 0.6324555320336761, -0.63245553203367633,\r\n    2.5983650767356975E-16, -1.1605356873594407E-17, 2.9445368647250142E-15,\r\n    4.2145129278627248E-16, 0.63245553203367522, -0.63245553203367821,\r\n    -0.44718718123895745, -0.44718718123895845, -0.44718718123895679,\r\n    -0.44718718123896128, 0.45619051101777153, -0.45619051101777153,\r\n    7.3176626472946483E-16, -7.5922226285522764E-16, 1.3751115593956729E-15,\r\n    1.7647822125110419E-17, 0.45619051101777253, -0.4561905110177738,\r\n    -7.0710678118742754E-6, -7.0710678118743889E-6, -7.0710678118834708E-6,\r\n    -7.0710678118834335E-6, 0.63245553203367988, -0.63245553203367466,\r\n    3.2023406170387303E-15, -7.8733367901487327E-15, -1.1511694757245051E-14,\r\n    5.7558473786225253E-15, 0.63245553203367744, -0.63245553203367311,\r\n    -0.4471882936584336, -0.44718829365843504, -0.4471882936584437,\r\n    -0.44718829365844104, 0.44406097753011042, -0.44406097753010959,\r\n    1.1923170362385029E-15, -2.2006827268304839E-15, -2.4577109690193012E-15,\r\n    1.4718627093415308E-15, 0.44406097753010981, -0.44406097753010865,\r\n    -7.07106781183602E-6, -7.0710678118360488E-6, -7.0710678118408837E-6,\r\n    -7.071067811840832E-6, 0.63245553203367388, -0.63245553203367866,\r\n    3.7295007228281486E-15, 6.3120069180340284E-16, -2.0206490051657223E-15,\r\n    -1.299473719367536E-15, 0.63245553203367644, -0.63245553203367333,\r\n    -0.44718931412208462, -0.44718931412208107, -0.447189314122096,\r\n    -0.44718931412209262, 0.433142344879369, -0.43314234487937059,\r\n    1.9731962929033723E-15, -4.5079044821199735E-16, -6.5645054626528107E-16,\r\n    -4.1948851213742174E-16, 0.4331423448793687, -0.43314234487936765,\r\n    -7.07106781183413E-6, -7.0710678118341464E-6, -7.0710678118308446E-6,\r\n    -7.0710678118307642E-6, 0.632455532033678, -0.63245553203367466,\r\n    2.9190927797583086E-15, -4.5205505150599917E-15, -6.7357598380720212E-15,\r\n    2.9343664225499631E-15, 0.63245553203367677, -0.63245553203367444,\r\n    -0.44719025349022307, -0.44719025349022418, -0.44719025349022817,\r\n    -0.44719025349022329, 0.42328315097737224, -0.42328315097737129,\r\n    8.74275801131972E-16, -1.0504152072820962E-15, -2.2437476879580421E-15,\r\n    1.2747360923933042E-15, 0.42328315097737235, -0.42328315097737185,\r\n    -7.0710678118681386E-6, -7.0710678118681437E-6, -7.0710678118672289E-6,\r\n    -7.0710678118672645E-6, 0.63245553203367721, -0.63245553203367411,\r\n    -1.9227933905330006E-15, 1.4349222480461753E-16, 4.2716359089613432E-15,\r\n    -2.6948364928901076E-15, 0.63245553203367388, -0.63245553203367477,\r\n    -0.4471911209769287, -0.44719112097692959, -0.44719112097692831,\r\n    -0.44719112097693037, 0.41435514048167071, -0.41435514048167005,\r\n    -4.1851465238819338E-16, 1.2528583073339824E-16, 9.0806843035616327E-16,\r\n    -5.2996860519455535E-16, 0.41435514048166944, -0.4143551404816696,\r\n    -7.07106781185299E-6, -7.0710678118527616E-6, -7.0710678118520755E-6,\r\n    -7.0710678118520374E-6, 0.63245553203367688, -0.63245553203367666,\r\n    -2.3298133036805056E-15, 7.5104868621104268E-16, -1.2129425850986053E-14,\r\n    9.7352294066669352E-15, 0.63245553203367533, -0.632455532033673,\r\n    -0.44719192445052908, -0.44719192445052497, -0.4471919244505283,\r\n    -0.44719192445052652, 0.40624903255293054, -0.4062490325529301,\r\n    -8.4353819012764107E-16, 1.1316731676976873E-16, -1.3906125748437078E-15,\r\n    1.4849808847005119E-15, 0.40624903255292838, -0.4062490325529286,\r\n    -7.0710678118854537E-6, -7.0710678118852623E-6, -7.0710678118831718E-6,\r\n    -7.0710678118832624E-6, 0.63245553203367966, -0.63245553203367744,\r\n    9.2866883545681217E-16, -7.4949601143341537E-16, 3.7227364630810249E-15,\r\n    -6.4743242836191742E-16, 0.63245553203367488, -0.63245553203367577,\r\n    -0.44719267067059532, -0.44719267067060053, -0.44719267067059526,\r\n    -0.44719267067060109, 0.39887118191596921, -0.3988711819159691,\r\n    6.8312190502128021E-16, 1.1396307836935691E-16, 4.1249302019253735E-16,\r\n    -3.1315266126866503E-16, 0.39887118191596749, -0.39887118191596721,\r\n    -7.0710678118909E-6, -7.0710678118901674E-6, -7.0710678118842441E-6,\r\n    -7.0710678118842941E-6, 0.63245553203367644, -0.63245553203367677,\r\n    5.058041761301791E-15, -5.383475231729466E-15, -6.2062677654935987E-16,\r\n    2.8548831721270555E-15, 0.63245553203366744, -0.63245553203366867,\r\n    -0.4471933654765774, -0.44719336547657512, -0.44719336547657351,\r\n    -0.44719336547657496, 0.39214092033737274, -0.3921409203373728,\r\n    1.1963059238496206E-15, -1.3753382177191263E-15, -1.3695813054234292E-15,\r\n    1.4421103841358187E-15, 0.3921409203373688, -0.39214092033736875,\r\n    -7.0710678118560176E-6, -7.071067811855705E-6, -7.0710678118529454E-6,\r\n    -7.0710678118529234E-6, 0.63245553203367444, -0.63245553203366833,\r\n    -2.0017287577946515E-15, -2.2448743113965723E-15, 3.4992542186450926E-15,\r\n    -4.1594908636724685E-15, 0.63245553203367433, -0.63245553203367433,\r\n    -0.44719401393915509, -0.44719401393915686, -0.44719401393915537,\r\n    -0.44719401393915392, 0.38598842177442377, -0.38598842177442239,\r\n    3.570589154754849E-17, -1.0884658294873653E-15, 7.9387044164394751E-16,\r\n    -1.0758594736112902E-15, 0.38598842177442361, -0.38598842177442338,\r\n    -7.0710678118527116E-6, -7.0710678118526108E-6, -7.0710678118521636E-6,\r\n    -7.0710678118521289E-6, 0.63245553203367055, -0.63245553203367633,\r\n    5.278519311132935E-15, -8.4085251845145558E-16, -3.2854057746893313E-16,\r\n    -3.2854057746893314E-15, 0.63245553203367844, -0.63245553203367577,\r\n    -0.44719462048270231, -0.4471946204827, -0.44719462048270403,\r\n    -0.447194620482702, 0.38035297446082483, -0.38035297446082572,\r\n    1.4254838506944024E-15, -5.2535637021086448E-16, -8.57066896661454E-16,\r\n    1.0061973212895016E-15, 0.38035297446082528, -0.38035297446082478,\r\n    -7.0710678118495175E-6, -7.0710678118495641E-6, -7.0710678118496369E-6,\r\n    -7.0710678118496488E-6, 0.63245553203367977, -0.63245553203367766,\r\n    -4.8901605571886747E-16, -1.3971887306253357E-16, -4.7244635471795253E-15,\r\n    6.1578360288961057E-16, 0.63245553203367877, -0.63245553203367488,\r\n    -0.44719518898503319, -0.44719518898503496, -0.44719518898503408,\r\n    -0.44719518898503524, 0.37518157206483072, -0.37518157206483049,\r\n    8.7294718223000071E-18, 9.4602567804648559E-17, -1.1854568914622877E-15,\r\n    1.0483309685738969E-15, 0.3751815720648301, -0.37518157206482994,\r\n    -7.0710678118639789E-6, -7.0710678118638052E-6, -7.0710678118629379E-6,\r\n    -7.0710678118629226E-6, 0.63245553203367888, -0.63245553203367333,\r\n    -2.1301864466486095E-15, -2.9696884728075353E-15, 3.6622112950165892E-16,\r\n    7.3244225900331784E-16, 0.63245553203367333, -0.63245553203367422,\r\n    -0.447195722859259, -0.44719572285925679, -0.44719572285925885,\r\n    -0.44719572285925813, 0.37042775712806281, -0.37042775712806103,\r\n    -1.0945203400592595E-15, -5.0747825787526294E-16, 9.3454258781907976E-16,\r\n    -4.4571257402733936E-16, 0.37042775712806236, -0.37042775712806281,\r\n    -7.0710678117590459E-6, -7.0710678119125469E-6, -7.0710678118243411E-6,\r\n    -7.0710678118472669E-6, 0.6324555320336761, -0.63245553203367622,\r\n    -4.9424535209713785E-16, 6.018619526756262E-16, 5.951154037830607E-15,\r\n    -5.3560386340475463E-15, 0.63245553203367821, -0.63245553203367788,\r\n    -0.44719622512132629, -0.4471962251213254, -0.44719622512132651,\r\n    -0.44719622512132556, 0.36605066554057819, -0.36605066554057814,\r\n    6.26285604341051E-16, -5.1984673443585564E-16, 1.8229458175532983E-15,\r\n    -1.7050061127459512E-15, 0.36605066554057836, -0.36605066554057814,\r\n    -7.0710678118694515E-6, -7.0710678118694371E-6, -7.0710678118694439E-6,\r\n    -7.0710678118694439E-6, 0.63245553203366911, -0.63245553203366922,\r\n    -1.0969817222052494E-14, 1.1010892619982029E-14, -1.7761192673938478E-15,\r\n    1.7761192673938478E-15, 0.63245553203366567, -0.63245553203366578,\r\n    -0.44719669844614096, -0.44719669844614063, -0.44719669844614113,\r\n    -0.44719669844614068, 0.36201423239410058, -0.36201423239410041,\r\n    -2.7484395132052017E-15, 2.7238719539163767E-15, -1.2943389346445817E-15,\r\n    1.5985284678411333E-15, 0.36201423239409986, -0.36201423239410019,\r\n    -7.0710678118671154E-6, -7.0710678118672222E-6, -7.0710678118671849E-6,\r\n    -7.0710678118671383E-6, 0.63245553203367677, -0.63245553203367677,\r\n    1.4843051023002501E-15, -2.3082192807514437E-15, -0.0,\r\n    -4.5953232536622253E-16, 0.63245553203367733, -0.63245553203367755,\r\n    -0.44719714521440945, -0.44719714521440718, -0.44719714521440873,\r\n    -0.4471971452144074, 0.35828652827154334, -0.35828652827154317,\r\n    3.9861433312050378E-16, -6.2284721054995336E-16, -7.0969356564333968E-16,\r\n    4.321378094870506E-16, 0.35828652827154278, -0.35828652827154273,\r\n    -7.071067811863945E-6, -7.0710678118640644E-6, -7.071067811864017E-6,\r\n    -7.0710678118639806E-6, 0.63245553203367511, -0.632455532033674,\r\n    -3.0016161843428895E-15, 4.8057285993587692E-15, 6.4786357731506646E-15,\r\n    -5.5531163769862836E-15, 0.63245553203367522, -0.63245553203367522,\r\n    -0.44719756755197304, -0.44719756755198031, -0.44719756755197726,\r\n    -0.44719756755197537, 0.35483920164607596, -0.3548392016460758,\r\n    -9.50632070815071E-16, 1.3909382161587523E-15, 1.3507965372404281E-15,\r\n    -1.5411395901643104E-15, 0.35483920164607446, -0.35483920164607458,\r\n    -7.0710678118638306E-6, -7.071067811863812E-6, -7.0710678118638145E-6,\r\n    -7.0710678118638179E-6, 0.63245553203367777, -0.63245553203367721,\r\n    2.7846208136009593E-15, -2.5293474673193039E-15, -2.9367766696054703E-15,\r\n    2.4473138913378919E-15, 0.63245553203367721, -0.63245553203367677,\r\n    -0.4471979673630247, -0.44719796736302514, -0.44719796736302464,\r\n    -0.44719796736302458, 0.351647008125723, -0.35164700812572286,\r\n    1.3310912649217392E-15, -1.2312101673965396E-15, -4.87361274553761E-16,\r\n    3.7509352984130895E-16, 0.35164700812572147, -0.35164700812572125,\r\n    -7.0710678118656975E-6, -7.0710678118656772E-6, -7.0710678118659482E-6,\r\n    -7.0710678118654222E-6, 0.63245553203367932, -0.63245553203367821,\r\n    1.91710772840582E-15, -1.3272284273578752E-15, -2.6143685888918616E-15,\r\n    2.8567852580648142E-15, 0.63245553203367744, -0.63245553203367721,\r\n    -0.44719834635819589, -0.44719834635819872, -0.44719834635819716,\r\n    -0.44719834635819683, 0.348687411184298, -0.34868741118429791,\r\n    3.2851087094801969E-16, -1.9749566703571372E-16, -5.2708647833397122E-16,\r\n    7.9044382280749964E-16, 0.34868741118429869, -0.34868741118429886,\r\n    -7.0710678118650546E-6, -7.0710678118649258E-6, -7.0710678118649809E-6,\r\n    -7.0710678118650046E-6, 0.63245553203367377, -0.63245553203367388,\r\n    -1.2429593485912241E-15, 1.2429593485912241E-15, -3.8208259448908707E-15,\r\n    3.8127137878953488E-15, 0.63245553203367388, -0.63245553203367388,\r\n    -0.44719870607854023, -0.4471987060785389, -0.44719870607853907,\r\n    -0.44719870607853995, 0.34594024205403978, -0.34594024205403984,\r\n    -6.590335208897669E-16, 7.25230773607009E-16, -7.0949734060309864E-16,\r\n    7.9025013483329648E-16, 0.34594024205403978, -0.34594024205403989,\r\n    -7.0710678118547979E-6, -7.071067811855268E-6, -7.0710678118550613E-6,\r\n    -7.0710678118550122E-6, 0.63245553203367511, -0.63245553203367633,\r\n    -1.1405113643992815E-15, 9.5537029376653564E-16, 6.8122852276839669E-15,\r\n    -6.4519880657888306E-15, 0.63245553203367422, -0.63245553203367466,\r\n    -0.44719904791602461, -0.44719904791602216, -0.447199047916024,\r\n    -0.44719904791602288, 0.34338740882991392, -0.34338740882991425,\r\n    7.4792421329191711E-16, -7.3228820570623191E-16, 1.1417514882613172E-15,\r\n    -9.2239658104583253E-16, 0.34338740882991337, -0.3433874088299137,\r\n    -7.0710678118643109E-6, -7.07106781186436E-6, -7.0710678118643007E-6,\r\n    -7.0710678118643677E-6, 0.63245553203367533, -0.632455532033675,\r\n    2.1896626723955273E-15, -1.9286225494440437E-15, -5.2712321335276738E-15,\r\n    5.5956156494370688E-15, 0.6324555320336791, -0.63245553203367855,\r\n    -0.4471993731310866, -0.4471993731310871, -0.44719937313108443,\r\n    -0.44719937313108921, 0.34101264670625731, -0.34101264670625725,\r\n    8.1523218866906133E-17, 4.4600419728492484E-17, -6.3280948341093882E-16,\r\n    9.2560288276881162E-16, 0.34101264670625858, -0.34101264670625864,\r\n    -7.0710678118658567E-6, -7.0710678118658279E-6, -7.0710678118658474E-6,\r\n    -7.0710678118658305E-6, 0.63245553203367677, -0.63245553203367688,\r\n    1.8544297106999443E-16, -1.215346468206889E-15, 2.1091070117780406E-15,\r\n    -1.6232421573067722E-15, 0.63245553203367355, -0.632455532033674,\r\n    -0.44719968286778644, -0.44719968286778211, -0.44719968286778433,\r\n    -0.44719968286778444, 0.33880130274958375, -0.33880130274958392,\r\n    1.9877773668957365E-16, -3.1196963953294448E-16, 5.0495648039269789E-16,\r\n    -5.4980892339209908E-16, 0.3388013027495837, -0.33880130274958364,\r\n    -7.071067811865977E-6, -7.0710678118659753E-6, -7.0710678118659533E-6,\r\n    -7.0710678118659753E-6, 0.63245553203367655, -0.63245553203367677,\r\n    -1.511780731571699E-15, 1.1174027753835892E-15, 5.350692166131463E-15,\r\n    -5.350692166131463E-15, 0.63245553203367721, -0.6324555320336761,\r\n    -0.44719997816692708, -0.44719997816692936, -0.44719997816692725,\r\n    -0.44719997816692869, 0.33674014979417038, -0.33674014979417044,\r\n    -2.3476670411800417E-16, 1.1772148337128405E-16, 1.4146899419279464E-15,\r\n    -9.06689466517371E-16, 0.33674014979417166, -0.336740149794172,\r\n    -7.07106781186179E-6, -7.071067811861935E-6, -7.0710678118618782E-6,\r\n    -7.071067811861846E-6, 0.63245553203368077, -0.63245553203368066,\r\n    -6.2274709007454829E-16, 3.0257311138279619E-16, 0.0,\r\n    -9.8202197128542357E-16, 0.63245553203367588, -0.632455532033676,\r\n    -0.44720025997742285, -0.44720025997742441, -0.44720025997742424,\r\n    -0.44720025997742258, 0.33481722499595007, -0.33481722499594996,\r\n    4.09211922871326E-16, -5.0734129663804713E-16, 4.6006992251268125E-16,\r\n    -3.585745544237903E-16, 0.3348172249959479, -0.334817224995948,\r\n    -7.0710678118653841E-6, -7.0710678118653756E-6, -7.0710678118653129E-6,\r\n    -7.0710678118652918E-6, 0.63245553203367677, -0.63245553203367344,\r\n    -8.4991026015146543E-16, -1.6714909601391502E-15, 5.3327926245460953E-16,\r\n    4.847993295041905E-16, 0.63245553203367644, -0.63245553203367766,\r\n    -0.44720052916618175, -0.44720052916618142, -0.4472005291661823,\r\n    -0.4472005291661823, 0.33302168934545867, -0.33302168934545862,\r\n    -1.6256349094021589E-16, 1.8128322765223243E-16, 3.0201704915039509E-16,\r\n    3.7512487908288414E-16, 0.33302168934545923, -0.33302168934545984,\r\n    -7.0710678118663243E-6, -7.0710678118662811E-6, -7.0710678118661219E-6,\r\n    -7.071067811866049E-6, 0.63245553203367511, -0.63245553203367466,\r\n    1.3282233422116419E-15, -1.4105325488468542E-15, -1.8261133861669637E-15,\r\n    -2.00872472478366E-15, 0.63245553203367821, -0.63245553203367488,\r\n    -0.44720078652676065, -0.44720078652676043, -0.44720078652676282,\r\n    -0.44720078652675926, 0.33134370506110028, -0.33134370506110011,\r\n    2.2786573260592131E-16, -3.4087809973374207E-16, 4.5894204644506119E-17,\r\n    -2.3000731497769141E-16, 0.33134370506110095, -0.33134370506110083,\r\n    -7.0710678118661642E-6, -7.0710678118659482E-6, -7.0710678118658533E-6,\r\n    -7.07106781186579E-6, 0.63245553203367888, -0.63245553203367821,\r\n    -1.5244484067694801E-15, 2.9126049345106721E-16, 2.0095862334342676E-15,\r\n    -2.4115034801211209E-15, 0.63245553203367355, -0.63245553203367455,\r\n    -0.4472010327869464, -0.447201032786947, -0.44720103278694717,\r\n    -0.44720103278694223, 0.32977432828937886, -0.3297743282893788,\r\n    -7.1538282355794864E-16, 4.8133432455972172E-16, 5.265849628099444E-16,\r\n    -9.0319045104643613E-16, 0.32977432828937758, -0.32977432828937742,\r\n    -7.071067811866016E-6, -7.0710678118660253E-6, -7.0710678118657458E-6,\r\n    -7.0710678118657322E-6, 0.63245553203367355, -0.632455532033674,\r\n    -1.21669120313717E-16, -6.9959744180387269E-16, -2.7262634481899062E-15,\r\n    -6.3486577817179147E-15, 0.63245553203367855, -0.63245553203367133,\r\n    -0.44720126861540754, -0.44720126861540549, -0.44720126861540666,\r\n    -0.44720126861540133, 0.32830541495271481, -0.32830541495271454,\r\n    3.0089241768194747E-16, -1.0337824612284455E-15, -1.2002198627905689E-16,\r\n    -1.0713574899798631E-15, 0.32830541495271542, -0.3283054149527142,\r\n    -7.07106781186477E-6, -7.0710678118647768E-6, -7.0710678118650089E-6,\r\n    -7.0710678118650978E-6, 0.63245553203367444, -0.6324555320336761,\r\n    3.8647549225874774E-15, -3.0290409890578696E-15, -4.0116977800280808E-15,\r\n    4.8701680868653653E-15, 0.6324555320336781, -0.63245553203367866,\r\n    -0.44720149462754172, -0.44720149462754261, -0.4472014946275405,\r\n    -0.44720149462754505, 0.32692953792568741, -0.3269295379256873,\r\n    8.7849126989071138E-16, -1.1981897065443424E-15, -6.0420741958793208E-16,\r\n    9.3252685181895919E-16, 0.32692953792568735, -0.32692953792568763,\r\n    -7.0710678118655857E-6, -7.0710678118653748E-6, -7.0710678118650309E-6,\r\n    -7.0710678118650012E-6, 0.63245553203368032, -0.632455532033681,\r\n    1.50132929924542E-15, -6.653962832258769E-17, 9.6733066744665959E-15,\r\n    -1.1805937036523086E-14, 0.6324555320336761, -0.63245553203367433,\r\n    -0.44720171139067877, -0.44720171139067549, -0.44720171139068093,\r\n    -0.44720171139067916, 0.32563991400158393, -0.32563991400158337,\r\n    9.3321197019563521E-16, -8.5500194237406687E-16, 6.5254560128575475E-16,\r\n    -1.0424865292299867E-15, 0.32563991400158221, -0.32563991400158193,\r\n    -7.0710678118923409E-6, -7.0710678118922681E-6, -7.0710678118898828E-6,\r\n    -7.0710678118895237E-6, 0.63245553203366789, -0.63245553203368121,\r\n    7.1452655948415425E-15, 6.3046461130954787E-15, -5.2980634413101624E-15,\r\n    -3.5763952725348281E-16, 0.6324555320336771, -0.63245553203367233,\r\n    -0.44720191942862436, -0.44720191942862, -0.4472019194286202,\r\n    -0.44720191942861859, 0.32443033934430071, -0.32443033934430204,\r\n    7.0762686750278763E-16, 8.1945968679842652E-16, -1.656333070065799E-15,\r\n    6.8553136922126054E-16, 0.324430339344301, -0.32443033934430043,\r\n    -7.0710678118664031E-6, -7.0710678118664725E-6, -7.0710678118649631E-6,\r\n    -7.0710678118647209E-6, 0.632455532033672, -0.63245553203367744,\r\n    3.0589820713866974E-15, 2.1555319221936689E-15, -1.388275531727476E-15,\r\n    -4.9977919142189137E-16, 0.63245553203367677, -0.63245553203367511,\r\n    -0.44720211922577441, -0.44720211922577868, -0.44720211922577846,\r\n    -0.44720211922577641, 0.32329513231466706, -0.32329513231466656,\r\n    6.5754341484866414E-17, -3.6794741545106826E-16, -1.974355257175068E-17,\r\n    2.5392123824220389E-16, 0.32329513231466706, -0.32329513231466744,\r\n    -7.0710678118649843E-6, -7.0710678118649945E-6, -7.0710678118648284E-6,\r\n    -7.0710678118648064E-6, 0.63245553203367533, -0.63245553203367533,\r\n    -8.8706692207756183E-16, 1.2201338294651088E-15, -1.8043769495230298E-16,\r\n    -4.5109423738075745E-17, 0.63245553203367377, -0.63245553203367377,\r\n    -0.44720231123070692, -0.44720231123070753, -0.44720231123070947,\r\n    -0.44720231123070991, 0.32222908272238077, -0.32222908272238054,\r\n    -5.6286146803039267E-16, 3.3663844522523627E-16, -4.3977751054022952E-18,\r\n    -1.0662452735711336E-16, 0.32222908272238004, -0.32222908272237988,\r\n    -7.0710678118660355E-6, -7.0710678118660778E-6, -7.0710678118659262E-6,\r\n    -7.071067811865938E-6, 0.63245553203367644, -0.63245553203367755,\r\n    2.1224706601266014E-15, -3.0383877394713175E-16, -6.2401606193995269E-15,\r\n    7.1508439585250929E-15, 0.63245553203367944, -0.63245553203368088,\r\n    -0.44720249585940325, -0.44720249585940441, -0.44720249585940269,\r\n    -0.44720249585940153, 0.32122740669095368, -0.32122740669095351,\r\n    3.4977570815954532E-16, 3.5884098948533615E-17, -6.2886009600457394E-16,\r\n    1.269492905016327E-15, 0.321227406690954, -0.32122740669095484,\r\n    -7.07106781186332E-6, -7.0710678118633444E-6, -7.0710678118634063E-6,\r\n    -7.0710678118634495E-6, 0.6324555320336821, -0.6324555320336781,\r\n    -4.0311296529422388E-16, -3.3295972005431446E-15, 4.1804385690325528E-15,\r\n    1.9180835787325829E-15, 0.63245553203367355, -0.63245553203368,\r\n    -0.44720267349815823, -0.44720267349815973, -0.44720267349815518,\r\n    -0.44720267349815696, 0.32028570643739557, -0.32028570643739473,\r\n    -6.0211474942244068E-17, -5.4990330270424153E-16, 6.6077186620002334E-16,\r\n    1.6507123211891691E-18, 0.32028570643739457, -0.32028570643739529,\r\n    -7.0710678118655154E-6, -7.0710678118652265E-6, -7.0710678118651444E-6,\r\n    -7.0710678118650969E-6, 0.6324555320336761, -0.63245553203367633,\r\n    -6.9412562227737586E-17, -7.17723598355659E-16, -1.071985882137421E-16,\r\n    -3.2159576464122632E-16, 0.6324555320336761, -0.63245553203367577,\r\n    -0.44720284450613645, -0.44720284450613867, -0.44720284450613956,\r\n    -0.44720284450613856, 0.31939993436516795, -0.31939993436516789,\r\n    -4.2447130549824478E-16, 1.8553703450539162E-17, -9.508621125331059E-17,\r\n    -9.414268365938442E-17, 0.31939993436516856, -0.31939993436516828,\r\n    -7.0710678111972758E-6, -7.07106781119816E-6, -7.0710678111903412E-6,\r\n    -7.0710678111889453E-6, 0.63245553203367144, -0.63245553203367755,\r\n    2.133673565853635E-15, 2.9174720186161949E-15, 5.148440595780641E-16,\r\n    -8.3404076845719613E-16, 0.6324555320336771, -0.63245553203367733,\r\n    -0.44720300921769918, -0.44720300921769818, -0.44720300921769573,\r\n    -0.44720300921769623, 0.31856636095084534, -0.31856636095084612,\r\n    -2.744357980594029E-19, 4.7963678254505168E-16, 6.4969135757198638E-16,\r\n    -5.5773660360038413E-16, 0.31856636095084584, -0.318566360950846,\r\n    -7.0710678118655772E-6, -7.0710678118655687E-6, -7.0710678118653129E-6,\r\n    -7.0710678118652968E-6, 0.63245553203367677, -0.63245553203367544,\r\n    -1.7102410069732596E-15, 9.2482176602366711E-16, 6.09036773461924E-16,\r\n    -1.9184658364050604E-15, 0.63245553203367744, -0.63245553203367555,\r\n    -0.44720316794448656, -0.44720316794448611, -0.44720316794449178,\r\n    -0.44720316794449144, 0.31778154597447977, -0.31778154597447977,\r\n    -1.545139955932761E-16, 3.2061621290022958E-16, 1.2414212359384725E-16,\r\n    2.9188613023879017E-16, 0.317781545974479, -0.31778154597447911,\r\n    -7.0710678118652714E-6, -7.0710678118652291E-6, -7.0710678118644219E-6,\r\n    -7.0710678118643888E-6, 0.6324555320336771, -0.6324555320336771,\r\n    -1.6981815153015948E-15, 9.2628082652814268E-16, -2.0509494132879534E-16,\r\n    1.2042956634914363E-15, 0.63245553203367555, -0.63245553203367721,\r\n    -0.4472033209772901, -0.44720332097728754, -0.44720332097728582,\r\n    -0.44720332097728382, 0.31704231270307703, -0.31704231270307776,\r\n    1.2324770487657684E-16, 5.6550734247629737E-16, -4.6406913566639856E-16,\r\n    8.1304725130419043E-17, 0.31704231270307737, -0.31704231270307731,\r\n    -7.0710678118642957E-6, -7.0710678118642491E-6, -7.0710678118649267E-6,\r\n    -7.0710678118649004E-6, 0.63245553203367721, -0.6324555320336771,\r\n    1.4307371591463388E-16, 3.1555781752619254E-16, -3.9679865066038566E-15,\r\n    -2.2608295212045229E-15, 0.63245553203367988, -0.63245553203367366,\r\n    -0.44720346858774435, -0.44720346858774129, -0.44720346858773613,\r\n    -0.44720346858773352, 0.3163457246872422, -0.31634572468724248,\r\n    1.7473295846806246E-16, 1.4609811069358975E-16, -7.8704418992646712E-16,\r\n    -1.7989915022837016E-16, 0.31634572468724237, -0.3163457246872412,\r\n    -7.0710678118636595E-6, -7.0710678118636036E-6, -7.0710678118625008E-6,\r\n    -7.0710678118624982E-6, 0.63245553203367355, -0.6324555320336761,\r\n    1.449115145017837E-15, 8.2077253471199976E-16, 1.2015659338005493E-15,\r\n    2.9785384910107552E-15, 0.63245553203367411, -0.63245553203367844,\r\n    -0.4472036110298544, -0.44720361102985384, -0.44720361102985318,\r\n    -0.44720361102985334, 0.31568906487450754, -0.31568906487450732,\r\n    -6.3101036740168545E-16, 5.1135171678351077E-16, 2.8833689385423666E-16,\r\n    5.11029476372624E-16, 0.31568906487450776, -0.31568906487450848,\r\n    -7.0710678118631827E-6, -7.0710678118631852E-6, -7.0710678118626406E-6,\r\n    -7.0710678118626211E-6, 0.63245553203367533, -0.63245553203367855,\r\n    4.7603126462736867E-15, -1.624106667552199E-15, -1.7127059440325454E-15,\r\n    -1.5237914083063695E-15, 0.63245553203367688, -0.63245553203367433,\r\n    -0.44720374854138611, -0.447203748541388, -0.44720374854138822,\r\n    -0.44720374854138678, 0.31506981678024237, -0.31506981678024282,\r\n    5.4157944421149006E-16, -1.7284305746596217E-17, -4.2733885334731109E-18,\r\n    -2.0013386935677202E-16, 0.31506981678024248, -0.31506981678024232,\r\n    -7.0710678118656492E-6, -7.0710678118647327E-6, -7.071067811858579E-6,\r\n    -7.0710678118587146E-6, 0.6324555320336781, -0.63245553203367966,\r\n    -1.0014818800604527E-15, 2.4805935798420445E-15, 1.0585830187153658E-15,\r\n    1.4243798475892445E-15, 0.63245553203367466, -0.63245553203367577,\r\n    -0.44720388134510847, -0.447203881345111, -0.44720388134510797,\r\n    -0.4472038813451103, 0.31448564748912439, -0.31448564748912516,\r\n    1.6535862530536583E-16, 5.1569088104524133E-16, -1.9063087792468982E-16,\r\n    4.8232868304416388E-16, 0.314485647489124, -0.31448564748912422,\r\n    -7.07106781186909E-6, -7.071067811869045E-6, -7.0710678118694007E-6,\r\n    -7.0710678118694295E-6, 0.63245553203367566, -0.63245553203367844,\r\n    -2.4806102068899035E-15, 4.59820428594226E-15, -6.268174402882736E-16,\r\n    -3.5796084451361827E-15, 0.63245553203367777, -0.63245553203367355,\r\n    -0.44720400964994028, -0.44720400964994111, -0.4472040096499415,\r\n    -0.44720400964994322, 0.31393439228800718, -0.31393439228800718,\r\n    -2.5071966110014021E-16, 3.409603800871784E-16, 2.3976658557857506E-16,\r\n    1.3488562450472678E-17, 0.31393439228800712, -0.31393439228800718 },\r\n\r\n  /* Expression: controller.velocities\r\n   * Referenced by: '<S9>/1-D Lookup Table'\r\n   */\r\n  { 30.0, 31.836734693877553, 33.673469387755105, 35.510204081632651,\r\n    37.3469387755102, 39.183673469387756, 41.020408163265309, 42.857142857142861,\r\n    44.693877551020407, 46.530612244897959, 48.367346938775512,\r\n    50.204081632653057, 52.040816326530617, 53.877551020408163,\r\n    55.714285714285715, 57.551020408163268, 59.387755102040813,\r\n    61.224489795918366, 63.061224489795919, 64.897959183673464,\r\n    66.734693877551024, 68.571428571428569, 70.408163265306115,\r\n    72.244897959183675, 74.081632653061234, 75.918367346938766,\r\n    77.755102040816325, 79.591836734693885, 81.428571428571431,\r\n    83.265306122448976, 85.102040816326536, 86.938775510204081,\r\n    88.775510204081627, 90.612244897959187, 92.448979591836732,\r\n    94.285714285714292, 96.122448979591837, 97.959183673469383,\r\n    99.795918367346943, 101.63265306122449, 103.46938775510205,\r\n    105.30612244897959, 107.14285714285714, 108.9795918367347,\r\n    110.81632653061224, 112.65306122448979, 114.48979591836735,\r\n    116.32653061224489, 118.16326530612245, 120.0 },\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/phi'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/theta'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/psi'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/p'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/q'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/r'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S16>/Integrator5'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S16>/Integrator3'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S16>/Integrator2'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S16>/Integrator'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S16>/Integrator1'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 3.27\r\n   * Referenced by: '<Root>/Motor Speed'\r\n   */\r\n  3.27,\r\n\r\n  /* Expression: -3.27\r\n   * Referenced by: '<Root>/Motor Speed'\r\n   */\r\n  -3.27,\r\n\r\n  /* Expression: 0.23\r\n   * Referenced by: '<Root>/Max Deflection'\r\n   */\r\n  0.23,\r\n\r\n  /* Expression: -0.23\r\n   * Referenced by: '<Root>/Max Deflection'\r\n   */\r\n  -0.23,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S22>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S23>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S24>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S25>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: OR.h\r\n   * Referenced by: '<Root>/OpenRocket alt'\r\n   */\r\n  { 6.229, 6.76, 7.592, 8.92, 11.058, 13.392, 15.913, 18.611, 21.48, 24.512,\r\n    27.7, 31.038, 34.525, 38.154, 41.922, 45.76, 49.342, 53.142, 57.383, 61.737,\r\n    66.197, 70.753, 75.389, 80.093, 84.855, 89.666, 94.516, 99.395, 104.295,\r\n    109.207, 114.127, 119.051, 123.974, 128.89, 133.792, 138.676, 141.689,\r\n    146.188, 150.999, 155.779, 160.529, 165.248, 169.938, 174.597, 179.226,\r\n    183.824, 188.393, 192.931, 197.438, 201.915, 206.362, 210.779, 215.166,\r\n    219.523, 223.85, 228.148, 232.417, 236.656, 240.867, 245.048, 249.2, 253.324,\r\n    257.418, 261.483, 265.519, 269.526, 273.505, 277.454, 281.374, 285.266,\r\n    289.129, 292.963, 296.769, 300.547, 304.296, 308.017, 311.71, 315.375,\r\n    319.012, 322.621, 326.202, 329.755, 333.28, 336.778, 340.247, 343.689,\r\n    347.103, 350.49, 353.849, 357.18, 360.484, 363.76, 367.009, 370.231, 373.425,\r\n    376.592, 379.732, 382.845, 385.931, 388.99, 392.023, 395.028, 398.007,\r\n    400.958, 403.883, 406.781, 409.653, 412.497, 415.315, 418.106, 420.871,\r\n    423.608, 426.319, 429.004, 431.662, 434.294, 436.899, 439.479, 442.032,\r\n    444.559, 447.06, 449.535, 451.983, 454.406, 456.803, 459.174, 461.519,\r\n    463.838, 466.131, 468.398, 470.639, 472.855, 475.044, 477.208, 479.347,\r\n    481.459, 483.546, 485.607, 487.643, 489.653, 491.638, 493.597, 495.53,\r\n    497.439, 499.322, 501.18, 503.012, 504.819, 506.601, 508.357, 510.088,\r\n    511.794, 513.474, 515.129, 516.758, 518.362, 519.941, 521.495, 523.023,\r\n    524.526, 526.004, 527.457, 528.884, 530.287, 531.664, 533.016, 534.343,\r\n    535.646, 536.923, 538.176, 539.403, 540.606, 541.784, 542.936, 544.064,\r\n    545.168, 546.246, 547.3, 548.329, 549.334, 550.314, 551.269, 552.201,\r\n    553.107, 553.989, 554.846, 555.679, 556.488, 557.272, 558.031, 558.767,\r\n    559.477, 560.164, 560.826, 561.463, 562.077, 562.666, 563.231, 563.772,\r\n    564.289, 564.781, 565.249, 565.694, 566.114, 566.51, 566.882, 567.23,\r\n    567.554, 567.855, 568.131, 568.384, 568.613, 568.818, 569.0, 569.157,\r\n    569.292, 569.402, 569.489, 569.553, 569.594, 569.611, 569.604, 569.574 },\r\n\r\n  /* Expression: OR.t\r\n   * Referenced by: '<Root>/OpenRocket alt'\r\n   */\r\n  { 0.0, 0.015000000000000013, 0.038000000000000034, 0.071000000000000008, 0.121,\r\n    0.17100000000000004, 0.22099999999999997, 0.271, 0.32100000000000006, 0.371,\r\n    0.42100000000000004, 0.471, 0.521, 0.57100000000000006, 0.621, 0.67, 0.715,\r\n    0.761, 0.811, 0.8610000000000001, 0.91099999999999992, 0.961,\r\n    1.0110000000000001, 1.061, 1.1110000000000002, 1.161, 1.2109999999999999,\r\n    1.2610000000000001, 1.311, 1.3610000000000002, 1.411, 1.4609999999999999,\r\n    1.5110000000000001, 1.561, 1.6110000000000002, 1.661, 1.6920000000000002,\r\n    1.738, 1.7880000000000003, 1.838, 1.8880000000000003, 1.9380000000000002,\r\n    1.988, 2.0380000000000003, 2.088, 2.1380000000000003, 2.188, 2.238,\r\n    2.2880000000000003, 2.338, 2.3880000000000003, 2.438, 2.488,\r\n    2.5380000000000003, 2.588, 2.6380000000000003, 2.688, 2.738,\r\n    2.7880000000000003, 2.838, 2.8880000000000003, 2.938, 2.988,\r\n    3.0380000000000003, 3.088, 3.1380000000000003, 3.188, 3.238,\r\n    3.2880000000000003, 3.338, 3.3880000000000003, 3.438, 3.488,\r\n    3.5380000000000003, 3.588, 3.6380000000000003, 3.688, 3.738, 3.788,\r\n    3.8380000000000005, 3.8880000000000003, 3.938, 3.988, 4.0379999999999994,\r\n    4.088, 4.138, 4.188, 4.2379999999999995, 4.2879999999999994, 4.338, 4.388,\r\n    4.438, 4.4879999999999995, 4.5379999999999994, 4.588, 4.638, 4.688,\r\n    4.7379999999999995, 4.7879999999999994, 4.838, 4.888, 4.938,\r\n    4.9879999999999995, 5.0379999999999994, 5.088, 5.138, 5.188,\r\n    5.2379999999999995, 5.2879999999999994, 5.338, 5.388, 5.438,\r\n    5.4879999999999995, 5.5379999999999994, 5.588, 5.638, 5.688,\r\n    5.7379999999999995, 5.7879999999999994, 5.838, 5.888, 5.938,\r\n    5.9879999999999995, 6.0379999999999994, 6.088, 6.138, 6.188,\r\n    6.2379999999999995, 6.2879999999999994, 6.338, 6.388, 6.438,\r\n    6.4879999999999995, 6.5379999999999994, 6.588, 6.638, 6.688,\r\n    6.7379999999999995, 6.7879999999999994, 6.838, 6.888, 6.938,\r\n    6.9879999999999995, 7.0379999999999994, 7.088, 7.138, 7.188,\r\n    7.2379999999999995, 7.2879999999999994, 7.338, 7.388, 7.438,\r\n    7.4879999999999995, 7.5379999999999994, 7.588, 7.638, 7.688, 7.738,\r\n    7.7879999999999994, 7.838, 7.887999999999999, 7.938, 7.988, 8.038,\r\n    8.088000000000001, 8.138, 8.188, 8.2380000000000013, 8.288,\r\n    8.338000000000001, 8.388, 8.438, 8.4880000000000013, 8.538,\r\n    8.588000000000001, 8.638, 8.688, 8.7380000000000013, 8.788,\r\n    8.838000000000001, 8.888, 8.938, 8.9880000000000013, 9.038,\r\n    9.088000000000001, 9.138, 9.188, 9.2380000000000013, 9.288,\r\n    9.338000000000001, 9.388, 9.438, 9.4880000000000013, 9.538,\r\n    9.588000000000001, 9.638, 9.688, 9.7380000000000013, 9.788,\r\n    9.838000000000001, 9.888, 9.938, 9.9880000000000013, 10.038,\r\n    10.088000000000001, 10.138, 10.188, 10.238000000000001, 10.288,\r\n    10.338000000000001, 10.388, 10.438, 10.488000000000001, 10.538,\r\n    10.588000000000001, 10.638, 10.688, 10.738000000000001, 10.788,\r\n    10.838000000000001, 10.888, 10.938, 10.988000000000001 },\r\n\r\n  /* Expression: max_height_low\r\n   * Referenced by: '<S148>/Limit Function 10ft to 1000ft'\r\n   */\r\n  1000.0,\r\n\r\n  /* Expression: 10\r\n   * Referenced by: '<S148>/Limit Function 10ft to 1000ft'\r\n   */\r\n  10.0,\r\n\r\n  /* Expression: max_height_low\r\n   * Referenced by: '<S131>/Limit Height h<1000ft'\r\n   */\r\n  1000.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S131>/Limit Height h<1000ft'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0.1\r\n   * Referenced by: '<S131>/sigma_wg '\r\n   */\r\n  0.1,\r\n\r\n  /* Expression: h_vec\r\n   * Referenced by: '<S130>/PreLook-Up Index Search  (altitude)'\r\n   */\r\n  { 500.0, 1750.0, 3750.0, 7500.0, 15000.0, 25000.0, 35000.0, 45000.0, 55000.0,\r\n    65000.0, 75000.0, 80000.0 },\r\n\r\n  /* Expression: [1:7]\r\n   * Referenced by: '<S130>/PreLook-Up Index Search  (prob of exceed)'\r\n   */\r\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 },\r\n\r\n  /* Expression: sigma_vec'\r\n   * Referenced by: '<S130>/Medium//High Altitude Intensity'\r\n   */\r\n  { 3.2, 2.2, 1.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 4.2, 3.6, 3.3,\r\n    1.6, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6.6, 6.9, 7.4, 6.7, 4.6, 2.7,\r\n    0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 8.6, 9.6, 10.6, 10.1, 8.0, 6.6, 5.0, 4.2, 2.7,\r\n    0.0, 0.0, 0.0, 11.8, 13.0, 16.0, 15.1, 11.6, 9.7, 8.1, 8.2, 7.9, 4.9, 3.2,\r\n    2.1, 15.6, 17.6, 23.0, 23.6, 22.1, 20.0, 16.0, 15.1, 12.1, 7.9, 6.2, 5.1,\r\n    18.7, 21.5, 28.4, 30.2, 30.7, 31.0, 25.2, 23.1, 17.5, 10.7, 8.4, 7.2 },\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S123>/White Noise'\r\n   */\r\n  0.0,\r\n\r\n  /* Computed Parameter: WhiteNoise_StdDev\r\n   * Referenced by: '<S123>/White Noise'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S120>/Lv'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S120>/Lw'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 5.00\r\n   * Referenced by: '<Root>/Windspeed'\r\n   */\r\n  5.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S41>/Integrator'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S1>/Constant1'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: -1\r\n   * Referenced by: '<S1>/Gain'\r\n   */\r\n  -1.0,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<S45>/1//2'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<S47>/Constant'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: 2\r\n   * Referenced by: '<S47>/Gain2'\r\n   */\r\n  2.0,\r\n\r\n  /* Expression: 2\r\n   * Referenced by: '<S47>/Gain'\r\n   */\r\n  2.0,\r\n\r\n  /* Expression: 2\r\n   * Referenced by: '<S47>/Gain1'\r\n   */\r\n  2.0,\r\n\r\n  /* Expression: 2\r\n   * Referenced by: '<S48>/Gain'\r\n   */\r\n  2.0,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<S48>/Constant'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: 2\r\n   * Referenced by: '<S48>/Gain2'\r\n   */\r\n  2.0,\r\n\r\n  /* Expression: 2\r\n   * Referenced by: '<S48>/Gain1'\r\n   */\r\n  2.0,\r\n\r\n  /* Expression: 2\r\n   * Referenced by: '<S49>/Gain'\r\n   */\r\n  2.0,\r\n\r\n  /* Expression: 2\r\n   * Referenced by: '<S49>/Gain1'\r\n   */\r\n  2.0,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<S49>/Constant'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: 2\r\n   * Referenced by: '<S49>/Gain2'\r\n   */\r\n  2.0,\r\n\r\n  /* Expression: 1\r\n   * Referenced by: '<S1>/Constant'\r\n   */\r\n  1.0,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S1>/Constant16'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S27>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S28>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S19>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S20>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: aptos.A_ref\r\n   * Referenced by: '<Root>/Constant6'\r\n   */\r\n  0.0083322891154835269,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<Root>/Constant32'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: aptos.A_plan_nose\r\n   * Referenced by: '<Root>/Constant33'\r\n   */\r\n  0.0349,\r\n\r\n  /* Expression: aptos.K_const\r\n   * Referenced by: '<Root>/Constant34'\r\n   */\r\n  1.1,\r\n\r\n  /* Expression: aptos.CP_nose\r\n   * Referenced by: '<Root>/Constant22'\r\n   */\r\n  0.236,\r\n\r\n  /* Expression: aptos.A_plan_body\r\n   * Referenced by: '<Root>/Constant35'\r\n   */\r\n  0.16098899999999997,\r\n\r\n  /* Expression: aptos.K_const\r\n   * Referenced by: '<Root>/Constant36'\r\n   */\r\n  1.1,\r\n\r\n  /* Expression: aptos.CP_body\r\n   * Referenced by: '<Root>/Constant23'\r\n   */\r\n  1.2885,\r\n\r\n  /* Expression: aptos.ss_fin\r\n   * Referenced by: '<Root>/Constant39'\r\n   */\r\n  0.14,\r\n\r\n  /* Expression: OR.M\r\n   * Referenced by: '<Root>/OpenRocket Mach No'\r\n   */\r\n  { 0.103, 0.107, 0.112, 0.121, 0.132, 0.143, 0.154, 0.164, 0.174, 0.183, 0.192,\r\n    0.201, 0.21, 0.218, 0.226, 0.234, 0.24, 0.247, 0.254, 0.26, 0.267, 0.272,\r\n    0.276, 0.28, 0.283, 0.286, 0.288, 0.289, 0.29, 0.291, 0.291, 0.291, 0.291,\r\n    0.291, 0.29, 0.288, 0.287, 0.286, 0.284, 0.282, 0.28, 0.278, 0.277, 0.275,\r\n    0.273, 0.271, 0.27, 0.268, 0.266, 0.264, 0.263, 0.261, 0.259, 0.257, 0.256,\r\n    0.254, 0.252, 0.251, 0.249, 0.247, 0.245, 0.244, 0.242, 0.24, 0.239, 0.237,\r\n    0.235, 0.234, 0.232, 0.23, 0.229, 0.227, 0.225, 0.224, 0.222, 0.221, 0.219,\r\n    0.217, 0.216, 0.214, 0.212, 0.211, 0.209, 0.207, 0.206, 0.204, 0.202, 0.201,\r\n    0.199, 0.198, 0.196, 0.194, 0.193, 0.191, 0.19, 0.188, 0.186, 0.185, 0.183,\r\n    0.182, 0.18, 0.179, 0.177, 0.175, 0.174, 0.172, 0.171, 0.169, 0.168, 0.166,\r\n    0.164, 0.163, 0.161, 0.16, 0.158, 0.157, 0.155, 0.154, 0.152, 0.151, 0.149,\r\n    0.148, 0.146, 0.145, 0.143, 0.141, 0.14, 0.138, 0.137, 0.135, 0.134, 0.133,\r\n    0.131, 0.13, 0.128, 0.127, 0.125, 0.124, 0.122, 0.121, 0.12, 0.118, 0.117,\r\n    0.116, 0.114, 0.112, 0.111, 0.11, 0.108, 0.107, 0.105, 0.104, 0.102, 0.101,\r\n    0.1, 0.098, 0.096, 0.095, 0.094, 0.092, 0.091, 0.089, 0.088, 0.086, 0.085,\r\n    0.084, 0.083, 0.081, 0.079, 0.078, 0.076, 0.075, 0.073, 0.073, 0.071, 0.069,\r\n    0.068, 0.067, 0.066, 0.065, 0.063, 0.062, 0.06, 0.059, 0.057, 0.056, 0.055,\r\n    0.053, 0.052, 0.051, 0.049, 0.048, 0.047, 0.046, 0.044, 0.044, 0.043, 0.041,\r\n    0.04, 0.039, 0.037, 0.036, 0.035, 0.034, 0.033, 0.033, 0.031, 0.031, 0.029,\r\n    0.028, 0.027, 0.026, 0.027, 0.026, 0.025, 0.025, 0.025, 0.024, 0.024, 0.024,\r\n    0.025, 0.024, 0.024 },\r\n\r\n  /* Expression: OR.t\r\n   * Referenced by: '<Root>/OpenRocket Mach No'\r\n   */\r\n  { 0.0, 0.015000000000000013, 0.038000000000000034, 0.071000000000000008, 0.121,\r\n    0.17100000000000004, 0.22099999999999997, 0.271, 0.32100000000000006, 0.371,\r\n    0.42100000000000004, 0.471, 0.521, 0.57100000000000006, 0.621, 0.67, 0.715,\r\n    0.761, 0.811, 0.8610000000000001, 0.91099999999999992, 0.961,\r\n    1.0110000000000001, 1.061, 1.1110000000000002, 1.161, 1.2109999999999999,\r\n    1.2610000000000001, 1.311, 1.3610000000000002, 1.411, 1.4609999999999999,\r\n    1.5110000000000001, 1.561, 1.6110000000000002, 1.661, 1.6920000000000002,\r\n    1.738, 1.7880000000000003, 1.838, 1.8880000000000003, 1.9380000000000002,\r\n    1.988, 2.0380000000000003, 2.088, 2.1380000000000003, 2.188, 2.238,\r\n    2.2880000000000003, 2.338, 2.3880000000000003, 2.438, 2.488,\r\n    2.5380000000000003, 2.588, 2.6380000000000003, 2.688, 2.738,\r\n    2.7880000000000003, 2.838, 2.8880000000000003, 2.938, 2.988,\r\n    3.0380000000000003, 3.088, 3.1380000000000003, 3.188, 3.238,\r\n    3.2880000000000003, 3.338, 3.3880000000000003, 3.438, 3.488,\r\n    3.5380000000000003, 3.588, 3.6380000000000003, 3.688, 3.738, 3.788,\r\n    3.8380000000000005, 3.8880000000000003, 3.938, 3.988, 4.0379999999999994,\r\n    4.088, 4.138, 4.188, 4.2379999999999995, 4.2879999999999994, 4.338, 4.388,\r\n    4.438, 4.4879999999999995, 4.5379999999999994, 4.588, 4.638, 4.688,\r\n    4.7379999999999995, 4.7879999999999994, 4.838, 4.888, 4.938,\r\n    4.9879999999999995, 5.0379999999999994, 5.088, 5.138, 5.188,\r\n    5.2379999999999995, 5.2879999999999994, 5.338, 5.388, 5.438,\r\n    5.4879999999999995, 5.5379999999999994, 5.588, 5.638, 5.688,\r\n    5.7379999999999995, 5.7879999999999994, 5.838, 5.888, 5.938,\r\n    5.9879999999999995, 6.0379999999999994, 6.088, 6.138, 6.188,\r\n    6.2379999999999995, 6.2879999999999994, 6.338, 6.388, 6.438,\r\n    6.4879999999999995, 6.5379999999999994, 6.588, 6.638, 6.688,\r\n    6.7379999999999995, 6.7879999999999994, 6.838, 6.888, 6.938,\r\n    6.9879999999999995, 7.0379999999999994, 7.088, 7.138, 7.188,\r\n    7.2379999999999995, 7.2879999999999994, 7.338, 7.388, 7.438,\r\n    7.4879999999999995, 7.5379999999999994, 7.588, 7.638, 7.688, 7.738,\r\n    7.7879999999999994, 7.838, 7.887999999999999, 7.938, 7.988, 8.038,\r\n    8.088000000000001, 8.138, 8.188, 8.2380000000000013, 8.288,\r\n    8.338000000000001, 8.388, 8.438, 8.4880000000000013, 8.538,\r\n    8.588000000000001, 8.638, 8.688, 8.7380000000000013, 8.788,\r\n    8.838000000000001, 8.888, 8.938, 8.9880000000000013, 9.038,\r\n    9.088000000000001, 9.138, 9.188, 9.2380000000000013, 9.288,\r\n    9.338000000000001, 9.388, 9.438, 9.4880000000000013, 9.538,\r\n    9.588000000000001, 9.638, 9.688, 9.7380000000000013, 9.788,\r\n    9.838000000000001, 9.888, 9.938, 9.9880000000000013, 10.038,\r\n    10.088000000000001, 10.138, 10.188, 10.238000000000001, 10.288,\r\n    10.338000000000001, 10.388, 10.438, 10.488000000000001, 10.538,\r\n    10.588000000000001, 10.638, 10.688, 10.738000000000001, 10.788,\r\n    10.838000000000001, 10.888, 10.938, 10.988000000000001 },\r\n\r\n  /* Expression: aptos.S_fin\r\n   * Referenced by: '<Root>/Constant40'\r\n   */\r\n  0.012950000000000001,\r\n\r\n  /* Expression: aptos.G_c_fin\r\n   * Referenced by: '<Root>/Constant41'\r\n   */\r\n  0.19395914725989308,\r\n\r\n  /* Expression: aptos.d_body\r\n   * Referenced by: '<Root>/Constant11'\r\n   */\r\n  0.103,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<Root>/Gain2'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: aptos.CP_fins\r\n   * Referenced by: '<Root>/Constant24'\r\n   */\r\n  2.0,\r\n\r\n  /* Expression: pInitialization.M\r\n   * Referenced by: '<S53>/KalmanGainM'\r\n   */\r\n  0.56639110926865932,\r\n\r\n  /* Expression: pInitialization.C\r\n   * Referenced by: '<S52>/C'\r\n   */\r\n  1.5,\r\n\r\n  /* Expression: pInitialization.X0\r\n   * Referenced by: '<S52>/X0'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<S8>/Gain3'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: pInitialization.A\r\n   * Referenced by: '<S52>/A'\r\n   */\r\n  2.0,\r\n\r\n  /* Expression: pInitialization.B\r\n   * Referenced by: '<S52>/B'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: pInitialization.Z\r\n   * Referenced by: '<S53>/CovarianceZ'\r\n   */\r\n  0.3775940728457729,\r\n\r\n  /* Expression: pInitialization.L\r\n   * Referenced by: '<S53>/KalmanGainL'\r\n   */\r\n  1.1327822185373198,\r\n\r\n  /* Expression: pInitialization.D\r\n   * Referenced by: '<S52>/D'\r\n   */\r\n  0.0,\r\n\r\n  /* Expression: aptos.X_CP_can\r\n   * Referenced by: '<Root>/Constant25'\r\n   */\r\n  0.589,\r\n\r\n  /* Expression: aptos.S_can\r\n   * Referenced by: '<Root>/Constant28'\r\n   */\r\n  0.0038500000000000006,\r\n\r\n  /* Expression: aptos.ss_can\r\n   * Referenced by: '<Root>/Constant37'\r\n   */\r\n  0.07,\r\n\r\n  /* Expression: aptos.G_c_can\r\n   * Referenced by: '<Root>/Constant38'\r\n   */\r\n  0.071307464785290278,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<Root>/Gain'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: OR.I_L\r\n   * Referenced by: '<Root>/OpenRocket I_L'\r\n   */\r\n  { 3.131, 3.129, 3.126, 3.122, 3.116, 3.11, 3.105, 3.099, 3.094, 3.089, 3.084,\r\n    3.079, 3.074, 3.07, 3.065, 3.061, 3.057, 3.053, 3.049, 3.045, 3.042, 3.038,\r\n    3.036, 3.033, 3.031, 3.029, 3.027, 3.025, 3.024, 3.023, 3.022, 3.021, 3.02,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019, 3.019,\r\n    3.019, 3.019, 3.019 },\r\n\r\n  /* Expression: OR.t\r\n   * Referenced by: '<Root>/OpenRocket I_L'\r\n   */\r\n  { 0.0, 0.015000000000000013, 0.038000000000000034, 0.071000000000000008, 0.121,\r\n    0.17100000000000004, 0.22099999999999997, 0.271, 0.32100000000000006, 0.371,\r\n    0.42100000000000004, 0.471, 0.521, 0.57100000000000006, 0.621, 0.67, 0.715,\r\n    0.761, 0.811, 0.8610000000000001, 0.91099999999999992, 0.961,\r\n    1.0110000000000001, 1.061, 1.1110000000000002, 1.161, 1.2109999999999999,\r\n    1.2610000000000001, 1.311, 1.3610000000000002, 1.411, 1.4609999999999999,\r\n    1.5110000000000001, 1.561, 1.6110000000000002, 1.661, 1.6920000000000002,\r\n    1.738, 1.7880000000000003, 1.838, 1.8880000000000003, 1.9380000000000002,\r\n    1.988, 2.0380000000000003, 2.088, 2.1380000000000003, 2.188, 2.238,\r\n    2.2880000000000003, 2.338, 2.3880000000000003, 2.438, 2.488,\r\n    2.5380000000000003, 2.588, 2.6380000000000003, 2.688, 2.738,\r\n    2.7880000000000003, 2.838, 2.8880000000000003, 2.938, 2.988,\r\n    3.0380000000000003, 3.088, 3.1380000000000003, 3.188, 3.238,\r\n    3.2880000000000003, 3.338, 3.3880000000000003, 3.438, 3.488,\r\n    3.5380000000000003, 3.588, 3.6380000000000003, 3.688, 3.738, 3.788,\r\n    3.8380000000000005, 3.8880000000000003, 3.938, 3.988, 4.0379999999999994,\r\n    4.088, 4.138, 4.188, 4.2379999999999995, 4.2879999999999994, 4.338, 4.388,\r\n    4.438, 4.4879999999999995, 4.5379999999999994, 4.588, 4.638, 4.688,\r\n    4.7379999999999995, 4.7879999999999994, 4.838, 4.888, 4.938,\r\n    4.9879999999999995, 5.0379999999999994, 5.088, 5.138, 5.188,\r\n    5.2379999999999995, 5.2879999999999994, 5.338, 5.388, 5.438,\r\n    5.4879999999999995, 5.5379999999999994, 5.588, 5.638, 5.688,\r\n    5.7379999999999995, 5.7879999999999994, 5.838, 5.888, 5.938,\r\n    5.9879999999999995, 6.0379999999999994, 6.088, 6.138, 6.188,\r\n    6.2379999999999995, 6.2879999999999994, 6.338, 6.388, 6.438,\r\n    6.4879999999999995, 6.5379999999999994, 6.588, 6.638, 6.688,\r\n    6.7379999999999995, 6.7879999999999994, 6.838, 6.888, 6.938,\r\n    6.9879999999999995, 7.0379999999999994, 7.088, 7.138, 7.188,\r\n    7.2379999999999995, 7.2879999999999994, 7.338, 7.388, 7.438,\r\n    7.4879999999999995, 7.5379999999999994, 7.588, 7.638, 7.688, 7.738,\r\n    7.7879999999999994, 7.838, 7.887999999999999, 7.938, 7.988, 8.038,\r\n    8.088000000000001, 8.138, 8.188, 8.2380000000000013, 8.288,\r\n    8.338000000000001, 8.388, 8.438, 8.4880000000000013, 8.538,\r\n    8.588000000000001, 8.638, 8.688, 8.7380000000000013, 8.788,\r\n    8.838000000000001, 8.888, 8.938, 8.9880000000000013, 9.038,\r\n    9.088000000000001, 9.138, 9.188, 9.2380000000000013, 9.288,\r\n    9.338000000000001, 9.388, 9.438, 9.4880000000000013, 9.538,\r\n    9.588000000000001, 9.638, 9.688, 9.7380000000000013, 9.788,\r\n    9.838000000000001, 9.888, 9.938, 9.9880000000000013, 10.038,\r\n    10.088000000000001, 10.138, 10.188, 10.238000000000001, 10.288,\r\n    10.338000000000001, 10.388, 10.438, 10.488000000000001, 10.538,\r\n    10.588000000000001, 10.638, 10.688, 10.738000000000001, 10.788,\r\n    10.838000000000001, 10.888, 10.938, 10.988000000000001 },\r\n\r\n  /* Expression: OR.I_R\r\n   * Referenced by: '<Root>/OpenRocket I_R'\r\n   */\r\n  { 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017, 0.017,\r\n    0.017, 0.017, 0.017 },\r\n\r\n  /* Expression: OR.t\r\n   * Referenced by: '<Root>/OpenRocket I_R'\r\n   */\r\n  { 0.0, 0.015000000000000013, 0.038000000000000034, 0.071000000000000008, 0.121,\r\n    0.17100000000000004, 0.22099999999999997, 0.271, 0.32100000000000006, 0.371,\r\n    0.42100000000000004, 0.471, 0.521, 0.57100000000000006, 0.621, 0.67, 0.715,\r\n    0.761, 0.811, 0.8610000000000001, 0.91099999999999992, 0.961,\r\n    1.0110000000000001, 1.061, 1.1110000000000002, 1.161, 1.2109999999999999,\r\n    1.2610000000000001, 1.311, 1.3610000000000002, 1.411, 1.4609999999999999,\r\n    1.5110000000000001, 1.561, 1.6110000000000002, 1.661, 1.6920000000000002,\r\n    1.738, 1.7880000000000003, 1.838, 1.8880000000000003, 1.9380000000000002,\r\n    1.988, 2.0380000000000003, 2.088, 2.1380000000000003, 2.188, 2.238,\r\n    2.2880000000000003, 2.338, 2.3880000000000003, 2.438, 2.488,\r\n    2.5380000000000003, 2.588, 2.6380000000000003, 2.688, 2.738,\r\n    2.7880000000000003, 2.838, 2.8880000000000003, 2.938, 2.988,\r\n    3.0380000000000003, 3.088, 3.1380000000000003, 3.188, 3.238,\r\n    3.2880000000000003, 3.338, 3.3880000000000003, 3.438, 3.488,\r\n    3.5380000000000003, 3.588, 3.6380000000000003, 3.688, 3.738, 3.788,\r\n    3.8380000000000005, 3.8880000000000003, 3.938, 3.988, 4.0379999999999994,\r\n    4.088, 4.138, 4.188, 4.2379999999999995, 4.2879999999999994, 4.338, 4.388,\r\n    4.438, 4.4879999999999995, 4.5379999999999994, 4.588, 4.638, 4.688,\r\n    4.7379999999999995, 4.7879999999999994, 4.838, 4.888, 4.938,\r\n    4.9879999999999995, 5.0379999999999994, 5.088, 5.138, 5.188,\r\n    5.2379999999999995, 5.2879999999999994, 5.338, 5.388, 5.438,\r\n    5.4879999999999995, 5.5379999999999994, 5.588, 5.638, 5.688,\r\n    5.7379999999999995, 5.7879999999999994, 5.838, 5.888, 5.938,\r\n    5.9879999999999995, 6.0379999999999994, 6.088, 6.138, 6.188,\r\n    6.2379999999999995, 6.2879999999999994, 6.338, 6.388, 6.438,\r\n    6.4879999999999995, 6.5379999999999994, 6.588, 6.638, 6.688,\r\n    6.7379999999999995, 6.7879999999999994, 6.838, 6.888, 6.938,\r\n    6.9879999999999995, 7.0379999999999994, 7.088, 7.138, 7.188,\r\n    7.2379999999999995, 7.2879999999999994, 7.338, 7.388, 7.438,\r\n    7.4879999999999995, 7.5379999999999994, 7.588, 7.638, 7.688, 7.738,\r\n    7.7879999999999994, 7.838, 7.887999999999999, 7.938, 7.988, 8.038,\r\n    8.088000000000001, 8.138, 8.188, 8.2380000000000013, 8.288,\r\n    8.338000000000001, 8.388, 8.438, 8.4880000000000013, 8.538,\r\n    8.588000000000001, 8.638, 8.688, 8.7380000000000013, 8.788,\r\n    8.838000000000001, 8.888, 8.938, 8.9880000000000013, 9.038,\r\n    9.088000000000001, 9.138, 9.188, 9.2380000000000013, 9.288,\r\n    9.338000000000001, 9.388, 9.438, 9.4880000000000013, 9.538,\r\n    9.588000000000001, 9.638, 9.688, 9.7380000000000013, 9.788,\r\n    9.838000000000001, 9.888, 9.938, 9.9880000000000013, 10.038,\r\n    10.088000000000001, 10.138, 10.188, 10.238000000000001, 10.288,\r\n    10.338000000000001, 10.388, 10.438, 10.488000000000001, 10.538,\r\n    10.588000000000001, 10.638, 10.688, 10.738000000000001, 10.788,\r\n    10.838000000000001, 10.888, 10.938, 10.988000000000001 },\r\n\r\n  /* Expression: OR.X_CG\r\n   * Referenced by: '<Root>/OpenRocket X_CG'\r\n   */\r\n  { 1.316, 1.316, 1.315, 1.314, 1.313, 1.312, 1.311, 1.31, 1.309, 1.307, 1.306,\r\n    1.305, 1.304, 1.304, 1.303, 1.302, 1.301, 1.3, 1.299, 1.298, 1.298, 1.297,\r\n    1.296, 1.296, 1.295, 1.295, 1.295, 1.294, 1.294, 1.294, 1.294, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293, 1.293,\r\n    1.293, 1.293, 1.293 },\r\n\r\n  /* Expression: OR.t\r\n   * Referenced by: '<Root>/OpenRocket X_CG'\r\n   */\r\n  { 0.0, 0.015000000000000013, 0.038000000000000034, 0.071000000000000008, 0.121,\r\n    0.17100000000000004, 0.22099999999999997, 0.271, 0.32100000000000006, 0.371,\r\n    0.42100000000000004, 0.471, 0.521, 0.57100000000000006, 0.621, 0.67, 0.715,\r\n    0.761, 0.811, 0.8610000000000001, 0.91099999999999992, 0.961,\r\n    1.0110000000000001, 1.061, 1.1110000000000002, 1.161, 1.2109999999999999,\r\n    1.2610000000000001, 1.311, 1.3610000000000002, 1.411, 1.4609999999999999,\r\n    1.5110000000000001, 1.561, 1.6110000000000002, 1.661, 1.6920000000000002,\r\n    1.738, 1.7880000000000003, 1.838, 1.8880000000000003, 1.9380000000000002,\r\n    1.988, 2.0380000000000003, 2.088, 2.1380000000000003, 2.188, 2.238,\r\n    2.2880000000000003, 2.338, 2.3880000000000003, 2.438, 2.488,\r\n    2.5380000000000003, 2.588, 2.6380000000000003, 2.688, 2.738,\r\n    2.7880000000000003, 2.838, 2.8880000000000003, 2.938, 2.988,\r\n    3.0380000000000003, 3.088, 3.1380000000000003, 3.188, 3.238,\r\n    3.2880000000000003, 3.338, 3.3880000000000003, 3.438, 3.488,\r\n    3.5380000000000003, 3.588, 3.6380000000000003, 3.688, 3.738, 3.788,\r\n    3.8380000000000005, 3.8880000000000003, 3.938, 3.988, 4.0379999999999994,\r\n    4.088, 4.138, 4.188, 4.2379999999999995, 4.2879999999999994, 4.338, 4.388,\r\n    4.438, 4.4879999999999995, 4.5379999999999994, 4.588, 4.638, 4.688,\r\n    4.7379999999999995, 4.7879999999999994, 4.838, 4.888, 4.938,\r\n    4.9879999999999995, 5.0379999999999994, 5.088, 5.138, 5.188,\r\n    5.2379999999999995, 5.2879999999999994, 5.338, 5.388, 5.438,\r\n    5.4879999999999995, 5.5379999999999994, 5.588, 5.638, 5.688,\r\n    5.7379999999999995, 5.7879999999999994, 5.838, 5.888, 5.938,\r\n    5.9879999999999995, 6.0379999999999994, 6.088, 6.138, 6.188,\r\n    6.2379999999999995, 6.2879999999999994, 6.338, 6.388, 6.438,\r\n    6.4879999999999995, 6.5379999999999994, 6.588, 6.638, 6.688,\r\n    6.7379999999999995, 6.7879999999999994, 6.838, 6.888, 6.938,\r\n    6.9879999999999995, 7.0379999999999994, 7.088, 7.138, 7.188,\r\n    7.2379999999999995, 7.2879999999999994, 7.338, 7.388, 7.438,\r\n    7.4879999999999995, 7.5379999999999994, 7.588, 7.638, 7.688, 7.738,\r\n    7.7879999999999994, 7.838, 7.887999999999999, 7.938, 7.988, 8.038,\r\n    8.088000000000001, 8.138, 8.188, 8.2380000000000013, 8.288,\r\n    8.338000000000001, 8.388, 8.438, 8.4880000000000013, 8.538,\r\n    8.588000000000001, 8.638, 8.688, 8.7380000000000013, 8.788,\r\n    8.838000000000001, 8.888, 8.938, 8.9880000000000013, 9.038,\r\n    9.088000000000001, 9.138, 9.188, 9.2380000000000013, 9.288,\r\n    9.338000000000001, 9.388, 9.438, 9.4880000000000013, 9.538,\r\n    9.588000000000001, 9.638, 9.688, 9.7380000000000013, 9.788,\r\n    9.838000000000001, 9.888, 9.938, 9.9880000000000013, 10.038,\r\n    10.088000000000001, 10.138, 10.188, 10.238000000000001, 10.288,\r\n    10.338000000000001, 10.388, 10.438, 10.488000000000001, 10.538,\r\n    10.588000000000001, 10.638, 10.688, 10.738000000000001, 10.788,\r\n    10.838000000000001, 10.888, 10.938, 10.988000000000001 },\r\n\r\n  /* Expression: OR.mDot\r\n   * Referenced by: '<Root>/OpenRocket mDot'\r\n   */\r\n  { -0.46666666666676287, -0.4347826086956425, -0.42424242424240477,\r\n    -0.420000000000016, -0.39999999999999114, -0.38000000000000306,\r\n    -0.35999999999997778, -0.34000000000002445, -0.33999999999998964, -0.32,\r\n    -0.32000000000000073, -0.32, -0.30000000000001109, -0.29999999999997623,\r\n    -0.28571428571430835, -0.28888888888888714, -0.26086956521740096,\r\n    -0.25999999999999779, -0.23999999999997335, -0.24000000000000996,\r\n    -0.21999999999998446, -0.18000000000000627, -0.16000000000001846,\r\n    -0.15999999999998152, -0.12000000000000498, -0.12000000000000498,\r\n    -0.1000000000000151, -0.079999999999991467, -0.079999999999990759,\r\n    -0.060000000000002489, -0.060000000000002489, -0.040000000000013143,\r\n    -0.03999999999997797, -0.040000000000013143, 0.0, -0.032258064516111011, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0 },\r\n\r\n  /* Expression: OR.t\r\n   * Referenced by: '<Root>/OpenRocket mDot'\r\n   */\r\n  { 0.0, 0.015000000000000013, 0.038000000000000034, 0.071000000000000008, 0.121,\r\n    0.17100000000000004, 0.22099999999999997, 0.271, 0.32100000000000006, 0.371,\r\n    0.42100000000000004, 0.471, 0.521, 0.57100000000000006, 0.621, 0.67, 0.715,\r\n    0.761, 0.811, 0.8610000000000001, 0.91099999999999992, 0.961,\r\n    1.0110000000000001, 1.061, 1.1110000000000002, 1.161, 1.2109999999999999,\r\n    1.2610000000000001, 1.311, 1.3610000000000002, 1.411, 1.4609999999999999,\r\n    1.5110000000000001, 1.561, 1.6110000000000002, 1.661, 1.6920000000000002,\r\n    1.738, 1.7880000000000003, 1.838, 1.8880000000000003, 1.9380000000000002,\r\n    1.988, 2.0380000000000003, 2.088, 2.1380000000000003, 2.188, 2.238,\r\n    2.2880000000000003, 2.338, 2.3880000000000003, 2.438, 2.488,\r\n    2.5380000000000003, 2.588, 2.6380000000000003, 2.688, 2.738,\r\n    2.7880000000000003, 2.838, 2.8880000000000003, 2.938, 2.988,\r\n    3.0380000000000003, 3.088, 3.1380000000000003, 3.188, 3.238,\r\n    3.2880000000000003, 3.338, 3.3880000000000003, 3.438, 3.488,\r\n    3.5380000000000003, 3.588, 3.6380000000000003, 3.688, 3.738, 3.788,\r\n    3.8380000000000005, 3.8880000000000003, 3.938, 3.988, 4.0379999999999994,\r\n    4.088, 4.138, 4.188, 4.2379999999999995, 4.2879999999999994, 4.338, 4.388,\r\n    4.438, 4.4879999999999995, 4.5379999999999994, 4.588, 4.638, 4.688,\r\n    4.7379999999999995, 4.7879999999999994, 4.838, 4.888, 4.938,\r\n    4.9879999999999995, 5.0379999999999994, 5.088, 5.138, 5.188,\r\n    5.2379999999999995, 5.2879999999999994, 5.338, 5.388, 5.438,\r\n    5.4879999999999995, 5.5379999999999994, 5.588, 5.638, 5.688,\r\n    5.7379999999999995, 5.7879999999999994, 5.838, 5.888, 5.938,\r\n    5.9879999999999995, 6.0379999999999994, 6.088, 6.138, 6.188,\r\n    6.2379999999999995, 6.2879999999999994, 6.338, 6.388, 6.438,\r\n    6.4879999999999995, 6.5379999999999994, 6.588, 6.638, 6.688,\r\n    6.7379999999999995, 6.7879999999999994, 6.838, 6.888, 6.938,\r\n    6.9879999999999995, 7.0379999999999994, 7.088, 7.138, 7.188,\r\n    7.2379999999999995, 7.2879999999999994, 7.338, 7.388, 7.438,\r\n    7.4879999999999995, 7.5379999999999994, 7.588, 7.638, 7.688, 7.738,\r\n    7.7879999999999994, 7.838, 7.887999999999999, 7.938, 7.988, 8.038,\r\n    8.088000000000001, 8.138, 8.188, 8.2380000000000013, 8.288,\r\n    8.338000000000001, 8.388, 8.438, 8.4880000000000013, 8.538,\r\n    8.588000000000001, 8.638, 8.688, 8.7380000000000013, 8.788,\r\n    8.838000000000001, 8.888, 8.938, 8.9880000000000013, 9.038,\r\n    9.088000000000001, 9.138, 9.188, 9.2380000000000013, 9.288,\r\n    9.338000000000001, 9.388, 9.438, 9.4880000000000013, 9.538,\r\n    9.588000000000001, 9.638, 9.688, 9.7380000000000013, 9.788,\r\n    9.838000000000001, 9.888, 9.938, 9.9880000000000013, 10.038,\r\n    10.088000000000001, 10.138, 10.188, 10.238000000000001, 10.288,\r\n    10.338000000000001, 10.388, 10.438, 10.488000000000001, 10.538,\r\n    10.588000000000001, 10.638, 10.688, 10.738000000000001, 10.788,\r\n    10.838000000000001, 10.888, 10.938, 10.988000000000001 },\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S26>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S30>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S31>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S32>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S33>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<S3>/Constant'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: aptos.X_T\r\n   * Referenced by: '<S3>/Constant1'\r\n   */\r\n  2.07,\r\n\r\n  /* Expression: aptos.N\r\n   * Referenced by: '<Root>/Constant7'\r\n   */\r\n  4.0,\r\n\r\n  /* Expression: aptos.yMAC\r\n   * Referenced by: '<Root>/Constant12'\r\n   */\r\n  0.16557837837837838,\r\n\r\n  /* Expression: aptos.rt\r\n   * Referenced by: '<Root>/Constant13'\r\n   */\r\n  0.0515,\r\n\r\n  /* Expression: aptos.CNa_1\r\n   * Referenced by: '<Root>/Constant8'\r\n   */\r\n  5.7659569751818616,\r\n\r\n  /* Expression: 0.5\r\n   * Referenced by: '<S7>/Constant'\r\n   */\r\n  0.5,\r\n\r\n  /* Expression: aptos.CNa0\r\n   * Referenced by: '<Root>/Constant9'\r\n   */\r\n  6.707042547226953,\r\n\r\n  /* Expression: aptos.sumTerm\r\n   * Referenced by: '<Root>/Constant10'\r\n   */\r\n  0.00019049330416666667,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S17>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S18>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S29>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S34>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: aptos.Y_CP_can\r\n   * Referenced by: '<Root>/Constant26'\r\n   */\r\n  0.0865,\r\n\r\n  /* Expression: aptos.Z_CP_can\r\n   * Referenced by: '<Root>/Constant27'\r\n   */\r\n  0.0865,\r\n\r\n  /* Expression: aptos.Xbar_CP_can\r\n   * Referenced by: '<Root>/Constant30'\r\n   */\r\n  -0.7410000000000001,\r\n\r\n  /* Expression: aptos.CLa\r\n   * Referenced by: '<Root>/Constant31'\r\n   */\r\n  2.86,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S35>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S36>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S37>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S38>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S39>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 180/pi\r\n   * Referenced by: '<S40>/Gain'\r\n   */\r\n  57.295779513082323,\r\n\r\n  /* Expression: 0\r\n   * Referenced by: '<S16>/Rear fin cant'\r\n   */\r\n  0.0,\r\n\r\n  /* Computed Parameter: MediumHighAltitudeIntensity_max\r\n   * Referenced by: '<S130>/Medium//High Altitude Intensity'\r\n   */\r\n  { 11U, 6U },\r\n\r\n  /* Expression: true()\r\n   * Referenced by: '<S52>/Enable'\r\n   */\r\n  true,\r\n\r\n  /* Expression: pInitialization.isSqrtUsed\r\n   * Referenced by: '<S102>/isSqrtUsed'\r\n   */\r\n  false,\r\n\r\n  /* Computed Parameter: uDLookupTable_tableData\r\n   * Referenced by: '<S9>/1-D Lookup Table'\r\n   */\r\n  { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,\r\n    22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\r\n    41, 42, 43, 44, 45, 46, 47, 48, 49, 50 }\r\n};\r\n"},{"name":"builtin_typeid_types.h","type":"header","group":"utility","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * builtin_typeid_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef BUILTIN_TYPEID_TYPES_H\r\n#define BUILTIN_TYPEID_TYPES_H\r\n#ifndef BUILTIN_TYPEID_TYPES\r\n#define BUILTIN_TYPEID_TYPES\r\n\r\n/* Enumeration of built-in data types */\r\ntypedef enum {\r\n  SS_DOUBLE = 0,\r\n  SS_SINGLE = 1,\r\n  SS_INT8 = 2,\r\n  SS_UINT8 = 3,\r\n  SS_INT16 = 4,\r\n  SS_UINT16 = 5,\r\n  SS_INT32 = 6,\r\n  SS_UINT32 = 7,\r\n  SS_BOOLEAN = 8\r\n} BuiltInDTypeId;\r\n\r\n#define SS_NUM_BUILT_IN_DTYPE          ((int)SS_BOOLEAN+1)\r\n\r\n/* Enumeration for MAT-file logging code */\r\ntypedef int DTypeId;\r\n\r\n/* Enumeration of pre-defined data types */\r\ntypedef enum {\r\n  SS_FCN_CALL = 9,\r\n  SS_INTEGER = 10,\r\n  SS_POINTER = 11,\r\n  SS_INTERNAL_DTYPE2 = 12,\r\n  SS_TIMER_UINT32_PAIR = 13,\r\n  SS_CONNECTION_TYPE = 14\r\n} PreDefinedDTypeId;\r\n\r\n#endif                                 /* BUILTIN_TYPEID_TYPES */\r\n#endif                                 /* BUILTIN_TYPEID_TYPES_H */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * Definitions supporting external data access\r\n */\r\ntypedef int32_T chunk_T;\r\ntypedef uint32_T uchunk_T;\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long int long_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} int64m_T;\r\n\r\ntypedef struct {\r\n  int64m_T re;\r\n  int64m_T im;\r\n} cint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[2];\r\n} uint64m_T;\r\n\r\ntypedef struct {\r\n  uint64m_T re;\r\n  uint64m_T im;\r\n} cuint64m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} int96m_T;\r\n\r\ntypedef struct {\r\n  int96m_T re;\r\n  int96m_T im;\r\n} cint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[3];\r\n} uint96m_T;\r\n\r\ntypedef struct {\r\n  uint96m_T re;\r\n  uint96m_T im;\r\n} cuint96m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[4];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} int160m_T;\r\n\r\ntypedef struct {\r\n  int160m_T re;\r\n  int160m_T im;\r\n} cint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[5];\r\n} uint160m_T;\r\n\r\ntypedef struct {\r\n  uint160m_T re;\r\n  uint160m_T im;\r\n} cuint160m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[6];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} int224m_T;\r\n\r\ntypedef struct {\r\n  int224m_T re;\r\n  int224m_T im;\r\n} cint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[7];\r\n} uint224m_T;\r\n\r\ntypedef struct {\r\n  uint224m_T re;\r\n  uint224m_T im;\r\n} cuint224m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[8];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} int288m_T;\r\n\r\ntypedef struct {\r\n  int288m_T re;\r\n  int288m_T im;\r\n} cint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[9];\r\n} uint288m_T;\r\n\r\ntypedef struct {\r\n  uint288m_T re;\r\n  uint288m_T im;\r\n} cuint288m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[10];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} int352m_T;\r\n\r\ntypedef struct {\r\n  int352m_T re;\r\n  int352m_T im;\r\n} cint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[11];\r\n} uint352m_T;\r\n\r\ntypedef struct {\r\n  uint352m_T re;\r\n  uint352m_T im;\r\n} cuint352m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[12];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} int416m_T;\r\n\r\ntypedef struct {\r\n  int416m_T re;\r\n  int416m_T im;\r\n} cint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[13];\r\n} uint416m_T;\r\n\r\ntypedef struct {\r\n  uint416m_T re;\r\n  uint416m_T im;\r\n} cuint416m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[14];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} int480m_T;\r\n\r\ntypedef struct {\r\n  int480m_T re;\r\n  int480m_T im;\r\n} cint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[15];\r\n} uint480m_T;\r\n\r\ntypedef struct {\r\n  uint480m_T re;\r\n  uint480m_T im;\r\n} cuint480m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[16];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} int544m_T;\r\n\r\ntypedef struct {\r\n  int544m_T re;\r\n  int544m_T im;\r\n} cint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[17];\r\n} uint544m_T;\r\n\r\ntypedef struct {\r\n  uint544m_T re;\r\n  uint544m_T im;\r\n} cuint544m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[18];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} int608m_T;\r\n\r\ntypedef struct {\r\n  int608m_T re;\r\n  int608m_T im;\r\n} cint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[19];\r\n} uint608m_T;\r\n\r\ntypedef struct {\r\n  uint608m_T re;\r\n  uint608m_T im;\r\n} cuint608m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[20];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} int672m_T;\r\n\r\ntypedef struct {\r\n  int672m_T re;\r\n  int672m_T im;\r\n} cint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[21];\r\n} uint672m_T;\r\n\r\ntypedef struct {\r\n  uint672m_T re;\r\n  uint672m_T im;\r\n} cuint672m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[22];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} int736m_T;\r\n\r\ntypedef struct {\r\n  int736m_T re;\r\n  int736m_T im;\r\n} cint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[23];\r\n} uint736m_T;\r\n\r\ntypedef struct {\r\n  uint736m_T re;\r\n  uint736m_T im;\r\n} cuint736m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[24];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} int800m_T;\r\n\r\ntypedef struct {\r\n  int800m_T re;\r\n  int800m_T im;\r\n} cint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[25];\r\n} uint800m_T;\r\n\r\ntypedef struct {\r\n  uint800m_T re;\r\n  uint800m_T im;\r\n} cuint800m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[26];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} int864m_T;\r\n\r\ntypedef struct {\r\n  int864m_T re;\r\n  int864m_T im;\r\n} cint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[27];\r\n} uint864m_T;\r\n\r\ntypedef struct {\r\n  uint864m_T re;\r\n  uint864m_T im;\r\n} cuint864m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[28];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} int928m_T;\r\n\r\ntypedef struct {\r\n  int928m_T re;\r\n  int928m_T im;\r\n} cint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[29];\r\n} uint928m_T;\r\n\r\ntypedef struct {\r\n  uint928m_T re;\r\n  uint928m_T im;\r\n} cuint928m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[30];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} int992m_T;\r\n\r\ntypedef struct {\r\n  int992m_T re;\r\n  int992m_T im;\r\n} cint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[31];\r\n} uint992m_T;\r\n\r\ntypedef struct {\r\n  uint992m_T re;\r\n  uint992m_T im;\r\n} cuint992m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[32];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} int1056m_T;\r\n\r\ntypedef struct {\r\n  int1056m_T re;\r\n  int1056m_T im;\r\n} cint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[33];\r\n} uint1056m_T;\r\n\r\ntypedef struct {\r\n  uint1056m_T re;\r\n  uint1056m_T im;\r\n} cuint1056m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[34];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} int1120m_T;\r\n\r\ntypedef struct {\r\n  int1120m_T re;\r\n  int1120m_T im;\r\n} cint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[35];\r\n} uint1120m_T;\r\n\r\ntypedef struct {\r\n  uint1120m_T re;\r\n  uint1120m_T im;\r\n} cuint1120m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[36];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} int1184m_T;\r\n\r\ntypedef struct {\r\n  int1184m_T re;\r\n  int1184m_T im;\r\n} cint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[37];\r\n} uint1184m_T;\r\n\r\ntypedef struct {\r\n  uint1184m_T re;\r\n  uint1184m_T im;\r\n} cuint1184m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[38];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} int1248m_T;\r\n\r\ntypedef struct {\r\n  int1248m_T re;\r\n  int1248m_T im;\r\n} cint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[39];\r\n} uint1248m_T;\r\n\r\ntypedef struct {\r\n  uint1248m_T re;\r\n  uint1248m_T im;\r\n} cuint1248m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[40];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} int1312m_T;\r\n\r\ntypedef struct {\r\n  int1312m_T re;\r\n  int1312m_T im;\r\n} cint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[41];\r\n} uint1312m_T;\r\n\r\ntypedef struct {\r\n  uint1312m_T re;\r\n  uint1312m_T im;\r\n} cuint1312m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[42];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} int1376m_T;\r\n\r\ntypedef struct {\r\n  int1376m_T re;\r\n  int1376m_T im;\r\n} cint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[43];\r\n} uint1376m_T;\r\n\r\ntypedef struct {\r\n  uint1376m_T re;\r\n  uint1376m_T im;\r\n} cuint1376m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[44];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} int1440m_T;\r\n\r\ntypedef struct {\r\n  int1440m_T re;\r\n  int1440m_T im;\r\n} cint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[45];\r\n} uint1440m_T;\r\n\r\ntypedef struct {\r\n  uint1440m_T re;\r\n  uint1440m_T im;\r\n} cuint1440m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[46];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} int1504m_T;\r\n\r\ntypedef struct {\r\n  int1504m_T re;\r\n  int1504m_T im;\r\n} cint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[47];\r\n} uint1504m_T;\r\n\r\ntypedef struct {\r\n  uint1504m_T re;\r\n  uint1504m_T im;\r\n} cuint1504m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[48];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} int1568m_T;\r\n\r\ntypedef struct {\r\n  int1568m_T re;\r\n  int1568m_T im;\r\n} cint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[49];\r\n} uint1568m_T;\r\n\r\ntypedef struct {\r\n  uint1568m_T re;\r\n  uint1568m_T im;\r\n} cuint1568m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[50];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} int1632m_T;\r\n\r\ntypedef struct {\r\n  int1632m_T re;\r\n  int1632m_T im;\r\n} cint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[51];\r\n} uint1632m_T;\r\n\r\ntypedef struct {\r\n  uint1632m_T re;\r\n  uint1632m_T im;\r\n} cuint1632m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[52];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} int1696m_T;\r\n\r\ntypedef struct {\r\n  int1696m_T re;\r\n  int1696m_T im;\r\n} cint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[53];\r\n} uint1696m_T;\r\n\r\ntypedef struct {\r\n  uint1696m_T re;\r\n  uint1696m_T im;\r\n} cuint1696m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[54];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} int1760m_T;\r\n\r\ntypedef struct {\r\n  int1760m_T re;\r\n  int1760m_T im;\r\n} cint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[55];\r\n} uint1760m_T;\r\n\r\ntypedef struct {\r\n  uint1760m_T re;\r\n  uint1760m_T im;\r\n} cuint1760m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[56];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} int1824m_T;\r\n\r\ntypedef struct {\r\n  int1824m_T re;\r\n  int1824m_T im;\r\n} cint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[57];\r\n} uint1824m_T;\r\n\r\ntypedef struct {\r\n  uint1824m_T re;\r\n  uint1824m_T im;\r\n} cuint1824m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[58];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} int1888m_T;\r\n\r\ntypedef struct {\r\n  int1888m_T re;\r\n  int1888m_T im;\r\n} cint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[59];\r\n} uint1888m_T;\r\n\r\ntypedef struct {\r\n  uint1888m_T re;\r\n  uint1888m_T im;\r\n} cuint1888m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[60];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} int1952m_T;\r\n\r\ntypedef struct {\r\n  int1952m_T re;\r\n  int1952m_T im;\r\n} cint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[61];\r\n} uint1952m_T;\r\n\r\ntypedef struct {\r\n  uint1952m_T re;\r\n  uint1952m_T im;\r\n} cuint1952m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[62];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} int2016m_T;\r\n\r\ntypedef struct {\r\n  int2016m_T re;\r\n  int2016m_T im;\r\n} cint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[63];\r\n} uint2016m_T;\r\n\r\ntypedef struct {\r\n  uint2016m_T re;\r\n  uint2016m_T im;\r\n} cuint2016m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint32_T chunks[64];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        inf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        minf = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetInf.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    uint16_T one = 1U;\r\n    enum {\r\n      LittleEndian,\r\n      BigEndian\r\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n    switch (machByteOrder) {\r\n     case LittleEndian:\r\n      {\r\n        union {\r\n          LittleEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n        tmpVal.bitVal.words.wordL = 0x00000000U;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n\r\n     case BigEndian:\r\n      {\r\n        union {\r\n          BigEndianIEEEDouble bitVal;\r\n          real_T fltVal;\r\n        } tmpVal;\r\n\r\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\r\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\r\n        nan = tmpVal.fltVal;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  uint16_T one = 1U;\r\n  enum {\r\n    LittleEndian,\r\n    BigEndian\r\n  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\r\n  switch (machByteOrder) {\r\n   case LittleEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0xFFC00000U;\r\n      break;\r\n    }\r\n\r\n   case BigEndian:\r\n    {\r\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return nanF.wordL.wordLreal;\r\n}\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtGetNaN.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include \"rt_nonfinite.h\"\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_defines.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_defines_h_\r\n#define RTW_HEADER_rt_defines_h_\r\n\r\n/*===========*\r\n * Constants *\r\n *===========*/\r\n#define RT_PI                          3.14159265358979323846\r\n#define RT_PIF                         3.1415927F\r\n#define RT_LN_10                       2.30258509299404568402\r\n#define RT_LN_10F                      2.3025851F\r\n#define RT_LOG10E                      0.43429448190325182765\r\n#define RT_LOG10EF                     0.43429449F\r\n#define RT_E                           2.7182818284590452354\r\n#define RT_EF                          2.7182817F\r\n\r\n/*\r\n * UNUSED_PARAMETER(x)\r\n *   Used to specify that a function parameter (argument) is required but not\r\n *   accessed by the function body.\r\n */\r\n#ifndef UNUSED_PARAMETER\r\n#if defined(__LCC__)\r\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\r\n#else\r\n\r\n/*\r\n * This is the semi-ANSI standard way of indicating that an\r\n * unused function parameter is required.\r\n */\r\n#define UNUSED_PARAMETER(x)            (void) (x)\r\n#endif\r\n#endif\r\n#endif                                 /* RTW_HEADER_rt_defines_h_ */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.c\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rt_nonfinite.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"C:\\Users\\sambr\\Workspace\\aptos\\Matlab\\Time_Varying_Model_2022a_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n *  rtmodel.h:\r\n *\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * Code generation for model \"Time_Varying_Model_2022a\".\r\n *\r\n * Model version              : 4.12\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Thu Mar  7 23:27:27 2024\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: Intel->x86-64 (Windows64)\r\n * Code generation objective: Debugging\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"Time_Varying_Model_2022a.h\"\r\n#define GRTINTERFACE                   0\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n"},{"name":"rt_logging.c","type":"source","group":"other","path":"C:\\Program Files\\MATLAB\\R2023b\\rtw\\c\\src","tag":"","groupDisplay":"Other files","code":"/* \n *\n * Copyright 1994-2022 The MathWorks, Inc.\n *\n * File: rt_logging.c\n *\n * Abstract:\n *\tReal-Time Workshop data logging routines using circular buffers of\n *      fixed size.  The buffers are allocated at start, filled in at each\n *      major time step and finally written to a MAT-file at the end of the\n *      simulation.\n *\n *      This file handles redefining the following standard MathWorks types\n *      (see tmwtypes.h):\n *         [u]int8_T     to be int32_T (logged as Matlab [u]int32)\n *         [u]int16_T    to be int32_T (logged as Matlab [u]int32)\n *         real_T        to be real32_T (logged as Matlab single)\n *\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n\n\n#if !defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)\n\n#include <stddef.h>                     /* size_t */\n#include \"rt_logging.h\"\n#ifndef IS_RAPID_ACCEL\n#include \"rt_mxclassid.h\"\n#endif\n#include \"rtw_matlogging.h\"\n\n#include \"rtwtypes.h\"\n\n#ifndef TMW_NAME_LENGTH_MAX\n#define TMW_NAME_LENGTH_MAX 64\n#endif\n#define mxMAXNAM  TMW_NAME_LENGTH_MAX\t/* maximum name length */\n#define matUNKNOWN                  0\n#define\tmatINT8                     1\n#define\tmatUINT8                    2\n#define\tmatINT16                    3\n#define\tmatUINT16                   4\n#define\tmatINT32                    5\n#define\tmatUINT32                   6\n#define\tmatFLOAT                    7\n#define\tmatDOUBLE                   9\n#define matINT64                   12\n#define matUINT64                  13\n#define\tmatMATRIX                  14\n\n#define matLOGICAL_BIT          0x200\n#define matCOMPLEX_BIT          0x800\n\n#define matKEY                 0x4D49\n#define matVERSION             0x0100\n#define matVERSION_INFO_OFFSET   124L\n\n#define matINT64_ALIGN(e)      ( ( ((unsigned)(e))+7 ) & (~7) )\n#define matTAG_SIZE            (sizeof(int32_T) << 1)\n\n#ifndef DEFAULT_BUFFER_SIZE\n#define DEFAULT_BUFFER_SIZE      1024  /* used if maxRows=0 and Tfinal=0.0    */\n#endif\n\n#define FREE(m) if (m != NULL) free(m)\n\n/* Logical definitions */\n#if (!defined(__cplusplus))\n#  ifndef false\n#   define false                       (0U)\n#  endif\n#  ifndef true\n#   define true                        (1U)\n#  endif\n#endif\n\n/*==========*\n * typedefs *\n *==========*/\n\ntypedef struct LogInfo_Tag {\n    LogVar       *t;                   /* Time log variable                   */\n    void         *x;                   /* State log variable                  */\n    int_T        ny;                   /* Length of \"y\" log variables         */\n    void         **y;                  /* Output log vars                     */\n    void         *xFinal;              /* Final state log variable            */\n\n    LogVar       *logVarsList;         /* Linked list of all LogVars          */\n    StructLogVar *structLogVarsList;   /* Linked list of all StructLogVars    */\n\n    boolean_T   haveLogVars;           /* Are logging one or more vars?       */\n} LogInfo;\n\ntypedef struct MatItem_tag {\n  int32_T    type;\n  uint32_T    nbytes;\n  const void *data;\n} MatItem;\n\ntypedef enum {\n    DATA_ITEM,\n    MATRIX_ITEM,\n    STRUCT_LOG_VAR_ITEM,\n    SIGNALS_STRUCT_ITEM\n} ItemDataKind;\n\n/*===========*\n * Constants *\n *===========*/\n\nstatic const char_T rtMemAllocError[] = \"Memory allocation error\";\n\n#define ZEROS32 \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n\n#if mxMAXNAM==32\n\n#define ZERO_PAD\n\n#elif mxMAXNAM==64\n\n#define ZERO_PAD ZEROS32\n\n#elif mxMAXNAM==128\n\n#define ZERO_PAD   ZEROS32  ZEROS32  ZEROS32\n\n#else\n\n#error \"Cannot Handle mxMAXNAM other than 32,64, and 128\"\n\n#endif\n/* field names: for variable-size signal logging */\nstatic const char_T rtStructLogVarFieldNames[] =\n                  \"time\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"signals\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtLocalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"valueDimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n                  \n\n#define TIME_FIELD_NAME      (rtStructLogVarFieldNames[0*mxMAXNAM])\n#define SIGNALS_FIELD_NAME   (rtStructLogVarFieldNames[1*mxMAXNAM])\n#define BLOCKNAME_FIELD_NAME (rtStructLogVarFieldNames[2*mxMAXNAM])\n\n#define VALUES_FIELD_NAME    (rtLocalLoggingSignalsStructFieldNames[0*mxMAXNAM])\n#define VALUEDIMENSIONS_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[1*mxMAXNAM])\n#define DIMENSION_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[2*mxMAXNAM])\n#define LABEL_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[3*mxMAXNAM])\n#define TITLE_FIELD_NAME     (rtLocalLoggingSignalsStructFieldNames[4*mxMAXNAM])\n#define PLOTSTYLE_FIELD_NAME (rtLocalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n\n#define STATENAME_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[5*mxMAXNAM])\n#define CROSS_MDL_REF_FIELD_NAME (rtGlobalLoggingSignalsStructFieldNames[6*mxMAXNAM])\n\n/* field names: for fixed-size signal logging */\nstatic const char_T rtLocalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"title\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"plotStyle\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\nstatic const char_T rtGlobalLoggingSignalsStructFieldNames_noValDims[] =\n                  \"values\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"dimensions\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"label\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"blockName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"stateName\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD\n                  \"inReferencedModel\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" ZERO_PAD;\n\nextern real_T rtInf; /* declared by rt_nonfinite.c */\nextern real_T rtNaN;\nextern real32_T rtNaNF;\n\n/*================*\n * Local routines *\n *================*/\n\n/* Function: rt_GetSizeofDataType ==============================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofDataType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 0; /* unknown */\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        elSz = sizeof(real_T);\n        break;\n      case SS_SINGLE:\n        elSz = sizeof(real32_T);\n        break;\n      case SS_INT8:\n        elSz = sizeof(int8_T);\n        break;\n      case SS_UINT8:\n        elSz = sizeof(uint8_T);\n        break;\n      case SS_INT16:\n        elSz = sizeof(int16_T);\n        break;\n      case SS_UINT16:\n        elSz = sizeof(uint16_T);\n        break;\n      case SS_INT32:\n        elSz = sizeof(int32_T);\n        break;\n      case SS_UINT32:\n        elSz = sizeof(uint32_T);\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n    return(elSz);\n\n} /* end rt_GetSizeofDataType */\n\n\n/* Function: rt_GetSizeofComplexType ===========================================\n * Abstract:\n *      Get the element size in bytes given the data type id.\n */\nstatic size_t rt_GetSizeofComplexType(BuiltInDTypeId dTypeID)\n{\n    size_t elSz = 2*rt_GetSizeofDataType(dTypeID);\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal_T);\n      #endif\n        break;\n      case SS_SINGLE:\n      #ifdef CREAL_T\n        elSz = sizeof(creal32_T);\n      #endif\n        break;\n      case SS_INT8:\n      #ifdef CINT8_T\n        elSz = sizeof(cint8_T);\n      #endif\n        break;\n      case SS_UINT8:\n      #ifdef CUINT8_T\n        elSz = sizeof(cuint8_T);\n      #endif\n        break;\n      case SS_INT16:\n      #ifdef CINT16_T\n        elSz = sizeof(cint16_T);\n      #endif\n        break;\n      case SS_UINT16:\n      #ifdef CUINT16_T\n        elSz = sizeof(cuint16_T);\n      #endif\n        break;\n      case SS_INT32:\n      #ifdef CINT32_T\n        elSz = sizeof(cint32_T);\n      #endif\n        break;\n      case SS_UINT32:\n      #ifdef CUINT32_T\n        elSz = sizeof(cuint32_T);\n      #endif\n        break;\n      case SS_BOOLEAN:\n        elSz = sizeof(boolean_T);\n        break;\n    }\n\n    return(elSz);\n\n} /* end rt_GetSizeofComplexType */\n\n\n/* Function: rt_GetDataTypeConvertInfo =========================================\n * Abstract:\n *      Directly copy if pointer to structure is non-NULL, otherwise set to\n *      default.\n */\nstatic RTWLogDataTypeConvert rt_GetDataTypeConvertInfo(\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    BuiltInDTypeId dTypeID\n    )\n{\n    RTWLogDataTypeConvert dataTypeConvertInfoCopy;\n\n    if (pDataTypeConvertInfo == NULL) {\n        dataTypeConvertInfoCopy.conversionNeeded = 0;\n        dataTypeConvertInfoCopy.dataTypeIdLoggingTo = dTypeID;\n        dataTypeConvertInfoCopy.dataTypeIdOriginal  = (DTypeId)dTypeID;\n        dataTypeConvertInfoCopy.bitsPerChunk = 0;\n        dataTypeConvertInfoCopy.numOfChunk = 0;\n        dataTypeConvertInfoCopy.isSigned = 0;\n        dataTypeConvertInfoCopy.fracSlope = 1.0;\n        dataTypeConvertInfoCopy.fixedExp = 0;\n        dataTypeConvertInfoCopy.bias = 0.0;\n    } else {\n        dataTypeConvertInfoCopy = *pDataTypeConvertInfo;\n    }\n\n    return dataTypeConvertInfoCopy;\n\n} /* end rt_GetDataTypeConvertInfo */\n\n\n/* Function: rt_GetDblValueFromOverSizedData ===================================\n * Abstract:\n */\nstatic double rt_GetDblValueFromOverSizedData(\n    const void *pVoid, \n    int bitsPerChunk, \n    int numOfChunk,\n    unsigned int isSigned, \n    double fracSlope, \n    int fixedExp, \n    double bias)\n{\n    double retValue = 0;\n\n    double *dblValue = (double *) calloc(numOfChunk, sizeof(double));\n\n    int i;    \n    double isSignedNeg;\n\n    if(isSigned) {\n        const chunk_T *pData = (const chunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    } else  {\n        const uchunk_T *pData = (const uchunk_T *) (pVoid);\n        for (i = 0; i <numOfChunk; i++) {\n            dblValue[i] = (double)(pData[i]);\n        }\n    }\n\n    /* \n       Assuming multi chunks b_n ... b_2 b_1 b_0, and the length of each chunk is N.\n       Suppose b_i is the i-th chunk's value.\n       Then for unsigned data or data with one chunk: we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0;\n       But for signed data, we have\n       retValue = b_n * 2^(n*N) + ... + b_1 * 2^N + b_0 * 2^0+ (b_0<0) * 2^N + \n       ... (b_(n-1) <0) * 2^(n*N) \n       = (b_n + (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + (b_0<0)) * 2^N + b_0 * 2^0;\n       Together:\n       retValue = \n       (b_n + isSigned * (b_(n-1)<0)) * 2^(n*N) +... + (b_1 + isSigned * (b_0<0)) * 2^N + b_0 * 2^0;\n    */\n\n    retValue = dblValue[numOfChunk - 1];\n    \n    for(i = numOfChunk - 1; i > 0; i--) {\n        isSignedNeg = dblValue[i - 1] < 0 ? (double)isSigned : 0;\n        retValue = retValue + isSignedNeg;\n\n        retValue = ldexp(retValue, bitsPerChunk)+ dblValue[i-1];\n    }\n    retValue = ldexp( fracSlope * retValue, fixedExp ) + bias;\n\n    FREE(dblValue);\n    return (retValue);\n\n} /* end rt_GetDblValueFromOverSizedData */\n\n\n/* Function: rt_GetNonBoolMxIdFromDTypeId ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nstatic mxClassID rt_GetNonBoolMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    switch (dTypeID) {\n      case SS_DOUBLE:\n        mxID = (sizeof(real_T)==4? mxSINGLE_CLASS: mxDOUBLE_CLASS);\n        break;\n      case SS_SINGLE:\n        mxID = mxSINGLE_CLASS;\n        break;\n      case SS_INT8:\n        switch (sizeof(int8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 32-bits\" */\n            mxID = mxINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps int8_T into 16-bits\" */\n            mxID = mxINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_UINT8:\n        switch (sizeof(uint8_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps uint8_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          case 1:\n            mxID = mxUINT8_CLASS;\n            break;\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown data type ID\" */\n            mxID = mxUNKNOWN_CLASS;\n            break;\n        }\n        break;\n      case SS_INT16:\n        mxID = (sizeof(int16_T)==4? mxINT32_CLASS: mxINT16_CLASS);\n        break;\n      case SS_UINT16:\n        mxID = (sizeof(uint16_T)==4? mxUINT32_CLASS: mxUINT16_CLASS);\n        break;\n      case SS_INT32:\n        mxID = mxINT32_CLASS;\n        break;\n      case SS_UINT32:\n        mxID = mxUINT32_CLASS;\n        break;\n        /*case SS_BOOLEAN:\n          mxID = (sizeof(boolean_T)==4? mxUINT32_CLASS: mxLOGICAL_CLASS);\n          break;*/\n      default:\n        mxID = mxUNKNOWN_CLASS;\n        break;\n    }\n\n    return(mxID);\n\n} /* end rt_GetNonBoolMxIdFromDTypeId */\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeIdForRSim ======================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeIdForRSim(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxLOGICAL_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeIdForRSim */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_GetMxIdFromDTypeId =============================================\n * Abstract:\n *      Get the mx???_CLASS given the simulink builtin data type id.\n */\nmxClassID rt_GetMxIdFromDTypeId(BuiltInDTypeId dTypeID)\n{\n    mxClassID mxID;\n\n    if (dTypeID == SS_BOOLEAN) {\n        switch (sizeof(boolean_T)) {\n          case 4: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 32-bits\" */\n            mxID = mxUINT32_CLASS;\n            break;\n          case 2: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                     \"Needed for when PWS maps boolean_T into 16-bits\" */\n            mxID = mxUINT16_CLASS;\n            break;\n          default:\n            mxID = mxUINT8_CLASS;\n            break;\n        }\n    } else {\n        mxID = rt_GetNonBoolMxIdFromDTypeId(dTypeID);\n    }\n    return(mxID);\n\n} /* end rt_GetMxIdFromDTypeId */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n/* Function: rt_GetMatIdFromMxId ===============================================\n * Abstract:\n *      Get the MatId given the mxClassID.\n */\nstatic int_T rt_GetMatIdFromMxId(mxClassID mxID)\n{\n    int_T matID;\n\n    switch (mxID) {\n      case mxCELL_CLASS:\n      case mxSTRUCT_CLASS:\n      case mxOBJECT_CLASS:\n        matID = -1;\n        break;\n      case mxCHAR_CLASS:\n        matID = matUINT16;\n        break;\n      case mxDOUBLE_CLASS:\n        matID = matDOUBLE;\n        break;\n      case mxSINGLE_CLASS:\n        matID = matFLOAT;\n        break;\n      case mxINT8_CLASS:\n        matID = matINT8;\n        break;\n      case mxUINT8_CLASS:\n        matID = matUINT8;\n        break;\n      case mxINT16_CLASS:\n        matID = matINT16;\n        break;\n      case mxUINT16_CLASS:\n        matID = matUINT16;\n        break;\n      case mxINT32_CLASS:\n        matID = matINT32;\n        break;\n      case mxUINT32_CLASS:\n        matID = matUINT32;\n        break;\n      case mxINT64_CLASS:\n        matID = matINT64;\n        break;\n      case mxUINT64_CLASS:\n        matID = matUINT64;\n        break;\n      default:\n        matID = matUNKNOWN;\n        break;\n    }\n    return(matID);\n\n} /* end rt_GetMatIdFromMxId */\n\n\n/* Forward declaration */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind dataKind);\n\n\n/* Function: rt_ProcessMatItem =================================================\n * Abstract:\n *      This routine along with rt_WriteItemToMatFile() write out a specified\n *      mat-item the .mat file. Note that if the input argument\n *          cmd == 0, then this function just calculates the size of the item.\n *          cmd <> 0, this function writes the mat-item to the file.\n *      Return values is\n *           -1 : coding/logic error\n *            0 : upon success\n *          > 0 : upon write failure (1)\n */\nstatic int_T rt_ProcessMatItem(FILE         *fp,\n                               MatItem      *pItem,\n                               ItemDataKind itemKind,\n                               int_T        cmd)\n{\n    mxClassID    mxID          = mxUNKNOWN_CLASS;\n    uint32_T     arrayFlags[2] = {0, 0};\n    int32_T      *dims         = NULL;\n    int32_T      _dims[3]      = {0, 0, 0};\n    int32_T      nDims         = 2;\n    int32_T      nBytesInItem  = 0;\n    const char_T *itemName;\n    MatItem      item;\n    int_T        retStat       = 0;\n\n    switch (itemKind) {\n      case DATA_ITEM: {\n          (void)fprintf(stderr,\"Unexpected itemKind = DATA_ITEM in \"\n                               \"rt_ProcessMatItem @A\\n\");\n          retStat = -1;\n          goto EXIT_POINT;\n      }\n      case MATRIX_ITEM: {\n          const MatrixData *var = (const MatrixData *) pItem->data;\n\n          mxID           = var->mxID;\n          arrayFlags[0]  = mxID;\n          arrayFlags[0] |= var->logical;\n          arrayFlags[0] |= var->complex;\n          if (var->nDims < 2) {\n              dims         = _dims;\n              dims[0]      = var->nRows;\n              dims[1]      = var->nCols;\n              nDims        = 2;\n          } else {\n              int32_T k;\n              dims = (int32_T*)malloc(sizeof(int32_T)*(var->nDims+1));\n              for (k = 0; k < var->nDims; k++) {\n                  dims[k] = var->dims[k];\n              }\n              dims[var->nDims] = var->nRows;\n              nDims = var->nDims + 1;\n          }\n          itemName = var->name;\n          break;\n      }\n      case STRUCT_LOG_VAR_ITEM: {\n          const StructLogVar *var = (const StructLogVar *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = 1;\n          itemName      = var->name;\n          break;\n      }\n      case SIGNALS_STRUCT_ITEM: {\n          const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n\n          mxID          = mxSTRUCT_CLASS;\n          arrayFlags[0] = mxID;\n          dims          = _dims;\n          dims[0]       = 1;\n          dims[1]       = var->numSignals;\n          itemName      = &SIGNALS_FIELD_NAME;\n          break;\n      }\n      default:\n        (void)fprintf(stderr,\"Unexpected itemKind=%d in rt_ProcessMatItem @B\\n\",\n                      itemKind);\n        retStat = -1;\n        goto EXIT_POINT;\n    }\n\n    /* array flags */\n    item.nbytes = 2*sizeof(uint32_T);\n    if (cmd) {\n        item.type = matUINT32;\n        item.data = arrayFlags;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* dimensions */\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    item.nbytes = nDims*sizeof(int32_T);\n    if (cmd) {\n        item.type = matINT32;\n        item.data = dims;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;            \n        }\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        nBytesInItem += matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n    /* name */\n    item.nbytes = (int32_T)strlen(itemName);\n    if (cmd) {\n        item.type = matINT8;\n        item.data = (const char_T*) itemName;\n        if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n            retStat = 1;\n            goto EXIT_POINT;\n        }\n    } else {\n        nBytesInItem += (item.nbytes <= 4) ? /*LINTED E_CAST_INT_TO_SMALL_INT*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n    }\n\n    if (itemKind == MATRIX_ITEM) {\n        const MatrixData *var   = (const MatrixData*) pItem->data;\n        int_T            matID  = rt_GetMatIdFromMxId(mxID);\n        size_t           elSize = var->elSize;\n\n        /* data */\n        item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n        if (cmd) {\n            item.type = matID;\n            item.data = var->re;\n            if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n        }\n        /* imaginary part */\n        if (var->complex) {\n            item.nbytes = (int32_T)(var->nRows * var->nCols * elSize);\n            if (cmd) {\n                item.type = matID;\n                item.data = var->im;\n                if (rt_WriteItemToMatFile(fp, &item, DATA_ITEM)) {\n                    retStat = 1;\n                    goto EXIT_POINT;\n                }\n            } else {\n                nBytesInItem += (item.nbytes <= 4) ? /*LINTED*/\n                        matTAG_SIZE : matINT64_ALIGN(matTAG_SIZE + item.nbytes);\n            }\n        }\n    } else {  /* some type of structure item */\n        const char_T *fieldNames;\n        int_T        sizeofFieldNames;\n\n        /* field names */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = (const StructLogVar *) pItem->data;\n              fieldNames        = rtStructLogVarFieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var = (const SignalsStruct *) pItem->data;\n              fieldNames        = var->fieldNames;\n              sizeofFieldNames  = var->numActiveFields * mxMAXNAM;\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @C\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n\n        /* write field names */\n        if (cmd) {\n            int32_T tmpInt = mxMAXNAM;\n\n            item.nbytes = sizeof(int32_T);\n            item.type   = matINT32;\n            item.data   = &tmpInt;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n\n            item.nbytes = sizeofFieldNames;\n            item.type   = matINT8;\n            item.data   = (const char_T*) fieldNames;\n            if (rt_WriteItemToMatFile(fp,&item, DATA_ITEM)) {\n                retStat = 1;\n                goto EXIT_POINT;\n            }\n        } else {\n            /*LINTED E_CAST_INT_TO_SMALL_INT*/\n            nBytesInItem += matINT64_ALIGN( matTAG_SIZE + matTAG_SIZE +\n                                            sizeofFieldNames );\n        }\n\n        /* process each field of the structure */\n        switch (itemKind) {\n          case STRUCT_LOG_VAR_ITEM: {\n              const StructLogVar *var = pItem->data;\n\n              /* time */\n              {\n                  const void *data = var->time;\n\n                  if (var->logTime) { /* time is a LogVar, get the MatrixData */\n                      data = &(((const LogVar*) (var->time))->data);\n                  }\n\n                  item.type = matMATRIX;\n                  item.data = data;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp,&item,MATRIX_ITEM)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM,0)){\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n\n              /* signals */\n              item.type = matMATRIX;\n              item.data = &(var->signals);\n              if (cmd) {\n                  if (rt_WriteItemToMatFile(fp,&item,SIGNALS_STRUCT_ITEM)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n              } else {\n                  if (rt_ProcessMatItem(fp, &item, SIGNALS_STRUCT_ITEM,0)) {\n                      retStat = 1;\n                      goto EXIT_POINT;\n                  }\n                  nBytesInItem += item.nbytes + matTAG_SIZE;\n              }\n\n              /* block name */\n              if (var->blockName != NULL) {\n                  item.type = matMATRIX;\n                  item.data = var->blockName;\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n              }\n              break;\n          }\n          case SIGNALS_STRUCT_ITEM: {\n              const SignalsStruct *var        = pItem->data;\n              const LogVar        *values     = var->values;\n              const MatrixData    *dimensions = var->dimensions;\n              const MatrixData    *labels     = var->labels;\n              const MatrixData    *plotStyles = var->plotStyles;\n              const MatrixData    *titles     = var->titles;\n              const MatrixData    *blockNames = var->blockNames;\n              const MatrixData    *stateNames = var->stateNames;\n              const MatrixData    *crossMdlRef = var->crossMdlRef;\n              const boolean_T logValueDimensions = var->logValueDimensions;\n              int_T               i;\n\n              for (i = 0; i < var->numSignals; i++) {\n                  /* values */\n                  item.type = matMATRIX;\n                  item.data = &(values->data);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n\n                  if(logValueDimensions)\n                  {\n                      /* valueDimensions */\n                      /* Since the functions rt_WriteItemToMatFile and \n                         rt_ProcessMatItem deal with MatrixData, \n                         convert valDims to tempData, and fill up the\n                         necessary fields.\n                      */\n                      MatrixData  tempData;\n                      (void)memcpy(tempData.name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n                      tempData.nRows = values->valDims->nRows;\n                      tempData.nCols = values->valDims->nCols;\n                      tempData.nDims = 1;\n                      tempData._dims[0] = values->valDims->nCols;\n                      tempData.re = values->valDims->dimsData;\n                      tempData.im = NULL;\n                      tempData.dTypeID = SS_DOUBLE;\n                      tempData.elSize =  sizeof(real_T);\n                      tempData.mxID = mxDOUBLE_CLASS;\n                      tempData.logical = 0;\n                      tempData.complex = 0;\n                      tempData.frameData = 0;\n                      tempData.frameSize = 1;\n\n                      item.type = matMATRIX;                    \n                      item.data = &tempData; /*values->valDims;*/\n\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  values = values->next;\n\n                  /* dimensions */\n                  if (dimensions != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(dimensions[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n\n                  /* label */\n                  item.type = matMATRIX;\n                  item.data = &(labels[i]);\n                  if (cmd) {\n                      if (rt_WriteItemToMatFile(fp, &item,MATRIX_ITEM)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                  } else {\n                      if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                          retStat = 1;\n                          goto EXIT_POINT;\n                      }\n                      nBytesInItem += item.nbytes + matTAG_SIZE;\n                  }\n                  /* title */\n                  if (titles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(titles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* plot style */\n                  if (plotStyles != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(plotStyles[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp,&item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* block name */\n                  if (blockNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(blockNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* state name */\n                  if (stateNames != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(stateNames[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n                  /* crossMdlRef */\n                  if (crossMdlRef != NULL) {\n                      item.type = matMATRIX;\n                      item.data = &(crossMdlRef[i]);\n                      if (cmd) {\n                          if (rt_WriteItemToMatFile(fp, &item, MATRIX_ITEM)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                      } else {\n                          if (rt_ProcessMatItem(fp, &item, MATRIX_ITEM, 0)) {\n                              retStat = 1;\n                              goto EXIT_POINT;\n                          }\n                          nBytesInItem += item.nbytes + matTAG_SIZE;\n                      }\n                  }\n              } /* for i=1:numSignals */\n              break;\n          }\n          default: /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                      \"Needed to handle an unknown itemKind\" */\n            (void)fprintf(stderr, \"Unexpected itemKind=%d in \"\n                          \"rt_ProcessMatItem @D\\n\", itemKind);\n            retStat = -1;\n            goto EXIT_POINT;\n        }\n    } /* end struct item */\n\n    if (!cmd) {\n        pItem->nbytes = nBytesInItem;\n    }\n\n  EXIT_POINT:\n    if (dims != _dims) {\n        FREE(dims);\n    }\n    return(retStat);\n\n} /* end rt_ProcessMatItem */\n\n\n/* Function: rt_WriteItemToMatFile =============================================\n * Abstract:\n *      Entry function for writing out a mat item to the mat file.\n *\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteItemToMatFile(FILE         *fp,\n                                   MatItem      *pItem,\n                                   ItemDataKind itemKind)\n{\n    /* Determine the item size */\n    if (pItem->type == matMATRIX) {\n        if (rt_ProcessMatItem(fp, pItem, itemKind, 0)) return(1);\n    }\n\n    /* Write the item tag and data */\n    if (pItem->nbytes > 4) {\n        int32_T nAlignBytes;\n\n        if (fwrite(pItem, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n\n        if (pItem->type == matMATRIX) {\n            if (rt_ProcessMatItem(fp, pItem, itemKind, 1)) return(1);\n        } else {\n            if ( fwrite(pItem->data, 1, pItem->nbytes, fp) !=\n                                                    ((size_t) pItem->nbytes) ) {\n                return(1);\n            }\n        }\n\n        /* Add offset for 8-byte alignment */\n        nAlignBytes = matINT64_ALIGN(pItem->nbytes) - pItem->nbytes;\n        if (nAlignBytes > 0) {\n            int pad[2] = {0, 0};\n            if ( fwrite(pad,1,nAlignBytes,fp) != ((size_t) nAlignBytes) ) {\n                return(1);\n            }\n        }\n    } else {\n        MatItem item = {0, 0, NULL};\n        item.type = ((uint32_T)(pItem->type))|(((uint32_T)(pItem->nbytes))<<16);\n        (void)memcpy(&item.nbytes, pItem->data, pItem->nbytes);\n        if (fwrite(&item, 1, matTAG_SIZE, fp) != matTAG_SIZE) return(1);\n    }\n\n    return(0);\n\n} /* end rt_WriteItemToMatFile */\n\n\n/* Function: rt_WriteMat5FileHeader ============================================\n * Abstract:\n *      Function to write the mat file header.\n *      Return values is\n *          == 0 : upon success\n *          <> 0 : upon failure\n */\nstatic int_T rt_WriteMat5FileHeader(FILE *fp)\n{\n    int_T        nbytes;\n    int_T        nspaces;\n    int_T        i, n;\n    unsigned short ver[2];\n    char_T       spaces[16];\n    const char_T *matversion = \"MATLAB 5.0 MAT-file\";\n\n    (void)memset(spaces, ' ', sizeof(spaces));\n\n    n = (int_T)strlen(matversion);\n    nbytes = (int_T)fwrite(matversion, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    nspaces = matVERSION_INFO_OFFSET - nbytes;\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces % sizeof(spaces);\n    nbytes += (int_T)fwrite(spaces, 1, n, fp);\n    /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n    n = nspaces / sizeof(spaces);\n    for (i = 0; i < n; ++i) {\n        nbytes += (int_T)fwrite(spaces, 1, sizeof(spaces), fp);\n    }\n    if (nbytes == matVERSION_INFO_OFFSET) {\n        ver[0] = matVERSION;\n        ver[1] = matKEY;\n        nbytes += (int_T)fwrite(ver, 1, sizeof(ver), fp);\n    }\n    return(nbytes != matVERSION_INFO_OFFSET + sizeof(ver));\n\n} /* end rt_WriteMat5FileHeader */\n\n\n/* Function: rt_FixupLogVar ====================================================\n * Abstract:\n *\tMake the logged variable suitable for MATLAB.\n */\nstatic const char_T *rt_FixupLogVar(LogVar *var,int verbose)\n{\n    int_T  nCols   = var->data.nCols;\n    int_T  maxRows = var->data.nRows;\n    int_T  nDims   = var->data.nDims;\n    size_t elSize  = var->data.elSize;\n    int_T  nRows   = (var->wrapped ?  maxRows : var->rowIdx);\n\n    var->nDataPoints = var->rowIdx + var->wrapped * maxRows;\n\n    if (var->wrapped > 1 || (var->wrapped == 1 && var->rowIdx != 0)) {\n        /*\n         * Warn the user the circular buffer has wrapped, implying that\n         * some data has been lost.\n         */\n        if( verbose) {\n            (void)fprintf(stdout,\n                          \"*** Log variable %s has wrapped %d times\\n\"\n                          \"    using a circular buffer of size %d\\n\",\n                          var->data.name, var->wrapped, var->data.nRows);\n        }\n        if (var->usingDefaultBufSize) {\n            /*\n             * If wrapping occurred using the default buffer size,\n             * let the user know what size buffer to use in the\n             * future to avoid wrapping.  If the default buffer\n             * size was not used, the user has no control to specify\n             * the correct value.  Wrapping may occur when not using\n             * the default buffer if we allocated too small a buffer\n             * size for this logvar.  One common case is a toWorkspace\n             * block inside of an iterative subsystem - we can not take\n             * the number of iterations into account (they may be\n             * variable) when allocating the buffer.  In this case,\n             * just warn the buffer wrapped and don't tell user they\n             * can override the buffer size.\n             */\n            if( verbose ) {\n                (void)fprintf(stdout,\n                              \"*** To avoid wrapping, explicitly specify a\\n\"\n                              \"    buffer size of %d in your Simulink model\\n\"\n                              \"    by adding OPTS=\\\"-DDEFAULT_BUFFER_SIZE=%d\\\"\\n\"\n                              \"    as an argument to the ConfigSet MakeCommand\\n\"\n                              \"    parameter\\n\",\n                              var->nDataPoints, var->nDataPoints);\n            }\n        }\n    }\n\n    if (nDims < 2 && nCols > 1) {  /* Transpose? */\n        /* Don't need to transpose valueDimensions */\n        int_T  nEl    = nRows*nCols;\n        char   *src   = var->data.re;\n        char   *pmT;\n        int_T  k;\n\n        /**********************************\n         * If memory cannot be allocated, *\n         * write to a temporary buffer    *\n         **********************************/\n        if ((pmT = malloc(nEl*elSize)) == NULL) {\n            FILE  *fptr;\n            char  fName[mxMAXNAM+13];\n\n            (void)sprintf(fName, \"%s%s\", var->data.name, \"_rtw_tmw.tmw\");\n            if ((fptr=fopen(fName,\"w+b\")) == NULL) {\n                (void)fprintf(stderr,\"*** Error opening %s\",fName);\n                return(\"unable to open data file\\n\");\n            }\n\n            /****************************\n             * Write the data to a file *\n             ****************************/\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nCols*(k%nRows) + (k/nRows);\n                char  *dst = src + kT*elSize;\n                (void)fwrite(dst, elSize, 1, fptr);\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n\n            /*******************************\n             * Read the data from the file *\n             *******************************/\n            (void)rewind(fptr);\n            (void)fread(var->data.re, elSize, nEl, fptr);\n            (void)fclose(fptr);\n            (void)remove(fName);\n        } else {\n            for (k=0; k<nEl; k++) {\n                int_T kT   = nRows*(k%nCols) + (k/nCols);\n                char  *dst = pmT + kT*elSize;\n                (void)memcpy(dst, src, elSize);\n                src += elSize;\n            }\n            if (var->data.complex) {\n                char *pmiT = var->data.re;\n                src  = var->data.im;\n                for (k=0; k<nEl; k++) {\n                    int_T kT   = nRows*(k%nCols) + (k/nCols);\n                    char  *dst = pmiT + kT*elSize;\n                    (void)memcpy(dst, src, elSize);\n                    src += elSize;\n                }\n                var->data.re = var->data.im;\n                var->data.im = pmiT;\n            }\n            FREE(var->data.re);\n            var->data.re = pmT;\n        }\n    } /* Transpose? */\n\n    if (var->wrapped > 0 && var->rowIdx != 0 ) {  /* Rotate? */\n        char_T *buffer    = var->data.re;\n        int_T  done       = 0; /* done: 0 (1) rotate real (imag) part. */\n\n        do {\n            char_T *col       = buffer;\n            int_T  rowOffset  = (int_T)((nDims == 1) ? (elSize) : (elSize * nCols));\n            int_T  colOffset  = (int_T)((nDims == 1)?  (nRows*elSize) : elSize);\n            int_T  zeroIdx    = var->rowIdx;\n            int_T  j;\n\n            for (j = 0 ; j < nCols; ++j, col += colOffset) {\n                int_T   swapCount;\n                int_T   srcIdx;\n                int_T   dstIdx;\n                int_T   tmpIdx;\n                MatReal tmp;\n\n                for (tmpIdx=0, swapCount=0; swapCount < nRows; tmpIdx++) {\n                    (void)memcpy(&tmp, col + tmpIdx*rowOffset, elSize);\n\n                    dstIdx=tmpIdx; \n                    srcIdx = ((dstIdx + zeroIdx) % nRows);\n                    while (srcIdx != tmpIdx) {\n                        (void)memcpy(col + dstIdx*rowOffset,\n                                     col + srcIdx*rowOffset,\n                                     elSize);\n                        ++swapCount;\n                        dstIdx = srcIdx;\n                        srcIdx = ((dstIdx + zeroIdx) % nRows);\n                        \n                    }\n                    (void)memcpy(col + dstIdx*rowOffset, &tmp, elSize);\n                    ++swapCount;\n                }\n            }\n            done ++;\n            /* need to rotate the imaginary part */\n        } while ((done == 1) && ((buffer = var->data.im) != NULL));\n\n        var->rowIdx = 0;\n    } /* Rotate? */\n\n    /*\n     * We might have allocated more number of rows than the number of data\n     * points that have been logged, in which case set nRows to nDataPoints\n     * so that only these values get saved.\n     */\n    if (var->nDataPoints < var->data.nRows) {\n        var->data.nRows = var->nDataPoints;\n        if(var->valDims != NULL){\n            size_t elSizeValDims = sizeof(real_T);\n            int_T  k;\n            real_T *dimsData = var->valDims->dimsData + nRows;\n            /* \n               Keep nRows of values and that of valueDimensions consistent \n               for variable-size signals.\n            */\n            var->valDims->nRows = var->data.nRows;\n            /*\n               Also need to move data when shrinking the array size,\n               because valueDimensions data is stored in array format. \n               e.g. maxRows = 4; nRows = 2; nDims = 3;\n               Before fixing up the logVar, the locations of data are as below:\n               (x, y, z -- useful data / o -- junk)\n               a[0] = x    a[4] = y    a[8] = z\n               a[1] = x    a[5] = y    a[9] = z\n               a[2] = o    a[6] = o    a[10]= o\n               a[3] = o    a[7] = o    a[11]= o\n               After fixing up the logVar, we want the data to be stored as:\n               a[0] = x    a[4] = z    a[8] = o\n               a[1] = x    a[5] = z    a[9] = o\n               a[2] = y    a[6] = o    a[10]= o\n               a[3] = y    a[7] = o    a[11]= o\n            */\n            for(k = 1; k < nDims; k++){\n                (void) memmove(dimsData, \n                              var->valDims->dimsData + k*maxRows,\n                              elSizeValDims * nRows);\n                dimsData += nRows;\n            }\n        }\n    }\n    return(NULL);\n\n} /* end rt_FixupLogVar */\n\n\n/* Function: rt_LoadModifiedLogVarName =========================================\n * Abstract:\n *      The name of the logged variable is obtained from the input argument\n *      varName and the nameModifier which is obtained from the simstruct. If\n *      the nameModifier begins with an '_', then nameModifier is post-pended to\n *      varName to obtain the name of the logged variable. If the first\n *      character does not begin with an '_', then the nameModifier is\n *      pre-pended to varName.\n *\n * Examples:\n *     a)  varName = \"tout\" & nameModifier = \"_rt\"  => logVarName = \"tout_rt\"\n *     b)  varName = \"tout\" & nameModifier = \"rt_\"  => logVarName = \"rt_tout\"\n *     c)  varName = \"tout\" & nameModifier = \"none\" => logVarName = \"tout\"\n */\nstatic void rt_LoadModifiedLogVarName(const RTWLogInfo *li,         /* in  */\n                                      const char       *varName,    /* in  */\n                                      char             *logVarName) /* out */\n{\n    int_T        nameLen;\n    const char_T *nameModifier = rtliGetLogVarNameModifier(li);\n\n    if (nameModifier != NULL && strcmp(nameModifier,\"none\")==0) {\n        nameModifier = NULL;\n    }\n\n    logVarName[mxMAXNAM-1] = '\\0';\n    if (nameModifier == NULL) {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n    } else if (nameModifier[0] == '_') {\n        (void)strncpy(logVarName, varName, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, nameModifier, (size_t)mxMAXNAM-1-nameLen);\n    } else {\n        (void)strncpy(logVarName, nameModifier, mxMAXNAM-1);\n        nameLen = (int_T)strlen(logVarName);\n        (void)strncat(logVarName, varName, (size_t)mxMAXNAM-1-nameLen);\n    }\n\n} /* end rt_LoadModifiedLogVarName */\n\n\n/* Function: rt_GetActualDTypeID ===============================================\n * Abstract:\n *\tGiven a built-in data type id, return the actual data type id.\n *\tThe only time these are different is when real_T has been mapped\n *\tto a single.\n */\n#if defined(_MSC_VER)\n #pragma warning(push)\n #pragma warning(disable: 4127)\n#endif\nstatic BuiltInDTypeId rt_GetActualDTypeID(BuiltInDTypeId dTypeID)\n{\n    /*LINTED E_FALSE_LOGICAL_EXPR*/\n    if (dTypeID == SS_DOUBLE && sizeof(real_T) != 8) {     /* polyspace DEFECT:DEAD_CODE \n                                                              [Not a defect:Unset] \n                                                              \"Needed for when real_T has been \n                                                              mapped to a single\" */\n        return(SS_SINGLE);\n    } else {\n        return(dTypeID);\n    }\n\n} /* end rt_GetActualDTypeID */\n#if defined(_MSC_VER)\n #pragma warning(pop)\n#endif\n\n\n/* Function: rt_DestroyLogVar ==================================================\n * Abstract:\n *      Destroy the log var linked list.\n */\nstatic void rt_DestroyLogVar(LogVar *head)\n{\n    while(head) {\n        LogVar *var = head;\n        head = var->next;\n        FREE(var->data.re);\n        FREE(var->data.im);\n        if (var->data.dims != var->data._dims) {\n            FREE(var->data.dims);\n        }\n        /* free valDims if necessary */\n        if(var->valDims != NULL) {\n            FREE(var->valDims->dimsData);\n            FREE(var->valDims);\n        }\n        /* free coords, strides and currStrides if necessary */\n        FREE(var->coords);\n        FREE(var->strides);\n        FREE(var->currStrides);\n\n        FREE(var);\n    }\n\n} /* end rt_DestroyLogVar */\n\n\n/* Function: rt_DestroyStructLogVar ============================================\n * Abstract:\n *      Destroy the struct log var linked list.\n */\nstatic void rt_DestroyStructLogVar(StructLogVar *head)\n{\n    while(head) {\n        StructLogVar *var = head;\n\n        head = var->next;\n\n        if (var->logTime) { /* time is LogVar */\n            rt_DestroyLogVar(var->time);\n        } else {        /* time is MatrixData */\n            FREE(var->time);\n        }\n        rt_DestroyLogVar(var->signals.values);\n        FREE(var->signals.labels);\n        FREE(var->signals.plotStyles);\n        FREE(var->signals.dimensions);\n        FREE(var->signals.titles);\n        FREE(var->signals.blockNames);\n        FREE(var->signals.stateNames);\n        FREE(var->signals.crossMdlRef);\n        FREE(var->blockName);\n        FREE(var);\n    }\n\n} /* end rt_DestroyStructLogVar */\n\n\n/* Function: rt_InitSignalsStruct ==============================================\n * Abstract:\n *      Initialize the signals structure in the struct log variable.\n *\n * Returns:\n *\t== NULL  => success.\n *\t~= NULL  => failure, the return value is a pointer to the error\n *                           message, which is also set in the simstruct.\n */\nstatic const char_T *rt_InitSignalsStruct(RTWLogInfo             *li,\n                                          const real_T           startTime,\n                                          const real_T           finalTime,\n                                          const real_T           inStepSize,\n                                          const char_T           **errStatus,\n                                          StructLogVar           *var,\n                                          int_T                  maxRows,\n                                          int_T                  decimation,\n                                          real_T                 sampleTime,\n                                          const RTWLogSignalInfo *sigInfo)\n{\n    int_T                i, sigIdx;\n    SignalsStruct        *sig          = &(var->signals);\n    int_T                nSignals      = sigInfo->numSignals;\n    const int_T          *numCols      = sigInfo->numCols;\n    const int_T          *numDims      = sigInfo->numDims;\n    const int_T          *dims         = sigInfo->dims;\n    const BuiltInDTypeId *dTypes       = sigInfo->dataTypes;\n    const int_T          *cSgnls       = sigInfo->complexSignals;\n    const int_T          *fData        = sigInfo->frameData;\n    const char_T         **labels      = sigInfo->labels.cptr;\n    const int_T          *plotStyles   = sigInfo->plotStyles;\n    const char_T         *titles       = sigInfo->titles;\n    const int_T          *titleLen     = sigInfo->titleLengths;\n    const char_T         **blockNames  = sigInfo->blockNames.cptr;\n    const char_T         **stateNames  = sigInfo->stateNames.cptr;\n    const boolean_T      *crossMdlRef  = sigInfo->crossMdlRef;\n    void                 **currSigDims = sigInfo->currSigDims;\n    int_T                *currSigDimsSize = sigInfo->currSigDimsSize;\n    LogVar               *prevValues   = NULL;\n    int_T                dimsOffset    = 0;\n    boolean_T            *isVarDims    = sigInfo->isVarDims;\n    /* if any signal is variable-size, the field 'valueDimensions' is needed */\n    boolean_T            logValueDimensions = false;\n    const RTWLogDataTypeConvert *pDTConvInfo = sigInfo->dataTypeConvert;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    sig->numActiveFields = 1;\n    sig->numSignals      = nSignals;\n\n    sig->isVarDims = isVarDims;\n    /* check whether we need valueDimensions field*/\n    for (i=0; i<nSignals; i++){\n        if(isVarDims[i]){\n            logValueDimensions = true;\n            break;\n        }\n    }\n\n    /* values */\n    dimsOffset = 0;\n    for (i = 0; i < nSignals; i++) {\n        BuiltInDTypeId dt = (dTypes) ? dTypes[i] : SS_DOUBLE;\n        int_T          cs = (cSgnls) ? cSgnls[i] : 0;\n        int_T          fd = (fData)  ? fData[i]  : 0;\n        int_T          nd = (numDims) ? numDims[i] : 1;\n\n        const RTWLogDataTypeConvert *pDTConvInfoCur =\n                       (pDTConvInfo)  ? (pDTConvInfo+i)  : 0;\n\n        LogVar *values = NULL;\n        LogValDimsStat logValDimsStat;\n\n        if(!logValueDimensions){\n            logValDimsStat = NO_LOGVALDIMS;\n        }\n        else{\n            logValDimsStat = isVarDims[i] ? LOGVALDIMS_VARDIMS :  \n                                            LOGVALDIMS_EMPTYMX;\n        }\n\n        values = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                            inStepSize, errStatus,\n                                            &VALUES_FIELD_NAME,\n                                            dt, \n                                            pDTConvInfoCur,\n                                            0, cs, fd,\n                                            numCols[i],nd,\n                                            dims + dimsOffset,\n                                            logValDimsStat,\n                                            currSigDims + dimsOffset,\n                                            currSigDimsSize + dimsOffset,\n                                            maxRows,decimation,sampleTime, 0);\n\n        if (values == NULL) goto ERROR_EXIT;\n\n        if (sig->values == NULL) {\n            sig->values = values;\n        } else {\n            if (prevValues == NULL) goto ERROR_EXIT;\n            prevValues->next = values;\n        }\n        prevValues = values;\n        dimsOffset += nd;\n    }\n\n    if(logValueDimensions){\n        ++sig->numActiveFields;\n        sig->logValueDimensions = true;\n    }\n    else{\n        sig->logValueDimensions = false;\n    }\n\n    /* Dimensions */\n    {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            int_T nd = (numDims) ? numDims[i] : 1;\n            dataLen += nd;\n        }\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->dimensions = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->dimensions)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n          data[i] = dims[i]; /* cannot memcpy double <- int */\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->dimensions[i]);\n            int_T nd = (numDims) ? numDims[i] : 1;\n\n            (void)memcpy(mtxData->name, &DIMENSION_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = 1;\n            mtxData->nCols   = nd;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += nd;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* labels */\n    if (labels != NULL) {\n        unsigned short   *data;\n        size_t  nbytes;\n        int_T   dataLen    = 0;\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (labels[i] != NULL){\n                dataLen = dataLen + (int_T)strlen(labels[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->labels = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->labels)) + dataOffset);\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T labelLen = (labels[sigIdx]==NULL) ? 0 : (int_T)strlen(labels[sigIdx]);\n            for (i = 0; i < labelLen; i++) {\n                data[dataIdx++] = (uint8_T)labels[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->labels[i]);\n            int_T labelLen = (int_T)strlen(labels[i]);\n\n            (void)memcpy(mtxData->name, &LABEL_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (labelLen) ? 1 : 0;\n            mtxData->nCols   = labelLen;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += labelLen;\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* plot styles */\n    if (plotStyles != NULL) {\n        real_T         *data;\n        size_t\t       nbytes;\n        int_T          dataLen    = 0;\n        BuiltInDTypeId dTypeId    = rt_GetActualDTypeID(SS_DOUBLE);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t         dataOffset = nSignals*sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T         overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n        for (i=0; i< nSignals; i++) {\n            dataLen += numCols[i];\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(real_T);\n\n        if ( (sig->plotStyles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (real_T*) (((char_T*) (sig->plotStyles)) + dataOffset);\n\n        for (i = 0; i < dataLen; i++) {\n            data[i] = plotStyles[i];\n        }\n\n        dimsOffset = 0;\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->plotStyles[i]);\n            \n            (void)memcpy(mtxData->name, &PLOTSTYLE_FIELD_NAME, mxMAXNAM);\n\n            mtxData->nRows   = (numCols[i]) ? 1 : 0;\n            mtxData->nCols   = numCols[i];\n\n            mtxData->nDims   = numDims[i];\n            \n            if(mtxData->nDims > 2) {\n                if ((mtxData->dims = calloc(mtxData->nDims, sizeof(int_T))) == NULL) goto ERROR_EXIT;\n            } else {\n                mtxData->dims    = mtxData->_dims;\n            }\n            \n            mtxData->dims[0] = *(dims + dimsOffset);\n            if(mtxData->nDims >= 2) {\n                int32_T j;\n                for (j=1; j<mtxData->nDims; j++) {\n                    mtxData->dims[j] = *(dims + dimsOffset + j);\n                }\n            }\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = dTypeId;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(dTypeId);\n            mtxData->elSize  = rt_GetSizeofDataType(dTypeId);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data       += numCols[i];\n            dimsOffset += numDims[i];\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* titles */\n    if (titles != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen    = (int_T)strlen(titles);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        size_t  dataOffset = nSignals * sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T  overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->titles = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        /*LINTED E_BAD_PTR_CAST_ALIGN*/\n        data = (unsigned short*) (((char_T*) (sig->titles)) + dataOffset);\n        for (i = 0; i < dataLen; i++) {\n            data[i] = titles[i];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->titles[i]);\n\n            (void)memcpy(mtxData->name, &TITLE_FIELD_NAME, mxMAXNAM);\n            if (titleLen) {\n                mtxData->nRows   = (titleLen[i]) ? 1 : 0;\n                mtxData->nCols   = titleLen[i];\n            } else {\n                mtxData->nRows   = (dataLen) ? 1 : 0;\n                mtxData->nCols   = dataLen;\n            }\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += ((titleLen) ? titleLen[i] : dataLen);\n        }\n        ++sig->numActiveFields;\n    }\n\n    /* block names */\n    if (blockNames != NULL)     {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (blockNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(blockNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->blockNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->blockNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (blockNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(blockNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)blockNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->blockNames[i]);\n            int_T blockNameLen = (int_T)strlen(blockNames[i]);\n\n            (void)memcpy(mtxData->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (blockNameLen) ? 1 : 0;\n            mtxData->nCols   = blockNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += blockNameLen;\n        }\n        ++sig->numActiveFields;\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    } else {\n        if(logValueDimensions){\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtLocalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* state names */\n    if (stateNames != NULL) {\n        unsigned short  *data;\n        size_t nbytes;\n        int_T  dataLen = 0;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n        int_T  dataIdx = 0;\n\n        for (i=0;i<nSignals;i++) {\n            if (stateNames[i] != NULL) {\n                dataLen = dataLen + (int_T)strlen(stateNames[i]);\n            }\n        }\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (sig->stateNames = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (unsigned short*) (((char_T*) (sig->stateNames)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            int_T nameLen = (stateNames[sigIdx]==NULL) ? 0 : \n                (int_T)strlen(stateNames[sigIdx]);\n            for (i = 0; i < nameLen; i++) {\n                data[dataIdx++] = (uint8_T)stateNames[sigIdx][i];\n            }\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->stateNames[i]);\n            int_T stateNameLen = (int_T)strlen(stateNames[i]);\n\n            (void)memcpy(mtxData->name, &STATENAME_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = (stateNameLen) ? 1 : 0;\n            mtxData->nCols   = stateNameLen;\n\n            mtxData->nDims   = 1; /* assume */\n            mtxData->dims    = mtxData->_dims;\n            mtxData->dims[0] = mtxData->nCols;\n\n            mtxData->re      = data;\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_INT16;\n            mtxData->mxID    = mxCHAR_CLASS;\n            mtxData->elSize  = sizeof(short);\n            mtxData->logical = 0U;\n            mtxData->complex = 0U;\n\n            data += stateNameLen;\n        }\n        ++sig->numActiveFields;\n\n        if(logValueDimensions){\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames;\n        }\n        else{\n            sig->fieldNames = rtGlobalLoggingSignalsStructFieldNames_noValDims;\n        }\n\n    }\n\n    /* CrossMdlRef */\n    if (crossMdlRef != NULL) {\n        real_T  *data;\n        size_t nbytes;\n        size_t dataOffset = nSignals * sizeof(MatrixData);\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(real_T));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(real_T) - overhang);\n        }\n\n        nbytes = dataOffset + nSignals*sizeof(real_T);\n\n        if ( (sig->crossMdlRef = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        data = (real_T*) (((char_T*) (sig->crossMdlRef)) + dataOffset);\n\n        for(sigIdx=0;sigIdx<nSignals;sigIdx++) {\n            data[sigIdx] = crossMdlRef[sigIdx];\n        }\n\n        for (i = 0; i < nSignals; i++) {\n            MatrixData *mtxData = &(sig->crossMdlRef[i]);\n\n            (void)memcpy(mtxData->name, &CROSS_MDL_REF_FIELD_NAME, mxMAXNAM);\n            mtxData->nRows   = 1;\n            mtxData->nCols   = 1;\n            mtxData->nDims   = 1; /* => matlab scalar */\n\n            mtxData->re      = &data[i];\n            mtxData->im      = NULL;\n            mtxData->dTypeID = SS_DOUBLE;\n            mtxData->mxID    = rt_GetMxIdFromDTypeId(SS_DOUBLE);\n            mtxData->elSize  = sizeof(real_T);\n            mtxData->logical = matLOGICAL_BIT;\n            mtxData->complex = 0U;\n            mtxData->frameData = 0;\n            mtxData->frameSize = 1;\n        }\n        ++sig->numActiveFields;\n    }\n    \n    return(NULL); /* NORMAL_EXIT */\n\n  ERROR_EXIT:\n\n    (void)fprintf(stderr, \"*** Error creating signals structure \"\n                  \"in the struct log variable %s\\n\", var->name);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyLogVar(sig->values);\n    FREE(sig->labels);\n    FREE(sig->plotStyles);\n    FREE(sig->dimensions);\n    FREE(sig->titles);\n    FREE(sig->blockNames);\n    FREE(sig->stateNames);\n    FREE(sig->crossMdlRef);\n    return(*errStatus);\n\n} /* end rt_InitSignalsStruct */\n\n\n/* Function: local_CreateStructLogVar ==========================================\n * Abstract:\n *      Create a logging variable in the structure format.\n *\n * Returns:\n *      ~= NULL  => success, returns the log variable created.\n *      == NULL  => failure, error message set in the simstruct.\n */\nstatic StructLogVar *local_CreateStructLogVar(\n    RTWLogInfo              *li,\n    const real_T            startTime,\n    const real_T            finalTime,\n    const real_T            inStepSize,\n    const char_T            **errStatus,\n    const char_T            *varName,\n    boolean_T               logTime,\n    int_T                   maxRows,\n    int_T                   decimation,\n    real_T                  sampleTime,\n    const RTWLogSignalInfo  *sigInfo,\n    const char_T            *blockName)\n{\n    StructLogVar *var;\n    LogInfo      *logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ( (var = calloc(1, sizeof(StructLogVar))) == NULL ) goto ERROR_EXIT;\n\n    var->numActiveFields = 2;\n\n    /* Setup the structure name using varName and nameModifier */\n    rt_LoadModifiedLogVarName(li,varName,var->name);\n\n    /* time field */\n    if (logTime) {\n        /* need to create a LogVar to log time */\n        int_T dims = 1;\n        var->time = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                               inStepSize, errStatus,\n                                               &TIME_FIELD_NAME, SS_DOUBLE, \n                                               NULL,\n                                               0, 0, 0, 1,\n                                               1, &dims, NO_LOGVALDIMS, \n                                               NULL, NULL, maxRows,\n                                               decimation, sampleTime, 0);\n        if (var->time == NULL) goto ERROR_EXIT;\n    } else {\n        /* create a dummy MatrixData to write out time as an empty matrix */\n        BuiltInDTypeId dt     = rt_GetActualDTypeID(SS_DOUBLE);\n        size_t         nbytes = sizeof(MatrixData);\n        MatrixData     *time;\n\n        if ( (var->time = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n        time = var->time;\n\n        (void)memcpy(time->name, &TIME_FIELD_NAME, mxMAXNAM);\n        time->nRows   = 0;\n        time->nCols   = 0;\n        time->nDims   = 0;\n        time->re      = NULL;\n        time->im      = NULL;\n        time->dTypeID = dt;\n        time->mxID    = rt_GetMxIdFromDTypeId(dt);\n        time->elSize  = rt_GetSizeofDataType(dt);\n        time->logical = 0U;\n        time->complex = 0U;\n    }\n    var->logTime = logTime;\n\n    /* signals field */\n    if (sigInfo) {\n        if (rt_InitSignalsStruct(li,startTime,finalTime,inStepSize,errStatus,\n                                 var,maxRows,decimation,sampleTime,sigInfo)) {\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* blockName Field */\n    if (blockName != NULL) {\n        int_T  dataLen = (int_T)strlen(blockName);\n        size_t nbytes;\n        size_t dataOffset = sizeof(MatrixData);\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        uint_T overhang   = (uint_T)(dataOffset % sizeof(short));\n\n        if (overhang) {                           /* polyspace DEFECT:DEAD_CODE [Not a defect:Unset] \n                                                    \"Needed for possible padding determination. */\n            dataOffset += (sizeof(short) - overhang);\n        }\n        /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n        nbytes = dataOffset + dataLen*sizeof(short);\n\n        if ( (var->blockName = calloc(nbytes, 1)) == NULL ) goto ERROR_EXIT;\n\n        (void)memcpy(var->blockName->name, &BLOCKNAME_FIELD_NAME, mxMAXNAM);\n        var->blockName->nRows   = (dataLen) ? 1 : 0;\n        var->blockName->nCols   = dataLen;\n\n        var->blockName->nDims   = 1;\n        var->blockName->dims    = var->blockName->_dims;\n        var->blockName->dims[0] = dataLen;\n        {\n            /*LINTED E_BAD_PTR_CAST_ALIGN*/\n            unsigned short *data = (unsigned short*)(((char_T*) (var->blockName))+dataOffset);\n            int_T   i;\n\n            for (i=0; i<dataLen; i++) {\n                data[i] = (uint8_T)blockName[i];\n            }\n            var->blockName->re  = data;\n        }\n        var->blockName->im      = NULL;\n        var->blockName->dTypeID = SS_INT16;\n        var->blockName->mxID    = mxCHAR_CLASS;\n        var->blockName->elSize  = sizeof(short);\n        var->blockName->logical = 0U;\n        var->blockName->complex = 0U;\n\n        ++var->numActiveFields;\n    }\n\n    /* Add this struct log var to the linked list in log info */\n    {\n        StructLogVar *list = logInfo->structLogVarsList;\n\n        if (list != NULL) {\n            while (list->next != NULL) {\n                list = list->next;\n            }\n            list->next = var;\n        } else {\n            logInfo->structLogVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Error creating log variable %s\\n\", varName);\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    rt_DestroyStructLogVar(var);\n    return(NULL);\n\n} /* end local_CreateStructLogVar */\n\n\n/* Function: rt_StartDataLoggingForOutput ======================================\n * Abstract:\n */\nstatic const char_T *rt_StartDataLoggingForOutput(RTWLogInfo   *li,\n                                                  const real_T startTime,\n                                                  const real_T finalTime,\n                                                  const real_T stepSize,\n                                                  const char_T **errStatus)\n{\n    const char_T   *varName;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    LogInfo *       logInfo;\n    logInfo = rtliGetLogInfo(li);\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    /* outputs */\n    varName = rtliGetLogY(li);\n    if (varName[0] != '\\0') {\n        int_T                  i;\n        int_T                  ny;\n        int_T                  yIdx;\n        char_T                 name[mxMAXNAM];\n        const char_T           *cp        = strchr(varName,',');\n        LogSignalPtrsType      ySigPtrs   = rtliGetLogYSignalPtrs(li);\n        const RTWLogSignalInfo *yInfo     = rtliGetLogYSignalInfo(li);\n\n        /* count the number of variables (matrices or structures) to create */\n        for (ny=1; cp != NULL; ny++) {\n            cp = strchr(cp+1,',');\n        }\n        logInfo->ny = ny;\n\n        if (logFormat==0) {\n            if ( (logInfo->y = calloc(ny,sizeof(LogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        } else {\n            if ( (logInfo->y = calloc(ny,sizeof(StructLogVar*))) == NULL ) {\n                *errStatus = rtMemAllocError;\n                goto ERROR_EXIT;\n            }\n        }\n\n        for (i = yIdx = 0, cp = varName; i < ny; i++) {\n            int_T        len;\n            const char_T *cp1 = strchr(cp+1,',');\n\n            if (cp1 != NULL) {\n                /*LINTED E_ASSIGN_INT_TO_SMALL_INT*/\n                len = (int_T)(cp1 - cp);\n                if (len >= mxMAXNAM) len = mxMAXNAM - 1;\n            } else {\n                len = mxMAXNAM - 1;\n            }\n            (void)strncpy(name, cp, len);\n            name[len] = '\\0';\n\n            if (ny > 1 && ySigPtrs[i] == NULL) {\n                goto NEXT_NAME;\n            }\n\n            if (logFormat == 0) {\n                int            numCols;\n                int            nDims;\n                const int      *dims;\n                BuiltInDTypeId dataType;\n                int            isComplex;\n\n                if (ny == 1) {\n                    int_T op;\n\n                    numCols = yInfo[0].numCols[0];\n                    for (op = 1; op < yInfo[0].numSignals; op++) {\n                        numCols += yInfo[0].numCols[op];\n                    }\n                    /*\n                     * If we have only one \"matrix\" outport,\n                     * we can still log it as a matrix\n                     */\n                    if (yInfo[0].numSignals == 1) {\n                        nDims = yInfo[0].numDims ? yInfo[0].numDims[0] : 1;\n                        dims  = yInfo[0].dims;\n                    } else {\n                        nDims = 1;\n                        dims  = &numCols;\n                    }\n\n                    dataType  = yInfo[0].dataTypes[0];\n                    isComplex = yInfo[0].complexSignals[0];\n                } else {\n                    numCols   = yInfo[yIdx].numCols[0];\n                    nDims     = yInfo[yIdx].numDims ? yInfo[yIdx].numDims[0] : 1;\n                    dims      = yInfo[yIdx].dims;\n                    dataType  = yInfo[yIdx].dataTypes[0];\n                    isComplex = yInfo[yIdx].complexSignals[0];\n                }\n\n                logInfo->y[yIdx] = rt_CreateLogVarWithConvert(\n                    li, startTime, finalTime,\n                    stepSize, errStatus,\n                    name,\n                    dataType,\n                    yInfo[yIdx].dataTypeConvert,\n                    0,isComplex,\n                    0,numCols,nDims,dims,\n                    NO_LOGVALDIMS, NULL, NULL,\n                    maxRows,decimation,\n                    sampleTime,1);\n                if (logInfo->y[yIdx] == NULL)  goto ERROR_EXIT;\n            } else {\n                logInfo->y[yIdx] = local_CreateStructLogVar(li, startTime,\n                                                            finalTime, stepSize,\n                                                            errStatus, name,\n                                                            logTime, maxRows,\n                                                            decimation, sampleTime,\n                                                            &yInfo[yIdx], NULL);\n                if (logInfo->y[yIdx] == NULL) goto ERROR_EXIT;\n            }\n            ++yIdx;\n        NEXT_NAME:\n            cp = cp1;\n            if (cp != NULL && *cp == ',') cp++;\n        }\n    }\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) { /* polyspace DEFECT:USELESS_IF [No action planned:Unset] \n                     \"Defense coding.\" */\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo->y);\n        logInfo->y = NULL;\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingForOutput */\n\n\n/* Function: rt_ReallocLogVar ==================================================\n * Abstract:\n *   Allocate more memory for the data buffers in the log variable.\n *   Exit if unable to allocate more memory.\n */\nstatic void rt_ReallocLogVar(LogVar *var, boolean_T isVarDims)\n{\n    void *tmp;\n    int_T nCols = var->data.nCols;\n    int_T nRows;\n    size_t elSize = var->data.elSize;\n\n    if (isVarDims)\n    {\n        nRows = var->data.nRows + DEFAULT_BUFFER_SIZE;\n    }\n    else\n    {\n        nRows = var->data.nRows == 0 ? 1 : 2*var->data.nRows;\n    }\n    \n    tmp = realloc(var->data.re, nRows*nCols*elSize);\n    if (tmp == NULL) {\n        (void)fprintf(stderr,\n                      \"*** Memory allocation error.\\n\");\n        (void)fprintf(stderr, \"\"\n                      \"    varName          = %s%s\\n\"\n                      \"    nRows            = %d\\n\"\n                      \"    nCols            = %d\\n\"\n                      \"    elementSize      = %lu\\n\"\n                      \"    Current Size     = %.16g\\n\"\n                      \"    Failed resize    = %.16g\\n\\n\",\n                      var->data.name,\n                      var->data.complex ? \" (real part)\" : \"\",\n                      var->data.nRows,\n                      var->data.nCols,\n                      (unsigned long)  var->data.elSize,\n                      (double)nRows*nCols*elSize,\n                      (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n        exit(1);\n    }\n    var->data.re = tmp;\n\n    if (var->data.complex) {\n        tmp = realloc(var->data.im, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s (complex part)\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->data.name,\n                          var->data.nRows,\n                          var->data.nCols,\n                          (unsigned long)  var->data.elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n        var->data.im = tmp;\n    }\n    var->data.nRows = nRows;\n\n    /* Also reallocate memory for \"valueDimensions\" \n       when logging the variable-size signal\n    */\n    if(isVarDims){\n        int_T k;\n        \n        nCols = var->valDims->nCols;\n        nRows = var->valDims->nRows + DEFAULT_BUFFER_SIZE;\n        elSize = sizeof(real_T);\n        tmp = realloc(var->valDims->dimsData, nRows*nCols*elSize);\n        if (tmp == NULL) {\n            (void)fprintf(stderr,\n                          \"*** Memory allocation error.\\n\");\n            (void)fprintf(stderr, \"\"\n                          \"    varName          = %s\\n\"\n                          \"    nRows            = %d\\n\"\n                          \"    nCols            = %d\\n\"\n                          \"    elementSize      = %lu\\n\"\n                          \"    Current Size     = %.16g\\n\"\n                          \"    Failed resize    = %.16g\\n\\n\",\n                          var->valDims->name,\n                          var->valDims->nRows,\n                          var->valDims->nCols,\n                          (unsigned long)  elSize,\n                          (double)nRows*nCols*elSize,\n                          (double)(nRows+DEFAULT_BUFFER_SIZE)*nCols*elSize);\n            exit(1);\n        }\n\n        /*\n         * valueDimensions data is stored in array format and must be\n         * adjusted after reallocation (see also rt_FixupLogVar())\n         *\n         * Example: maxRows = 4; nRows = 4; nDims = 3;\n         * Before realloc of the logVar, the locations of data are as below:\n         * (x, y, z -- useful data / o -- junk, don't care)\n         * a[0] = x    a[4] = y    a[8] = z\n         * a[1] = x    a[5] = y    a[9] = z\n         * a[2] = x    a[6] = y    a[10]= z\n         * a[3] = x    a[7] = y    a[11]= z\n         *\n         * After realloc of the logVar (suppose 2 extra rows are added),\n         * the locations of data are as below:\n         * a[0] = x    a[6] = y    a[12]= o\n         * a[1] = x    a[7] = y    a[13]= o\n         * a[2] = x    a[8] = z    a[14]= o\n         * a[3] = x    a[9] = z    a[15]= o\n         * a[4] = y    a[10]= z    a[16]= o\n         * a[5] = y    a[11]= z    a[17]= o\n         *\n         * The data must be adjusted as below:\n         * a[0] = x    a[6] = y    a[12]= z\n         * a[1] = x    a[7] = y    a[13]= z\n         * a[2] = x    a[8] = y    a[14]= z\n         * a[3] = x    a[9] = y    a[15]= z\n         * a[4] = o    a[10]= o    a[16]= o\n         * a[5] = o    a[11]= o    a[17]= o\n         */\n        for(k = var->data.nDims-1; k > 0; k--){\n            (void) memcpy((real_T*)tmp + k*nRows, \n                          (real_T*)tmp + k*var->valDims->nRows,\n                          elSize * var->valDims->nRows);\n        }\n\n        var->valDims->dimsData = tmp;\n        var->valDims->nRows = nRows;\n    }\n\n} /* end rt_ReallocLogVar */\n\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs);\n                                             \n/* Function: rt_UpdateLogVarWithDiscontinuousData ==============================\n * Abstract:\n *      Log one row of the LogVar with data that is not contiguous.\n */\nconst char_T *rt_UpdateLogVarWithDiscontiguousData(LogVar                 *var,\n                                             int8_T**               data,\n                                             const int_T            *segmentLengths,\n                                             int_T                  nSegments,\n                                             RTWPreprocessingFcnPtr *preprocessingPtrs)\n{\n    size_t elSize = 0;\n    size_t offset = 0;\n    int    segIdx = 0;\n\n    if (++var->numHits % var->decimation) return(NULL);\n    var->numHits = 0;\n\n    /*\n     * Reallocate or wrap the LogVar\n     */\n    if (var->rowIdx == var->data.nRows) {\n        if (var->okayToRealloc == 1) {\n            rt_ReallocLogVar(var, false);\n        } else {\n            /* Circular buffer */\n            var->rowIdx = 0;\n            ++(var->wrapped); /* increment the wrap around counter */\n        }\n    }\n\n    /* This function is only used to log states, there's no var-dims issue. */\n    elSize = var->data.elSize;\n    offset = (size_t)(elSize * var->rowIdx * var->data.nCols);\n\n    if (var->data.complex) {\n        char_T *dstRe = (char_T*)(var->data.re) + offset;\n        char_T *dstIm = (char_T*)(var->data.im) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            int_T         nEl  = segmentLengths[segIdx];\n            char_T *src        = (char_T *)data[segIdx];\n            int_T         el;\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(elSize * nEl * 2);\n                preprocessingPtr(src, (void *)data[segIdx]);\n            }\n\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);\n            }\n            else {\n                for (el = 0; el < nEl; el++) {\n                    (void)memcpy(dstRe, src, elSize);\n                    dstRe += elSize;   src += elSize;\n                    (void)memcpy(dstIm, src, elSize);\n                    dstIm += elSize;   src += elSize;\n                }\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    } else {\n        char_T *dst = (char_T*)(var->data.re) + offset;\n\n        for (segIdx = 0; segIdx < nSegments; segIdx++) {\n            size_t      segSize = elSize*segmentLengths[segIdx];\n            char_T *src         = (void *) data[segIdx];\n\n            /* preprocess data in-place before logging */\n            RTWPreprocessingFcnPtr preprocessingPtr = preprocessingPtrs[segIdx];\n            if (preprocessingPtr != NULL) {\n                src = malloc(segSize);\n                preprocessingPtr(src, data[segIdx]);\n            }\n            if (src == NULL) {\n                const char_T *errorMessage = \"Could not allocate memory for logging.\";\n                fprintf(stderr,\"%s.\\n\", errorMessage);\n                return(errorMessage);            }\n            else {\n                (void)memcpy(dst, src, segSize);\n                dst += segSize;\n            }\n\n            /* free temporarily declared data */\n            if (preprocessingPtr != NULL) {\n                free( src );\n            }\n        }\n    }\n\n    ++var->rowIdx;\n    return(NULL);\n\n} /* end rt_UpdateLogVarWithDiscontinuousData */\n\n\n/*==================*\n * Visible routines *\n *==================*/\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_CreateLogVarWithConvert ========================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVarWithConvert(\n    RTWLogInfo        *li,\n    const real_T      startTime,\n    const real_T      finalTime,\n    const real_T      inStepSize,\n    const char_T      **errStatus,\n    const char_T      *varName,\n    BuiltInDTypeId    inpDataTypeID,\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo,\n    int_T             logical,\n    int_T             complex,\n    int_T             frameData,\n    int_T             nCols,\n    int_T             nDims,\n    const int_T       *dims,\n    LogValDimsStat    logValDimsStat,\n    void              **currSigDims,\n    int_T             *currSigDimsSize,\n    int_T             maxRows,\n    int_T             decimation,\n    real_T            sampleTime,\n    int_T             appendToLogVarsList)\n{\n    int_T          usingDefaultBufSize = 0;\n#ifdef NO_LOGGING_REALLOC\n    int_T          okayToRealloc       = 0;\n#else\n    int_T          okayToRealloc       = 1;\n#endif\n    LogVar         *var                = NULL;\n    /*inpDataTypeID is the rt_LoggedOutputDataTypeId*/\n    BuiltInDTypeId dTypeID             = (BuiltInDTypeId)inpDataTypeID; \n    size_t         elementSize         = rt_GetSizeofDataType(dTypeID);\n    int_T          frameSize;\n    int_T          nRows;\n    int_T          nColumns;\n\n    /*===================================================================*\n     * Determine the frame size if the data is frame based               *\n     *===================================================================*/\n    frameSize = frameData ? dims[0] : 1;\n\n    /*===================================================================*\n     * Calculate maximum number of rows needed in the buffer             *\n     *===================================================================*/\n\n    if (finalTime > startTime && finalTime != rtInf) {\n        real_T nPoints;            /* Tfinal is finite  ===>  nRows can be  */\n        real_T stepSize;           /* computed since the StepSize is fixed  */\n\n        if (sampleTime == -2.0) {  /* The signal being logged is constant,  *\n                                    * Hence, only one data point is logged. */\n            stepSize = finalTime;\n        } else if (sampleTime == -1.0 || sampleTime == 0.0) {\n                                /* Signal being logged is either inside a    *\n                                 * triggered sub-system or it is continuous. */\n            stepSize = inStepSize;\n        } else {                /* Discrete signal */\n            stepSize = sampleTime;\n        }\n\n        if (stepSize == 0.0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {\n            nPoints = 1.0 + floor((finalTime-startTime)/stepSize);\n\n            /*\n             * Add one more data point if needed.\n             */\n            if ( stepSize*(nPoints-1.0) < (finalTime-startTime) ) {\n                nPoints += 1.0;\n            }\n\n            /*\n             * Actual number of points to log = nPoints * size of\n             * each frame if data is frame-based\n             */\n            nPoints = frameData ? (nPoints * frameSize) : nPoints;\n\n            nPoints /= decimation;\n            if (nPoints != floor(nPoints)) {\n                nPoints += 1.0;\n            }\n            nRows = (nPoints <= INT_MAX) ? ((int_T) nPoints) : INT_MAX;\n        }\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (finalTime == startTime) {\n        /*\n         * Number of rows to log is equal to 1 if not frame-based and\n         * equal to frame size if frame-based\n         */\n        nRows = frameData ? frameSize : 1;\n\n        /*\n         * If maxRows is specified, and if this number is less\n         * than the number we computed (nRows) then use maxRows.\n         */\n        if ((maxRows > 0) && (maxRows < nRows)) {\n            nRows = maxRows;\n            okayToRealloc = 0;\n        }\n    } else if (maxRows > 0) {     /* maxRows is specified => nRows=maxRows  */\n        nRows = maxRows;\n        okayToRealloc = 0;\n    } else {\n\n        if (inStepSize == 0) {\n            /* small initial value, so as to exercise the realloc code */\n            nRows = maxRows+1;\n            okayToRealloc = 1;\n        } else {                    /* Use a default value for nRows          */\n            usingDefaultBufSize = 1;\n            nRows = DEFAULT_BUFFER_SIZE;\n            okayToRealloc = 0;  /* No realloc with infinite stop time */\n            (void)fprintf(stdout, \"*** Using a default buffer of size %d for \"\n                          \"logging variable %s\\n\", nRows, varName);\n        }\n    }\n\n    /*\n     * Figure out the number of columns that the log variable should have.\n     * If the data is not frame based, then number of columns should equal\n     * nCols that is provided as input to the function. If the data is\n     * frame-based, then the number of columns should be equal to the\n     * number of channels = nCols/frameSize = dims[1];\n     */\n    nColumns = frameData ? dims[1] : nCols;\n\n    /*\n     * Error out if the size of the circular buffer is absurdly large, this\n     * error message is more informative than the one we get when we try to\n     * malloc this many number of bytes in one fell swoop.\n     */\n    {\n        double tmpDbl = ((double)elementSize)*((double)nRows)*\n                                              ((double)nColumns);\n\n        if (tmpDbl >= UINT_MAX) {\n            (void)fprintf(stderr,\n                          \"\\n*** Memory required to log variable '%s' is too\"\n                          \"\\n    big. Use the 'Limit rows to last:' and (or)\"\n                          \"\\n    'Decimation:' options to reduce the required\"\n                          \"\\n    memory size.\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Required  = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long)\n                          elementSize, tmpDbl);\n            goto ERROR_EXIT;\n        }\n    }\n\n    /* Allocate memory for the log variable */\n    if ( (var = calloc(1, sizeof(LogVar))) == NULL ) {\n        (void)fprintf(stderr, \"*** Error allocating memory for logging %s\\n\",\n                      varName);\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer (real part) */\n    if ( (var->data.re = malloc(nRows*nColumns*elementSize)) == NULL ) {\n        (void)fprintf(stderr,\n                      \"*** Error allocating memory for the circular buffer\\n\");\n        (void)fprintf(stderr, \"*** Details:\\n\"\n                      \"       varName         = %s\\n\"\n                      \"       nRows           = %d\\n\"\n                      \"       nCols           = %d\\n\"\n                      \"       elementSize     = %lu\\n\"\n                      \"       Bytes Requested = %.16g\\n\\n\",\n                      varName, nRows, nColumns, (unsigned long) elementSize,\n                      ((double)elementSize)*((double)nRows)*((double)nColumns));\n        goto ERROR_EXIT;\n    }\n\n    /* Allocate memory for the circular buffer for the imaginary part */\n    if (complex) {\n        if ( (var->data.im = malloc(nRows*nColumns*elementSize)) == NULL ) {\n            (void)fprintf(stderr,\n                          \"*** Error allocating memory for the circular buffer \"\n                          \"for logging the imaginary part of %s\\n\", varName);\n            (void)fprintf(stderr, \"*** Details:\\n\"\n                          \"       varName         = %s\\n\"\n                          \"       nRows           = %d\\n\"\n                          \"       nCols           = %d\\n\"\n                          \"       elementSize     = %lu\\n\"\n                          \"       Bytes Requested = %.16g\\n\\n\",\n                          varName, nRows, nColumns, (unsigned long) elementSize,\n                          ((double)elementSize)*((double)nRows)*\n                                                 ((double)nColumns));\n            goto ERROR_EXIT;\n        }\n    }\n    /*\n     * Initialize the fields in LogVar structure.\n     */\n    if (appendToLogVarsList) {\n        rt_LoadModifiedLogVarName(li,varName,var->data.name);\n    } else {\n        var->data.name[mxMAXNAM-1] = '\\0';\n        (void)strncpy(var->data.name,varName,mxMAXNAM-1);\n    }\n    var->data.nCols           = nColumns;\n    var->data.nRows           = nRows;\n\n    var->data.nDims           = frameData ? 1 : nDims;\n    if (var->data.nDims > 2) {\n        var->data.dims = (int_T*)malloc(sizeof(int_T)*var->data.nDims);\n    } else {\n        var->data.dims = var->data._dims;\n    }\n    if (frameData) {\n        var->data.dims[0] = nColumns;\n    } else {\n        /*LINTED E_CAST_INT_TO_SMALL_INT*/\n        (void)memcpy(var->data.dims, dims, (size_t)(nDims*sizeof(int_T)));\n    }\n\n    var->data.dTypeID         = dTypeID;\n    var->data.elSize          = elementSize;\n\n    var->data.dataTypeConvertInfo = rt_GetDataTypeConvertInfo(\n        pDataTypeConvertInfo, dTypeID);\n\n    var->data.mxID            = rt_GetMxIdFromDTypeId(dTypeID);\n    /* over-ride logical bit if data type is boolean */\n    logical = dTypeID == SS_BOOLEAN ? 1 : 0;\n    var->data.logical         = (logical)   ? matLOGICAL_BIT : 0x0;\n    var->data.complex         = (complex)   ? matCOMPLEX_BIT : 0x0;\n    var->data.frameData       = frameData;\n    var->data.frameSize       = (frameData) ? frameSize : 1;\n\n    /* fill up valDims field */\n    if(logValDimsStat == NO_LOGVALDIMS){\n        /* All signals are fixed-size, no need to log valueDimensions field */\n        var->valDims     = NULL;\n        /* Set these pointers to NULLs in this case */\n        var->coords      = NULL;\n        var->strides     = NULL;\n        var->currStrides = NULL;\n    }\n    else{\n        if ( (var->valDims = calloc(1, sizeof(ValDimsData))) == NULL ) {\n            goto ERROR_EXIT;\n        }\n\n        (void)memcpy(var->valDims->name, &VALUEDIMENSIONS_FIELD_NAME, mxMAXNAM);\n\n        if (logValDimsStat == LOGVALDIMS_EMPTYMX) {\n            /* At least one signal is variable-size, \n               but the current signal is fixed-size. \n               Therefore, create a dummy MatrixData to write out valueDimensions \n               as an empty matrix. \n            */\n            var->valDims->nRows = 0;\n            var->valDims->nCols = 0;\n            var->valDims->currSigDims = NULL;\n            var->valDims->currSigDimsSize = NULL;\n            var->valDims->dimsData = NULL;\n            /* Set these pointers to NULLs in this case */\n            var->coords      = NULL;\n            var->strides     = NULL;\n            var->currStrides = NULL;\n        } else { /* The current signal is a variable-size signal. */\n            /* The \"valueDimensions\" must be double, so re-assign element size */\n            elementSize = sizeof(real_T);\n\n            /* When signals are frame-based, 'valueDimensions' has 1 column */\n            if(frameData){\n                /* When signal is frame-based, the first dimension is always fixed, \n                   so we only need to record the second dimension.\n                   e.g. Two frame-based signals [10x4] and [10x3], \n                   'valueDimensions' and 'currSigDims'\n                   only record 4 or 3.\n                */\n                nColumns = 1;\n                var->valDims->currSigDims = (void**) (currSigDims + 1);\n                var->valDims->currSigDimsSize = (int_T*) (currSigDimsSize + 1);\n            } else { /* non-frame based */\n                nColumns = nDims;\n                var->valDims->currSigDims = (void**) currSigDims;\n                var->valDims->currSigDimsSize = (int_T*) currSigDimsSize;\n            }\n            \n            /* Allocate memory for the circular buffer */\n            if ( (var->valDims->dimsData = malloc(nRows*nColumns*elementSize)) == NULL ) {\n                (void)fprintf(stderr,\n                              \"*** Error allocating memory for the circular buffer\\n\");\n                (void)fprintf(stderr, \"*** Details:\\n\"\n                              \"       varName         = %s\\n\"\n                              \"       nRows           = %d\\n\"\n                              \"       nCols           = %d\\n\"\n                              \"       elementSize     = %lu\\n\"\n                              \"       Bytes Requested = %.16g\\n\\n\",\n                              var->valDims->name, nRows, nColumns, (unsigned long) elementSize,\n                              ((double)elementSize)*((double)nRows)*((double)nColumns));\n                goto ERROR_EXIT;\n            }\n            var->valDims->nRows = nRows;\n            var->valDims->nCols = nColumns;\n\n            /* Allocate memory for these dynamic arrays */\n            {\n                size_t nbytes = var->data.nDims*sizeof(int_T);\n                if( ((var->coords = calloc(nbytes, 1)) == NULL)\n                    ||((var->strides = calloc(nbytes, 1)) == NULL)\n                    ||((var->currStrides = calloc(nbytes, 1)) == NULL) )\n                    goto ERROR_EXIT;\n            }\n        }\n    }\n\n    var->rowIdx               = 0;\n    var->wrapped              = 0;\n    var->nDataPoints          = 0;\n    var->usingDefaultBufSize  = usingDefaultBufSize;\n    var->okayToRealloc        = okayToRealloc;\n    var->decimation           = decimation;\n    var->numHits              = -1;  /* so first point gets logged */\n\n    /* Add this log var to list in log info, if necessary */\n    if (appendToLogVarsList) {\n        LogInfo *logInfo = (LogInfo*) rtliGetLogInfo(li);\n        LogVar  *varList = logInfo->logVarsList;\n\n        if (varList != NULL) {\n            while (varList->next != NULL) {\n                varList = varList->next;\n            }\n            varList->next = var;\n        } else {\n            logInfo->logVarsList = var;\n        }\n    }\n\n    return(var); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    \n    *errStatus = rtMemAllocError;\n    rt_DestroyLogVar(var);\n    return(NULL);\n\n} /* end rt_CreateLogVarWithConvert */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateLogVar ===================================================\n * Abstract:\n *\tCreate a logging variable.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nLogVar *rt_CreateLogVar(RTWLogInfo        *li,\n                               const real_T      startTime,\n                               const real_T      finalTime,\n                               const real_T      inStepSize,\n                               const char_T      **errStatus,\n                               const char_T      *varName,\n                               BuiltInDTypeId    inpDataTypeID,\n                               int_T             logical,\n                               int_T             complex,\n                               int_T             frameData,\n                               int_T             nCols,\n                               int_T             nDims,\n                               const int_T       *dims,\n                               LogValDimsStat    logValDimsStat,\n                               void              **currSigDims,\n                               int_T             *currSigDimsSize,\n                               int_T             maxRows,\n                               int_T             decimation,\n                               real_T            sampleTime,\n                               int_T             appendToLogVarsList)\n{\n    const RTWLogDataTypeConvert *pDataTypeConvertInfo = NULL;\n\n    return rt_CreateLogVarWithConvert(li,\n                                      startTime,\n                                      finalTime,\n                                      inStepSize,\n                                      errStatus,\n                                      varName,\n                                      inpDataTypeID,\n                                      pDataTypeConvertInfo,\n                                      logical,\n                                      complex,\n                                      frameData,\n                                      nCols,\n                                      nDims,\n                                      dims,\n                                      logValDimsStat,\n                                      currSigDims,\n                                      currSigDimsSize,\n                                      maxRows,\n                                      decimation,\n                                      sampleTime,\n                                      appendToLogVarsList);\n\n} /* end rt_CreateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_CreateStructLogVar =============================================\n * Abstract:\n *\tCreate a logging variable in the structure format.\n *\n * Returns:\n *\t~= NULL  => success, returns the log variable created.\n *\t== NULL  => failure, error message set in the simstruct.\n */\nStructLogVar *rt_CreateStructLogVar(RTWLogInfo              *li,\n                                           const real_T            startTime,\n                                           const real_T            finalTime,\n                                           const real_T            inStepSize,\n                                           const char_T            **errStatus,\n                                           const char_T            *varName,\n                                           boolean_T               logTime,\n                                           int_T                   maxRows,\n                                           int_T                   decimation,\n                                           real_T                  sampleTime,\n                                           const RTWLogSignalInfo  *sigInfo,\n                                           const char_T            *blockName)\n{\n\n    return( local_CreateStructLogVar(li,\n                                     startTime,\n                                     finalTime,\n                                     inStepSize,\n                                     errStatus,\n                                     varName,\n                                     logTime,\n                                     maxRows,\n                                     decimation,\n                                     sampleTime,\n                                     sigInfo,\n                                     blockName));\n\n} /* end rt_CreateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_StartDataLoggingWithStartTime ==================================\n * Abstract:\n *      Initialize data logging info based upon the following settings cached\n *      in the RTWLogging data structure of the SimStruct.\n *\n * Return value is:\n *\t== NULL  => success\n *\t!= NULL  => failure (the return value is a pointer that points to the\n *                           error message, which is also set in the simstruct)\n */\nconst char_T *rt_StartDataLoggingWithStartTime(RTWLogInfo   *li,\n                                                      const real_T startTime,\n                                                      const real_T finalTime,\n                                                      const real_T stepSize,\n                                                      const char_T **errStatus)\n{\n    const char_T   *varName;\n    LogInfo        *logInfo;\n    real_T         sampleTime = stepSize;\n    int_T          maxRows    = rtliGetLogMaxRows(li);\n    int_T          decimation = rtliGetLogDecimation(li);\n    int_T          logFormat  = rtliGetLogFormat(li);\n    boolean_T      logTime    = (logFormat==2) ? 1 : 0;\n\n    /* reset error status */\n    *errStatus = NULL;\n\n    if ((logInfo=calloc(1,sizeof(LogInfo))) == NULL) {\n        *errStatus = rtMemAllocError;\n        goto ERROR_EXIT;\n    }\n    rtliSetLogInfo(li, (void*)logInfo);\n\n    /* time */\n    varName = rtliGetLogT(li);\n    if (varName[0] != '\\0') {\n        int_T dims = 1;\n        logInfo->t = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                stepSize, errStatus,\n                                                varName,SS_DOUBLE,\n                                                NULL,\n                                                0,0,0,1,1,\n                                                &dims, NO_LOGVALDIMS, NULL, NULL,\n                                                maxRows,decimation,\n                                                sampleTime,1);\n        if (logInfo->t == NULL) goto ERROR_EXIT;\n    }\n\n    /* states */\n    if ( rtliGetLogX(li)[0] != '\\0' ||  rtliGetLogXFinal(li)[0] != '\\0' ) {\n        const RTWLogSignalInfo  *xInfo = rtliGetLogXSignalInfo(li);\n\n        if (logFormat == 0) {                                /* Matrix Format */\n            int            numCols;\n            int            nDims;\n            const int      *dims;\n            BuiltInDTypeId dataType;\n            int            isComplex;\n            int_T          sIdx;\n\n            const RTWLogDataTypeConvert *pDTConvInfo;\n\n            numCols = xInfo[0].numCols ? xInfo[0].numCols[0] : 0;\n            for (sIdx = 1; sIdx < xInfo[0].numSignals; sIdx++) {\n                numCols += xInfo[0].numCols[sIdx];\n            }\n            /* If we have only one \"matrix\" state, we can log as a matrix */\n            if (xInfo[0].numSignals == 1) {\n                nDims     = xInfo[0].numDims ? xInfo[0].numDims[0] : 1;\n                dims      = xInfo[0].dims;\n            } else {\n                nDims     = 1;\n                dims      = &numCols;\n            }\n            dataType  = xInfo[0].dataTypes ? xInfo[0].dataTypes[0] : 0;\n            isComplex = xInfo[0].complexSignals ? xInfo[0].complexSignals[0] : 0;\n\n            pDTConvInfo = xInfo[0].dataTypeConvert;\n\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                        stepSize, errStatus,\n                                                        rtliGetLogX(li),dataType,\n                                                        pDTConvInfo,\n                                                        0,\n                                                        isComplex,0,numCols,nDims,dims,\n                                                        NO_LOGVALDIMS, NULL, NULL,\n                                                        maxRows,decimation,sampleTime,1);\n                if (logInfo->x == NULL)  goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = rt_CreateLogVarWithConvert(li, startTime, finalTime,\n                                                             stepSize, errStatus,\n                                                             rtliGetLogXFinal(li),dataType,\n                                                             pDTConvInfo,\n                                                             0,isComplex,0,numCols,nDims,\n                                                             dims, NO_LOGVALDIMS, NULL, \n                                                             NULL, 1,decimation,\n                                                             sampleTime,1);\n                if (logInfo->xFinal == NULL)  goto ERROR_EXIT;\n            }\n        } else {                                          /* Structure Format */\n            if (rtliGetLogX(li)[0] != '\\0') {\n                logInfo->x = local_CreateStructLogVar(li, startTime, finalTime,\n                                                      stepSize, errStatus,\n                                                      rtliGetLogX(li), logTime,\n                                                      maxRows, decimation,\n                                                      sampleTime, xInfo, NULL);\n                if (logInfo->x == NULL) goto ERROR_EXIT;\n            }\n            if (rtliGetLogXFinal(li)[0] != '\\0') {\n                logInfo->xFinal = local_CreateStructLogVar(li, startTime, finalTime,\n                                                           stepSize, errStatus,\n                                                           rtliGetLogXFinal(li),\n                                                           logTime,1,decimation,\n                                                           sampleTime,xInfo,NULL);\n                if (logInfo->xFinal == NULL) goto ERROR_EXIT;\n            }\n        }\n    }\n\n    /* outputs */\n    *errStatus = rt_StartDataLoggingForOutput(li,startTime,finalTime,\n                                              stepSize,errStatus);\n    if (*errStatus != NULL)  goto ERROR_EXIT;\n\n    return(NULL); /* NORMAL_EXIT */\n\n ERROR_EXIT:\n    (void)fprintf(stderr, \"*** Errors occurred when starting data logging.\\n\");\n    if (*errStatus == NULL) {\n        *errStatus = rtMemAllocError;\n    }\n    if (logInfo) {\n        rt_DestroyLogVar(logInfo->logVarsList);\n        logInfo->logVarsList = NULL;\n        rt_DestroyStructLogVar(logInfo->structLogVarsList);\n        logInfo->structLogVarsList = NULL;\n        FREE(logInfo);\n        rtliSetLogInfo(li,NULL);\n    }\n    return(*errStatus);\n\n} /* end rt_StartDataLoggingWithStartTime */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StartDataLogging ===============================================\n * Abstract:\n */\nconst char_T *rt_StartDataLogging(RTWLogInfo   *li,\n                                         const real_T finalTime,\n                                         const real_T stepSize,\n                                         const char_T **errStatus)\n{\n    return rt_StartDataLoggingWithStartTime(li,\n                                            0.0,\n                                            finalTime,\n                                            stepSize,\n                                            errStatus);\n}\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n \n/* Function: rt_UpdateLogVar ===================================================\n * Abstract:\n *\tCalled to log data for a log variable.\n */\nvoid rt_UpdateLogVar(LogVar *var, const void *data, boolean_T isVarDims)\n{\n    size_t        elSize    = var->data.elSize;\n    const  char_T *cData    = data;\n    const  int_T  frameData = var->data.frameData;\n    const  int_T  frameSize = frameData ? (var->data.frameSize) : 1;\n    const  int_T  logWidth  = var->data.nCols;\n    BuiltInDTypeId dTypeID  = var->data.dTypeID;\n\n    size_t offset        = 0;\n    char_T *currRealRow  = NULL;\n    char_T *currImagRow  = NULL;\n    int_T  pointSize     = (int_T)((var->data.complex) ? rt_GetSizeofComplexType(dTypeID) : elSize);\n\n    int    i, j, k;\n\n    /* The following variables will be used for \n       logging variable-size signals */\n    const  int_T  nDims = var->data.nDims;\n    const  int_T  *dims = var->data.dims;\n    const  void   * const *currDimsPtr = NULL;\n    const  int_T  *currDimsSizePtr = NULL;\n\n    /* The following variables will be used for \n       logging \"valueDimensions\" field */\n    size_t offset_valDims   = 0;\n    char_T *currValDimsRow  = NULL;\n    size_t elSize_valDims   = sizeof(real_T);\n    real_T currentSigDims   = 0;\n    int_T  nRows_valDims    = 0;\n    int_T  logWidth_valDims = 0;\n\n    for (i = 0; i < frameSize; i++) {\n        if (++var->numHits % var->decimation) continue;\n        var->numHits = 0;\n\n        if (var->rowIdx == var->data.nRows) {\n            if (var->okayToRealloc == 1) {\n                rt_ReallocLogVar(var, isVarDims);\n            } else {\n                /* Circular buffer */\n                var->rowIdx = 0;\n                ++(var->wrapped); /* increment the wrap around counter */\n            }\n        }\n\n        if(isVarDims){\n            currDimsPtr = (const void * const *) var->valDims->currSigDims;\n            currDimsSizePtr = (const int_T*) var->valDims->currSigDimsSize;\n            logWidth_valDims = frameData ? 1 : var->valDims->nCols;\n            nRows_valDims = var->valDims->nRows;\n\n            var->strides[0] = 1;\n            var->currStrides[0] = 1;\n\n            for (k = 1; k < nDims; k++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[k-1]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+(k-1)));\n                    break;\n                }\n                var->strides[k] = var->strides[k-1] * dims[k-1];\n                var->currStrides[k] = var->currStrides[k-1] * currDimsVal;\n            }\n        }\n\n        offset       = (size_t)(elSize * var->rowIdx * logWidth);\n        currRealRow  = ((char_T*) (var->data.re)) + offset;\n        currImagRow  = (var->data.complex) ?\n                       ((char_T*) (var->data.im)) + offset :  NULL;\n\n        /* update logging data */\n        for (j = 0; j < logWidth; j++) {\n\n            boolean_T inRange = true;\n            int idx = j;\n\n            /* Check whether the currently logged value is in range or not.\n               For fixed-size signal logging, always inRange = true; idx = j;\n               For variable-size signal logging, use strides, coordinates\n               and current strides to decide whether the currently logged\n               data is in range or not and its location in the logging \n               matrix.\n             */\n            if(isVarDims){\n                int rem = j;\n                idx = 0;\n                for(k = nDims-1; k>=0; k--){\n                    int32_T currDimsVal=0;\n                    switch (currDimsSizePtr[k]) {\n                      case 1:\n                        currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+k));\n                        break;\n                      case 2:\n                        currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+k));\n                        break;\n                      case 4:\n                        currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+k));\n                        break;\n                    }\n                    var->coords[k] = rem / var->strides[k];\n                    if( var->coords[k] >= currDimsVal ){\n                        inRange = false;\n                        break;\n                    }\n                    rem = rem - var->coords[k] * var->strides[k];\n                }\n                if(inRange){\n                    idx = var->coords[0];\n                    for (k = 1; k < nDims; k++){\n                        idx += var->coords[k] * var->currStrides[k];\n                    }\n                }\n            }\n            \n            if (!var->data.dataTypeConvertInfo.conversionNeeded) {\n                /* NO  conversion needed\n                 */ \n                if (inRange) {\n                    /* If in range, fill in data */\n                    const char *cDataPoint = cData + (i+frameSize*idx) * pointSize;\n\n                    (void) memcpy(currRealRow, cDataPoint, elSize);\n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        (void) memcpy(currImagRow, cDataPoint + pointSize/2, elSize);\n                        currImagRow += elSize;\n                    }\n                } else {\n                    /* If out of range, fill in NaN or 0:\n                       1) For bool, int32, uint32, int16, uint16, etc,\n                          memset to zeros;\n                       2) For fixed-point data type, NaN conversion is not\n                          allowed, memset to zeros.\n                    */\n                    if (dTypeID == SS_DOUBLE) {\n                       ((real_T*)(currRealRow))[0] = rtNaN;\n                    } else if (dTypeID == SS_SINGLE){\n                        ((real32_T*)(currRealRow))[0] = rtNaNF;\n                    } else {\n                        (void) memset(currRealRow, 0, elSize);\n                    }\n                    \n                    currRealRow += elSize;\n                    if (var->data.complex) {\n                        /* For imaginary part, fill in 0 */\n                        (void) memset(currImagRow, 0, elSize);\n                        currImagRow += elSize;\n                    }\n                }\n            }\n            else\n            {\n                /* YES conversion needed\n                 */ \n                DTypeId dataTypeIdOriginal = \n                    var->data.dataTypeConvertInfo.dataTypeIdOriginal;\n                int_T DpSize = (int_T)((var->data.complex) ? \n                                       rt_GetSizeofComplexType(dataTypeIdOriginal) : \n                                       rt_GetSizeofDataType(dataTypeIdOriginal));\n\n                DTypeId dataTypeIdLoggingTo = \n                    var->data.dataTypeConvertInfo.dataTypeIdLoggingTo;\n\n                int bitsPerChunk = var->data.dataTypeConvertInfo.bitsPerChunk;\n                int numOfChunk =  var->data.dataTypeConvertInfo.numOfChunk;\n                unsigned int isSigned = var->data.dataTypeConvertInfo.isSigned;\n\n                double fracSlope = var->data.dataTypeConvertInfo.fracSlope;\n                int    fixedExp  = var->data.dataTypeConvertInfo.fixedExp;\n                double bias      = var->data.dataTypeConvertInfo.bias;\n\n                double curRealValue = -0.12345678987654;\n                double curImagValue = -0.12345678987654;\n\n                int_T adjIndexIfComplex = (var->data.complex) ? 2 : 1;\n\n                if(inRange){\n                    if(numOfChunk > 1)\n                    {\n                        /* For multiword */\n                        const char *pInData = (const char *)(cData);\n                        int dtSize = bitsPerChunk*numOfChunk/8;\n                        pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                        \n                        curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                       isSigned, fracSlope, fixedExp, bias);\n                        if (var->data.complex) {\n                            curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                           isSigned, fracSlope, fixedExp, bias);\n                        }\n                    }\n                    else\n                    {\n                        /* if in range, fill in data that is converted first */\n                        switch ( dataTypeIdOriginal )\n                        {\n                          case SS_DOUBLE:\n                            {\n                                const real_T *pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_SINGLE:\n                            {\n                                const real32_T *pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const real32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT8:\n                            {\n                                const int8_T *pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT8:\n                            {\n                                const uint8_T *pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint8_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT16:\n                            {\n                                const int16_T *pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT16:\n                            {\n                                const uint16_T *pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint16_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_INT32:\n                            {\n                                const int32_T *pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize);\n\n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const int32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_UINT32:\n                            {\n                                const uint32_T *pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize);\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    pInData = (const uint32_T *)(cData + (i+frameSize*idx)* DpSize + DpSize/2);\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          case SS_BOOLEAN:\n                            {\n                                const boolean_T *pInData = ((const boolean_T *)(cData));\n                                \n                                pInData += (i+frameSize*idx) * adjIndexIfComplex;\n                                \n                                curRealValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                if (var->data.complex) {\n                                    curImagValue = ldexp( fracSlope * (double)(*pInData), fixedExp ) + bias;\n                                }\n                            }\n                            break;\n                          default: \n                            {\n                                /* For biglong */\n                                const char *pInData = (const char *)(cData);\n                                int dtSize = bitsPerChunk*numOfChunk/8;\n                                pInData += ((i+frameSize*idx) * adjIndexIfComplex) * dtSize;\n                                \n                                curRealValue = rt_GetDblValueFromOverSizedData(pInData, bitsPerChunk, numOfChunk, \n                                                                               isSigned, fracSlope, fixedExp, bias);\n                                if (var->data.complex) {\n                                    curImagValue = rt_GetDblValueFromOverSizedData((pInData+dtSize), bitsPerChunk, numOfChunk, \n                                                                                   isSigned, fracSlope, fixedExp, bias);\n                                }\n                            }\n                            break;\n                        } /* -- end of switch -- */\n                    }\n                } else {\n                    /* if out of range, just fill NaN or 0 */\n                    if(dTypeID == SS_DOUBLE || dTypeID == SS_SINGLE){\n                        /* vijay 4/11/2013: DO NOT CALL ldexp() with NaN below as it causes \n                         * lcc-win64 to generate inf instead of NaN as output. \n                         * Just use rtNaN directly */\n                        curRealValue = rtNaN;\n                    }\n                    else{\n                        curRealValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                    if (var->data.complex) {\n                        /* fill 0 in imaginary part*/\n                        curImagValue = ldexp( 0, fixedExp ) + bias;\n                    }\n                }\n\n                switch ( dataTypeIdLoggingTo )\n                {\n                  case SS_DOUBLE:\n                    {\n                        *((real_T *)currRealRow) = (real_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real_T *)currImagRow) = (real_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_SINGLE:\n                    {\n                        *((real32_T *)currRealRow) = (real32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((real32_T *)currImagRow) = (real32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT8:\n                    {\n                        *((int8_T *)currRealRow) = (int8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int8_T *)currImagRow) = (int8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT8:\n                    {\n                        *((uint8_T *)currRealRow) = (uint8_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint8_T *)currImagRow) = (uint8_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT16:\n                    {\n                        *((int16_T *)currRealRow) = (int16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int16_T *)currImagRow) = (int16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT16:\n                    {\n                        *((uint16_T *)currRealRow) = (uint16_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint16_T *)currImagRow) = (uint16_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_INT32:\n                    {\n                        *((int32_T *)currRealRow) = (int32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((int32_T *)currImagRow) = (int32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_UINT32:\n                    {\n                        *((uint32_T *)currRealRow) = (uint32_T)curRealValue;\n\n                        if (var->data.complex) {\n\n                            *((uint32_T *)currImagRow) = (uint32_T)curImagValue;\n                        }\n                    }\n                    break;\n                  case SS_BOOLEAN:\n                    {\n                        *((boolean_T *)currRealRow) = (boolean_T)(curRealValue != 0.0);\n\n                        if (var->data.complex) {\n\n                            *((boolean_T *)currImagRow) = (boolean_T)(curImagValue != 0.0);\n                        }\n                    }\n                    break;\n                } /* -- end of switch -- */\n\n                currRealRow += elSize;\n                if (var->data.complex) {\n                    currImagRow += elSize;\n                }\n            }\n        }\n\n        if(isVarDims){ /* update \"valueDimensions\" field */\n            for(j = 0; j < logWidth_valDims; j ++){\n                int32_T currDimsVal=0;\n                switch (currDimsSizePtr[j]) {\n                  case 1:\n                    currDimsVal = (**(((const uint8_T * const *) currDimsPtr)+j));\n                    break;\n                  case 2:\n                    currDimsVal = (**(((const uint16_T * const *) currDimsPtr)+j));\n                    break;\n                  case 4:\n                    currDimsVal = (**(((const uint32_T * const *) currDimsPtr)+j));\n                    break;\n                }\n                offset_valDims  = (size_t)(elSize_valDims *( var->rowIdx + nRows_valDims * j));\n                currValDimsRow  = ((char_T*) (var->valDims->dimsData)) + offset_valDims;\n\n                /* convert int_T to real_T */\n                currentSigDims = (real_T) currDimsVal;\n                (void) memcpy(currValDimsRow, &currentSigDims, elSize_valDims);\n                currValDimsRow += elSize_valDims;\n            }\n        }\n        \n        ++var->rowIdx;\n    }\n\n    return;\n\n} /* end rt_UpdateLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n \n \n/* Function: rt_UpdateStructLogVar =============================================\n * Abstract:\n *      Called to log data for a structure log variable.\n */\nvoid rt_UpdateStructLogVar(StructLogVar *var, const real_T *t, const void *data)\n{\n    LogVar       *values = var->signals.values;\n    const char_T *signal = data;\n    boolean_T *isVarDims = var->signals.isVarDims;\n    int i = 0;\n\n    /* time */\n    if (var->logTime) {\n        rt_UpdateLogVar(var->time, t, false);\n    }\n\n    /* signals */\n    while (values) {\n        size_t elSz = values->data.elSize;\n\n        rt_UpdateLogVar(values, signal, isVarDims[i]);\n\n        if (values->data.complex) elSz *= 2;\n        signal += elSz * values->data.nCols;\n\n        values = values->next;\n        i++;\n    }\n\n} /* end rt_UpdateStructLogVar */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * g1614989:Refactoring this function to accept number of elements\n *          instead of accepting signalInfo and index.\n */\nvoid* rt_getTempMemory(LogVar* var, int_T numEls);\n\nvoid* rt_getTempMemory(LogVar* var, int_T numEls)\n{\n    size_t elSize  = var->data.elSize;\n    size_t cmplxMult = var->data.complex ? 2 : 1;\n    /*\n     * g1689750: With multiword support for mat file logging in row major array layout, we need to allocate more space to\n     * store the data when the transpose operation is being performed. The additional space is required to store multiple\n     * chunks that each multi word contains.\n     */\n    size_t numOfChunks = var->data.dataTypeConvertInfo.conversionNeeded ? var->data.dataTypeConvertInfo.numOfChunk : 1;\n    void* tempMemory = malloc(elSize * numEls * cmplxMult * numOfChunks);\n    return tempMemory;\n}\n\n/*\n* g1614989:This function processes the signal data if a function pointer is available and then logs the data.\n*          If a function pointer is not present, signal data is logged without any processing.\n*          The idx parameter specifies which information from the SignalInfo to be used for processing and logging.\n*          When idx is -1, the provided signal info is to be used for processing and logging the data.\n*/\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogDataWithIndex(const RTWLogSignalInfo *signalInfo, int_T idx, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    RTWPreprocessingFcnPtr preprocessingPtr = NULL;\n    int_T numEls = -1;\n    if (idx == -1) {\n        preprocessingPtr = *(signalInfo->preprocessingPtrs);\n        numEls = *(signalInfo->numCols);\n    }\n    else {\n        preprocessingPtr = signalInfo->preprocessingPtrs[idx];\n        numEls = signalInfo->numCols[idx];\n    }\n\n    if (preprocessingPtr != NULL) {\n        void* curData = rt_getTempMemory(val, numEls);\n        preprocessingPtr(curData, data);\n        rt_UpdateLogVar(val, curData, isVarDims);\n        free(curData);\n    }\n    else {\n        rt_UpdateLogVar(val, data, isVarDims);\n    }\n}\n\n/*\n* g1614989:This function is called when each signal has a specific RTWLogSignalInfo structure defined.\n*/\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims);\n\nvoid rt_preProcessAndLogData(RTWLogSignalInfo signalInfo, LogVar* val, const void * data, boolean_T isVarDims)\n{\n    rt_preProcessAndLogDataWithIndex(&signalInfo, -1, val, data, isVarDims);\n}\n \n/* Function: rt_UpdateTXYLogVars ===============================================\n * Abstract:\n *\tUpdate the xFinal,T,X,Y variables that are being logged.\n */\nconst char_T *rt_UpdateTXYLogVars(RTWLogInfo *li, time_T *tPtr)\n{\n    return rt_UpdateTXXFYLogVars(li, tPtr, true);\n}\n \n/* Function: rt_UpdateTXXFYLogVars =============================================\n * Abstract:\n *\tUpdate xFinal and/or the T,X,Y variables that are being logged\n */\nconst char_T *rt_UpdateTXXFYLogVars(RTWLogInfo *li, time_T *tPtr, boolean_T updateTXY)\n{\n    LogInfo *logInfo     = rtliGetLogInfo(li);\n    int_T   matrixFormat = (rtliGetLogFormat(li) == 0);\n    const RTWLogSignalInfo* yInfo = rtliGetLogYSignalInfo(li);\n    const RTWLogSignalInfo* xInfo = rtliGetLogXSignalInfo(li);\n\n    /* time */\n    if (logInfo->t != NULL && updateTXY) {\n        rt_UpdateLogVar(logInfo->t, tPtr, false);\n    }\n\n    if (matrixFormat) {                                      /* MATRIX_FORMAT */\n        /* states */\n        if (logInfo->x != NULL || logInfo->xFinal != NULL) {\n            int8_T**               segAddr     = _rtliGetLogXSignalPtrs(li);\n            const int_T            *segLengths = xInfo->numCols;\n            int_T                  nSegments   = xInfo->numSignals;\n            RTWPreprocessingFcnPtr* preprocessingPtrs = xInfo->preprocessingPtrs;\n\n            if (logInfo->x != NULL && updateTXY) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->x, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n            if (logInfo->xFinal != NULL) {\n                const char_T *errorMessage = rt_UpdateLogVarWithDiscontiguousData(logInfo->xFinal, segAddr,\n                                                                                  segLengths, nSegments, \n                                                                                  preprocessingPtrs);\n                if (errorMessage != NULL) return(errorMessage);\n            }\n        }\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            LogVar **var = (LogVar**) (logInfo->y);\n            int_T  ny    = logInfo->ny;\n            int_T  i;\n            int    yIdx;\n            LogSignalPtrsType data = rtliGetLogYSignalPtrs(li);\n\n            for (i = 0, yIdx = 0; i < ny; i++) {\n                if (data[i] != NULL) {\n                    /* \n                       When outputs are logged in Matrix format, \n                       no variable-size signal logging is allowed.\n                    */\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *          Function pointer is now identified by using \n                     *          Y Signal Info instead of iterating over pre-processing \n                     *          function pointers.\n                    */ \n                    rt_preProcessAndLogData(yInfo[yIdx], var[yIdx], data[i], false);\n                    yIdx++;\n                }\n            }\n        }\n    } else {                                              /* STRUCTURE_FORMAT */\n        /* states */\n        if (logInfo->x != NULL && updateTXY) {\n            int_T             i;\n            StructLogVar      *var = logInfo->x;\n            LogVar            *val = var->signals.values;\n            int_T             nsig = var->signals.numSignals;\n            LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n\n            /* time */\n            if (var->logTime) {\n                rt_UpdateLogVar(var->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n\n        /* outputs */\n        if (logInfo->y != NULL && updateTXY) {\n            int_T             ny      = logInfo->ny;\n            LogSignalPtrsType data    = rtliGetLogYSignalPtrs(li);\n            StructLogVar      **var   = (StructLogVar**) (logInfo->y);\n\n            if (ny == 1) {\n                int_T  i;\n                int_T  dataIdx;\n                LogVar *val = var[0]->signals.values;\n                int_T  nsig = var[0]->signals.numSignals;\n                boolean_T   *isVarDims = var[0]->signals.isVarDims;\n\n                /* time */\n                if (var[0]->logTime) {\n                    rt_UpdateLogVar(var[0]->time, tPtr, false);\n                }\n\n                /* signals */\n                for (i = 0, dataIdx = 0; i < nsig; i++) {                    \n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogDataWithIndex(yInfo, i, val, data[dataIdx], isVarDims[i]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            } else {\n                int_T  i;\n                int_T  dataIdx;\n\n                for (i = 0, dataIdx = 0; i < ny && var[i] != NULL; i++) {\n                    LogVar *val = var[i]->signals.values;\n                    boolean_T   *isVarDims = var[i]->signals.isVarDims;\n\n                    /* time */\n                    if (var[i]->logTime) {\n                        rt_UpdateLogVar(var[i]->time, tPtr, false);\n                    }\n\n                    /* signals */\n                    while (data[dataIdx] == NULL) {\n                        ++dataIdx;\n                    }\n                    /* g1614989:Code refactoring and fix for logging issue.\n                     *         Function pointer is now identified by using \n                     *         Y Signal Info instead of iterating over pre-processing \n                     *         function pointers.\n                     */\n                    rt_preProcessAndLogData(yInfo[i], val, data[dataIdx], isVarDims[0]);\n                    dataIdx++;\n                    val = val->next;\n                }\n            }\n        }\n        /* final state */\n        if (logInfo->xFinal != NULL) {\n            StructLogVar *xf  = logInfo->xFinal;\n            LogVar       *val = xf->signals.values;\n            int_T        nsig = xf->signals.numSignals;\n            int_T        i;\n\n            /* time */\n            if (xf->logTime) {\n                rt_UpdateLogVar(xf->time, tPtr, false);\n            }\n\n            /* signals */\n            for (i = 0; i < nsig; i++) {\n                LogSignalPtrsType data = rtliGetLogXSignalPtrs(li);\n                /* g1614989:Code refactoring and fix for logging issue.\n                 *         Function pointer is now identified by using \n                 *         X Signal Info instead of iterating over pre-processing \n                 *         function pointers.\n                 */\n                rt_preProcessAndLogDataWithIndex(xInfo, i, val, data[i], false);\n                val = val->next;\n            }\n        }\n    }\n    return(NULL);\n} /* end rt_UpdateTXXFYLogVars */\n\n\n#ifdef __cplusplus\n}\n#endif\n          \n\n          \n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLoggingImpl =======================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLoggingImpl(const char_T *file, RTWLogInfo *li, boolean_T isRaccel)\n{\n    FILE          *fptr;\n    LogInfo       *logInfo     = (LogInfo*) rtliGetLogInfo(li);\n    LogVar        *var         = logInfo->logVarsList;\n    StructLogVar  *svar        = logInfo->structLogVarsList;\n    /* At this time, verbose is only needed if running rapid accelerator\n     * simulations. */\n    int           verbose      = isRaccel ? 0: 1;\n\n    boolean_T     emptyFile    = 1; /* assume */\n    boolean_T     errFlag      = 0;\n    const char_T  *msg;\n\n    /*******************************\n     * Create MAT file with header *\n     *******************************/\n    if ((fptr=fopen(file,\"w+b\")) == NULL) {\n        (void)fprintf(stderr,\"*** Error opening %s\",file);\n        goto EXIT_POINT;\n    }\n    if (rt_WriteMat5FileHeader(fptr)) {\n        (void)fprintf(stderr,\"*** Error writing to %s\",file);\n        goto EXIT_POINT;\n    }\n\n    /**************************************************\n     * First log all the variables in the LogVar list *\n     **************************************************/\n    while (var != NULL) {\n        if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n            (void)fprintf(stderr,\"*** Error writing %s due to: %s\\n\",file,msg);\n            errFlag = 1;\n            break;\n        }\n        if (var->nDataPoints > 0 || isRaccel) {\n            MatItem item;\n\n            item.type   = matMATRIX;\n            item.nbytes = 0; /* not yet known */\n            item.data   = &(var->data);\n            if (rt_WriteItemToMatFile(fptr, &item, MATRIX_ITEM)) {\n                (void)fprintf(stderr,\"*** Error writing log variable %s to \"\n                              \"file %s\",var->data.name, file);\n                errFlag = 1;\n                break;\n            }\n            emptyFile = 0;\n        }\n        var = var->next;\n    }\n    /* free up some memory by destroying the log var list here */\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n\n    /*******************************************************\n     * Next log all the variables in the StructLogVar list *\n     *******************************************************/\n    while (svar != NULL) {\n        MatItem item;\n\n        if (svar->logTime) {\n            var = svar->time;\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n        }\n\n        var = svar->signals.values;\n        while (var) {\n            if ( (msg = rt_FixupLogVar(var,verbose)) != NULL ) {\n                (void)fprintf(stderr, \"*** Error writing %s due to: %s\\n\",\n                              file, msg);\n                errFlag = 1;\n                break;\n            }\n            var = var->next;\n        }\n\n        item.type   = matMATRIX;\n        item.nbytes = 0; /* not yet known */\n        item.data   = svar;\n\n        if (rt_WriteItemToMatFile(fptr, &item, STRUCT_LOG_VAR_ITEM)) {\n            (void)fprintf(stderr,\"*** Error writing structure log variable \"\n                          \"%s to file %s\",svar->name, file);\n            errFlag = 1;\n            break;\n        }\n        emptyFile = 0;\n\n        svar = svar->next;\n    }\n\n    /******************\n     * Close the file *\n     ******************/\n    (void)fclose(fptr);\n    if (emptyFile || errFlag) {\n        (void)remove(file);\n    } else {\n        if( verbose ) {\n            (void)printf(\"** created %s **\\n\\n\", file);\n        }\n    }\n\n EXIT_POINT:\n\n    /****************\n     * free logInfo *\n     ****************/\n    rt_DestroyLogVar(logInfo->logVarsList);\n    logInfo->logVarsList = NULL;\n    rt_DestroyStructLogVar(logInfo->structLogVarsList);\n    logInfo->structLogVarsList = NULL;\n    FREE(logInfo->y);\n    logInfo->y = NULL;\n    FREE(logInfo);\n    rtliSetLogInfo(li,NULL);\n\n} /* end rt_StopDataLoggingImpl */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n\n/* Function: rt_StopDataLogging ================================================\n * Abstract:\n *\tWrite logged data to model.mat and free memory.\n */\nvoid rt_StopDataLogging(const char_T *file, RTWLogInfo *li)\n{\n    rt_StopDataLoggingImpl(file,li,false);\n\n} /* end rt_StopDataLogging */\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#else /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n#define rt_StartDataLogging(li, finalTime, stepSize, errStatus) NULL /* do nothing */\n#define rt_UpdateTXYLogVars(li, tPtr) NULL /* do nothing */\n#define rt_StopDataLogging(file, li) { (void(file)); } /* use file quiet unused macro warning */ /* do nothing */\n\n#endif /*!defined(MAT_FILE) || (defined(MAT_FILE) && MAT_FILE == 1)*/\n\n\n\n/* [eof] rt_logging.c */\n\n/* LocalWords:  Tfinal MAXNAM nonfinite DType PWS RSim Fixup logvar DDEFAULT th\n * LocalWords:  curr Realloc realloc inp biglong vijay ldexp TXY eof XFinal th\n * LocalWords:  TXXFY NULL typedefs ret polyspace NUL\n */\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};